{*
 * Project name:
     Can_Spi_1st (CAN Network demonstration with mikroE's CAN-SPI module)
 * Copyright:
     (c) MikroElektronika, 2005-2010.
 * Description:
      This project is a simple demonstration of CAN on PIC16F887. With minor
      adjustments, it should work with any other PIC MCU that has a SPI module.
      This code demonstrates how to use CANSPI library functions and procedures.
      It is used together with the CAN_2nd example (on second MCU), and it can
      be used to test the connection of PIC to the CAN network.
      This node initiates the communication with the Can_2nd node by sending some
      data to its address. The 2nd node responds by sending back the data incre-
      mented by 1. This (1st) node then does the same and sends incremented data
      back to 2nd node, etc.
 * Test configuration:
     MCU:             PIC16F887
                      http://ww1.microchip.com/downloads/en/DeviceDoc/41291F.pdf
     Dev.Board:       EasyPIC6
                      http://www.mikroe.com/eng/products/view/297/easypic6-development-system/
     Oscillator:      HS, 8.0000 MHz
     Ext. Modules:    ac:CAN_SPI_Board on PORTC
     SW:              mikroPascal PRO for PIC
                      http://www.mikroe.com/eng/products/view/10/mikropascal-pro-for-pic/
 * NOTES:
     - Consult the CAN standard about CAN bus termination resistance.
     - Turn on LEDs on PORTB SW9.2 (board specific)
 *}

program Can_Spi_1st;

var Can_Init_Flags, Can_Send_Flags, Can_Rcv_Flags : byte;   // can flags
    Rx_Data_Len : byte;                                     // received data length in bytes
    RxTx_Data   : array[8] of byte;                         // can rx/tx data buffer
    Msg_Rcvd : byte;                                        // reception flag
    Tx_ID, Rx_ID : longint;                                 // can rx and tx ID

// CANSPI module connections
var CanSpi_CS : sbit at  RC0_bit;
    CanSpi_CS_Direction : sbit at TRISC0_bit;
    CanSpi_Rst : sbit at RC2_bit;
    CanSpi_Rst_Direction : sbit at TRISC2_bit;
// End CANSPI module connections

begin

  ANSEL  := 0;                       // Configure AN pins as digital I/O
  ANSELH := 0;
  PORTB := 0;
  TRISB := 0;

  Can_Init_Flags := 0;                                      //
  Can_Send_Flags := 0;                                      // clear flags
  Can_Rcv_Flags  := 0;                                      //

  Can_Send_Flags := _CANSPI_TX_PRIORITY_0 and               // form value to be used
                    _CANSPI_TX_XTD_FRAME and                //     with CANSPIWrite
                    _CANSPI_TX_NO_RTR_FRAME;

  Can_Init_Flags := _CANSPI_CONFIG_SAMPLE_THRICE and        // form value to be used
                    _CANSPI_CONFIG_PHSEG2_PRG_ON and        // with CANSPIInit
                    _CANSPI_CONFIG_XTD_MSG and
                    _CANSPI_CONFIG_DBL_BUFFER_ON and
                    _CANSPI_CONFIG_VALID_XTD_MSG;

  SPI1_Init();                                                      // initialize SPI module
  CANSPIInitialize(1,3,3,3,1,Can_Init_Flags);                       // Initialize external CANSPI module
  CANSPISetOperationMode(_CANSPI_MODE_CONFIG,0xFF);                 // set CONFIGURATION mode
  CANSPISetMask(_CANSPI_MASK_B1,-1,_CANSPI_CONFIG_XTD_MSG);         // set all mask1 bits to ones
  CANSPISetMask(_CANSPI_MASK_B2,-1,_CANSPI_CONFIG_XTD_MSG);         // set all mask2 bits to ones
  CANSPISetFilter(_CANSPI_FILTER_B2_F4,3,_CANSPI_CONFIG_XTD_MSG);   // set id of filter B2_F4 to 3

  CANSPISetOperationMode(_CANSPI_MODE_NORMAL,0xFF);                 // set NORMAL mode

  RxTx_Data[0] := 9;                                                // set initial data to be sent

  Tx_ID := 12111;                                                   // set transmit ID

  CANSPIWrite(Tx_ID, RxTx_Data, 1, Can_Send_Flags);                 // send initial message
  while (TRUE) do
    begin                                                                       // endless loop
      Msg_Rcvd := CANSPIRead(Rx_ID , RxTx_Data , Rx_Data_Len, Can_Rcv_Flags);   // receive message
      if ((Rx_ID = 3) and Msg_Rcvd) then                                        // if message received check id
        begin
          PORTB := RxTx_Data[0];                                                // id correct, output data at PORTB
          Inc(RxTx_Data[0]) ;                                                   // increment received data
          Delay_ms(10);
          CANSPIWrite(Tx_ID, RxTx_Data, 1, Can_Send_Flags);                     // send incremented data back
        end;
    end;
end.