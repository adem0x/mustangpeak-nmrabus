unit NMRABus;

uses
  CAN_Data;
  
{$I Options.inc}

// Mustangpeak NMRANet allocated ID's  $05, $01, $01, $01, $07, $xx
const
  MUSTANGPEAK_UNIQUE_ID_0_LO = $01010700;
  MUSTANGPEAK_UNIQUE_ID_0_HI = $00000501;
  
  RID_TIME_COUNT_MAX = 21;   //  Clock Ticks every 1ms so to ensure at least 20ms need 21 asyncronous ticks

// *****************************************************************************
//  Extended CAN Frames
//  29 Bits Divided as follows:
//     - 1 Bit = Priority (1 = Low Priority typical)
//     - 4 Bits = Frame Type (FT_xxxx Constants)
//     - 12 Bits = Destination Node Address Alias or Message Type (MT_xxx Constants)
//     - 12 Bits = Source Node Address Alias
//
// Frame Types.  These define what the Frame of the CAN message consists of.
const
  FT_CAN             = $0;   // Frame Type CAN Control Message
  FT_CID0            = $4000;  // First 12 Bits of 48 bit Node ID
  FT_CID1            = $5000;  // 2rd 12 Bits of 48 bit Node ID
  FT_CID2            = $6000;  // 3nd 12 Bits of 48 bit Node ID
  FT_CID3            = $7000;  // Last 12 Bits of 48 bit Node ID
  FT_RID             = $0700;  // Reserve ID
  FT_BROADCAST_1     = $08;  // Broadcast Message
  FT_BROADCAST_2     = $09;  // Broadcast Message again....
  FT_DATAGRAM_FIRST  = $0C;  // First Frame of Datagram
  FT_DATAGRAM_LAST   = $0D;  // Last Frame of Datagram
  FT_DATAGRAM_SINGLE = $0E;  // Single Frame Datagram
  FT_STREAM          = $0F;  // Stream Data
  
  FT_CID_MASK        = $17000000;
  
  // NMRABus States
  BS_PERMITED          = $01;    // CAN Frame Layer is permitted (Node ID's resolved with bus)
  BS_INITIALIZED       = $02;    // Message Layer has sent its first Initialize Complete Message

type
  TNodeID = array[0..1] of DWORD;
  TNodeAliasID = Word;
  

  TNMRABus = record
    Node_ID: TNodeID;                // Unique 48 Bit ID for Node
    Unique_ID_Global_Seed: TNodeID;  // Seed for Random Number Generator in case we have to reseed because of a duplicate ID
    Node_Alias_ID: TNodeAliasID;     // 12 Bit Alias ID
    RIDTimeCounter: Word;            // Times the 20ms spec to wait for duplicate Node ID
    
    State: Word;                     // State of the Bus; see the BS_xxxx
  end;
  
  

var
  NMRABus: TNMRABus;
  
  
  procedure NMRABus_Connect;
  function NMRABus_Connected: Boolean;
  procedure NMRABus_Disconnect;
  procedure NMRABus_Initialize;
  procedure NMRABus_GlobalTimer;
  procedure RecreateAliasID;

implementation

function NMRABus_CheckIDFrameEncode(CID_Type: Word): DWord;
//
// Pass what CID Type (FT_CID0..FT_CID3) and returns the 29 Bit CAN Header based on current NodeID and generated Alias
//
begin
  Result := $10000000 or NMRABus.Node_Alias_ID;
  if CID_Type = FT_CID3 then
    Result := Result or $04000000 or ((NMRABus.Node_ID[1] shr 8) and ($00FFF000))
  else
  if CID_Type = FT_CID2 then
    Result := Result or $05000000 or ((NMRABus.Node_ID[1] shl 12) and ($00FFF000))
  else
  if CID_Type = FT_CID1 then
    Result := Result or $06000000 or ((NMRABus.Node_ID[0] shr 8) and ($00FFF000))
  else
  if CID_Type = FT_CID0 then
    Result := Result or $07000000 or ((NMRABus.Node_ID[0] shl 12) and ($00FFF000))
  else
  if CID_Type = FT_RID then
    Result := Result or $00700000;
end;

procedure LoadNodeID(var NodeID: TNodeID; Upper, Lower: DWORD);
begin
  NodeID[0] := Lower;
  NodeID[1] := Upper;
end;

procedure PsudoRandomNumberGenerator;
var
  temp1,              // Upper 24 Bits of temp 48 bit number
  temp2: DWORD;       // Lower 24 Bits of temp 48 Bit number
begin
  temp1 := ((NMRABus.Unique_ID_Global_Seed[1] shl 9) or ((NMRABus.Unique_ID_Global_Seed[0] shr 15) and $000001FF)) and $00FFFFFF;           // x(i+1)(2^9 + 1)*x(i) + C  = 2^9 * x(i) + x(i) + C
  temp2 := (NMRABus.Unique_ID_Global_Seed[0] shl 9) and $00FFFFFF;                                                                  // Calculate 2^9 * x

  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Unique_ID_Global_Seed[0] + temp2 + $7A4BA9;                                                    // Now y = 2^9 * x so all we have left is x(i+1) = y + x + c
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Unique_ID_Global_Seed[1] + temp1 + $1B0CA3;

  NMRABus.Unique_ID_Global_Seed[1] := (NMRABus.Unique_ID_Global_Seed[1] and $00FFFFFF) or (NMRABus.Unique_ID_Global_Seed[0] and $FF000000) shr 24;   // Handle the carries of the lower 24 bits into the upper
  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Unique_ID_Global_Seed[0] and $00FFFFFF;
end;

function GenerateID_Alias_From_Global_Seed: Word;
begin
  Result := (NMRABus.Unique_ID_Global_Seed[0] xor NMRABus.Unique_ID_Global_Seed[1] xor (NMRABus.Unique_ID_Global_Seed[0] shr 12) xor (NMRABus.Unique_ID_Global_Seed[1] shr 12)) and $00000FFF;
end;

procedure CreateAliasID(Regenerate: Boolean);
begin
  if Regenerate then
    PsudoRandomNumberGenerator;
  NMRABus.Node_Alias_ID := GenerateID_Alias_From_Global_Seed;
  if NMRABus.Node_Alias_ID = 0 then
  begin
    PsudoRandomNumberGenerator;
    NMRABus.Node_Alias_ID := GenerateID_Alias_From_Global_Seed;
  end
end;

procedure RecreateAliasID;
begin
  CreateAliasID(True)
end;

procedure NMRABus_Initialize;
begin
  NMRABus.Node_ID[0] := MUSTANGPEAK_UNIQUE_ID_0_LO;
  NMRABus.Node_ID[1] := MUSTANGPEAK_UNIQUE_ID_0_HI;

  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Node_ID[0];
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Node_ID[1];

  CreateAliasID(False);
end;

function NMRABus_Connected: Boolean;
begin
  Result := NMRABus.State and BS_PERMITED <> 0
end;

procedure NMRABus_GlobalTimer;
begin
  Inc(NMRABus.RIDTimeCounter)
end;

function UniqueNodeIDTestPass: Boolean;
var
  Packet: TCAN_Packet;
begin
  Result := False;
  CAN_Layer_Buffer.Transmitting := True;
  CAN_Layer_Buffer.ReceivedRID := False;
  // Transmitting and the RIDTimeCounter are reset in the Tx Complete Interrupt
  while CAN_Layer_Buffer.Transmitting do
    Delay_us(100);
      
  while NMRABus.RIDTimeCounter < RID_TIME_COUNT_MAX do
    Result := not CAN_Layer_Buffer.ReceivedRID
end;

procedure NMRABus_Connect;
var
  Packet: TCAN_Packet;
begin
  NMRABus.State := NMRABus.State and not BS_PERMITED;                           // Not permitted until we successfully get through this log in series
  CAN_Data_LoadPacket(@Packet, NMRABus_CheckIDFrameEncode(FT_CID0), 0, 0, 0, 0, 0, 0, 0, 0, 0, True);
  CAN_Data_ListAddCANLayer(@Packet);                                            // Load the high priority transmitter buffer
  if UniqueNodeIDTestPass then                                                  // Wait 50ms+ for RID to be received
  begin
    CAN_Data_LoadPacket(@Packet, NMRABus_CheckIDFrameEncode(FT_CID1), 0, 0, 0, 0, 0, 0, 0, 0, 0, True);
    CAN_Data_ListAddCANLayer(@Packet);                                          // Load the high priority transmitter buffer
    if UniqueNodeIDTestPass then                                                // Wait 50ms+ for RID to be received
    begin
      CAN_Data_LoadPacket(@Packet, NMRABus_CheckIDFrameEncode(FT_CID2), 0, 0, 0, 0, 0, 0, 0, 0, 0, True);
      CAN_Data_ListAddCANLayer(@Packet);                                        // Load the high priority transmitter buffer
      if UniqueNodeIDTestPass then                                              // Wait 50ms+ for RID to be received
      begin
        CAN_Data_LoadPacket(@Packet, NMRABus_CheckIDFrameEncode(FT_CID3), 0, 0, 0, 0, 0, 0, 0, 0, 0, True);
        CAN_Data_ListAddCANLayer(@Packet);                                      // Load the high priority transmitter buffer
        if UniqueNodeIDTestPass then                                            // Wait 50ms+ for RID to be received
        begin
          CAN_Data_LoadPacket(@Packet, NMRABus_CheckIDFrameEncode(FT_RID), 0, 0, 0, 0, 0, 0, 0, 0, 0, True);
          CAN_Data_ListAddCANLayer(@Packet);                                    // Load the high priority transmitter buffer
          if UniqueNodeIDTestPass then                                          // Wait 50ms+ for RID to be received
            NMRABus.State := NMRABus.State or BS_PERMITED;
        end
      end
    end
  end
end;

procedure NMRABus_Disconnect;
begin
end;

end.