unit NMRABus;

uses
  CAN_Data;
  
{$I Options.inc}

// Mustangpeak NMRANet allocated ID's  $05, $01, $01, $01, $07, $xx
const
  MUSTANGPEAK_UNIQUE_ID_0_LO = $00010700;  // The Bottom 3 Bytes
  MUSTANGPEAK_UNIQUE_ID_0_HI = $00050101;  // The Top 3 Bytes
  
  RID_TIME_COUNT_MAX = 51;   //  Clock Ticks every 1ms so to ensure at least 50ms need 51 asyncronous ticks

// *****************************************************************************
//  Extended CAN Frames
//  29 Bits Divided as follows:
//     - 1 Bit = Priority (1 = Low Priority typical)
//     - 4 Bits = Frame Type (FT_xxxx Constants)
//     - 12 Bits = Destination Node Address Alias or Message Type (MT_xxx Constants)
//     - 12 Bits = Source Node Address Alias
//
// Frame Types.  These define what the Frame of the CAN message consists of.
const
  FT_CAN             = $0;   // Frame Type CAN Control Message
  FT_CID0            = $4000;  // First 12 Bits of 48 bit Node ID
  FT_CID1            = $5000;  // 2rd 12 Bits of 48 bit Node ID
  FT_CID2            = $6000;  // 3nd 12 Bits of 48 bit Node ID
  FT_CID3            = $7000;  // Last 12 Bits of 48 bit Node ID
  FT_RID             = $0700;  // Reserve ID
  FT_AMD             = $0701;  // Alias Map Definition
  FT_AME             = $0702;  // Alias Mapping Enquiry
  FT_AMR             = $0703;  // Alias Map Reset Fram
  
  
  FT_INITIALIZATION_COMPLETE        = $19017000;
  FT_VERIFY_NODE_ID_NUMBER_DEST     = $1E000000;
  FT_VERIFY_NODE_ID_NUMBER_NO_DEST  = $180A7000;
  FT_VERIFIED_NODE_ID_NUMBER        = $180B7000;
  FT_OPTIONAL_INTERACTION_REJECTED  = $1E000000;
  FT_TERMINATE_DUE_TO_ERROR         = $1E000000;

  FT_BROADCAST_1     = $08;  // Broadcast Message
  FT_BROADCAST_2     = $09;  // Broadcast Message again....
  FT_DATAGRAM_FIRST  = $0C;  // First Frame of Datagram
  FT_DATAGRAM_LAST   = $0D;  // Last Frame of Datagram
  FT_DATAGRAM_SINGLE = $0E;  // Single Frame Datagram
  FT_STREAM          = $0F;  // Stream Data
  
  FT_CID_MASK        = $17000000;
  
  // NMRABus States
  BS_PERMITED          = $01;    // CAN Frame Layer is permitted (Node ID's resolved with bus)
  BS_INITIALIZED       = $02;    // Message Layer has sent its first Initialize Complete Message

type
  TNodeID = array[0..1] of DWORD;    // The Bottom 3 Bytes = [0] and the Top 3 Bytes = [1]
  TNodeAliasID = Word;
  

  TNMRABus = record
    Node_ID: TNodeID;                // Unique 48 Bit ID for Node
    Unique_ID_Global_Seed: TNodeID;  // Seed for Random Number Generator in case we have to reseed because of a duplicate ID
    Node_Alias_ID: TNodeAliasID;     // 12 Bit Alias ID
    RIDTimeCounter: Word;            // Times the 20ms spec to wait for duplicate Node ID
    
    State: Word;                     // State of the Bus; see the BS_xxxx
  end;
  
  

var
  NMRABus: TNMRABus;
  procedure NMRABus_Connect;
  function NMRABus_Connected: Boolean;
  procedure NMRABus_Disconnect;
  procedure NMRABus_Initialize;
  procedure NMRABus_GlobalTimer;
  procedure RecreateAliasID;

implementation

// *****************************************************************************
//  function CoreCANControlFramePacket
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function CoreCANControlFramePacket: DWord;
begin
  Result := $10000000 or NMRABus.Node_Alias_ID;
end;

// *****************************************************************************
//  function NMRABus_CheckIDFrameEncode
//     Parameters:
//     Returns:
//
//     Description:
//
// Pass what CID Type (FT_CID0..FT_CID3) and returns the 29 Bit CAN Header based on current NodeID and generated Alias
//
// *****************************************************************************
function NMRABus_CheckIDFrameEncode(CID_Type: Word): DWord;
begin

  if CID_Type = FT_CID3 then
    Result := CoreCANControlFramePacket or $04000000 or ((NMRABus.Node_ID[1] shr 8) and $00FFF000)
  else
  if CID_Type = FT_CID2 then
    Result := CoreCANControlFramePacket or $05000000 or ((NMRABus.Node_ID[1] shl 12) and $00FFF000)
  else
  if CID_Type = FT_CID1 then
    Result := CoreCANControlFramePacket or $06000000 or ((NMRABus.Node_ID[0] shr 8) and $00FFF000)
  else
  if CID_Type = FT_CID0 then
    Result := CoreCANControlFramePacket or $07000000 or ((NMRABus.Node_ID[0] shl 12) and $00FFF000)
  else
  if CID_Type = FT_RID then
    Result := CoreCANControlFramePacket or $00700000;
end;

// *****************************************************************************
//  procedure LoadNodeID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure LoadNodeID(var NodeID: TNodeID; Upper, Lower: DWORD);
begin
  NodeID[0] := Lower;
  NodeID[1] := Upper;
end;

// *****************************************************************************
//  procedure PsudoRandomNumberGenerator
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure PsudoRandomNumberGenerator;
var
  temp1,              // Upper 24 Bits of temp 48 bit number
  temp2: DWORD;       // Lower 24 Bits of temp 48 Bit number
begin
  temp1 := ((NMRABus.Unique_ID_Global_Seed[1] shl 9) or ((NMRABus.Unique_ID_Global_Seed[0] shr 15) and $000001FF)) and $00FFFFFF;           // x(i+1)(2^9 + 1)*x(i) + C  = 2^9 * x(i) + x(i) + C
  temp2 := (NMRABus.Unique_ID_Global_Seed[0] shl 9) and $00FFFFFF;                                                                  // Calculate 2^9 * x

  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Unique_ID_Global_Seed[0] + temp2 + $7A4BA9;                                                    // Now y = 2^9 * x so all we have left is x(i+1) = y + x + c
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Unique_ID_Global_Seed[1] + temp1 + $1B0CA3;

  NMRABus.Unique_ID_Global_Seed[1] := (NMRABus.Unique_ID_Global_Seed[1] and $00FFFFFF) or (NMRABus.Unique_ID_Global_Seed[0] and $FF000000) shr 24;   // Handle the carries of the lower 24 bits into the upper
  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Unique_ID_Global_Seed[0] and $00FFFFFF;
end;

// *****************************************************************************
//  function GenerateID_Alias_From_Global_Seed
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function GenerateID_Alias_From_Global_Seed: Word;
begin
  Result := (NMRABus.Unique_ID_Global_Seed[0] xor NMRABus.Unique_ID_Global_Seed[1] xor (NMRABus.Unique_ID_Global_Seed[0] shr 12) xor (NMRABus.Unique_ID_Global_Seed[1] shr 12)) and $00000FFF;
end;

// *****************************************************************************
//  procedure CreateAliasID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure CreateAliasID(Regenerate: Boolean);
begin
  if Regenerate then
    PsudoRandomNumberGenerator;
  NMRABus.Node_Alias_ID := GenerateID_Alias_From_Global_Seed;
  if NMRABus.Node_Alias_ID = 0 then
  begin
    PsudoRandomNumberGenerator;
    NMRABus.Node_Alias_ID := GenerateID_Alias_From_Global_Seed;
  end
end;

// *****************************************************************************
//  procedure RecreateAliasID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure RecreateAliasID;
begin
  CreateAliasID(True)
end;

// *****************************************************************************
//  procedure NMRABus_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Initialize;
begin
  NMRABus.Node_ID[0] := MUSTANGPEAK_UNIQUE_ID_0_LO;
  NMRABus.Node_ID[1] := MUSTANGPEAK_UNIQUE_ID_0_HI;

  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Node_ID[0];
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Node_ID[1];

  CreateAliasID(False);
end;

// *****************************************************************************
//  function NMRABus_Connected
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRABus_Connected: Boolean;
begin
  Result := NMRABus.State and BS_PERMITED <> 0
end;

// *****************************************************************************
//  procedure NMRABus_GlobalTimer
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_GlobalTimer;
begin
  Inc(NMRABus.RIDTimeCounter);
end;

// *****************************************************************************
//  function UniqueNodeIDTestPass
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function UniqueNodeIDTestPass(MessageType: Word): Boolean;
var
  Packet: TCAN_Packet;
begin
  Result := False;
  CAN_Data_LoadPacket(@Packet, NMRABus_CheckIDFrameEncode(MessageType), 0, 0, 0, 0, 0, 0, 0, 0, 0, True);
  CAN_Data_ListAddCANLayer(@Packet);                                            // Load the high priority transmitter buffer
  while CAN_Layer_Buffer.State and CAN_LAYER_STATE_TRANSMIT_PENDING <> 0 do;    // Wait for the Bus Timer to load and transmit the packet on the CAN Bus
  while NMRABus.RIDTimeCounter < RID_TIME_COUNT_MAX do;                         // The message has hit the CAN Bus now wait and see if anyone objects to our Alias ID
  if CAN_Layer_Buffer.State and CAN_LAYER_STATE_ERROR = 0 then
    Result := CAN_Layer_Buffer.State and CAN_LAYER_STATE_SUCCESS <> 0
end;

// *****************************************************************************
//  procedure LoadFull48BitNodeIDFrame
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure LoadFull48BitNodeIDFrame(Header: DWord);
var
  Packet: TCAN_Packet;
begin
  CAN_Data_LoadPacket(@Packet,
                      Header,
                      6,
                      0,
                      0,
                      NMRABus.Node_ID[0] shr 0,
                      NMRABus.Node_ID[0] shr 8,
                      NMRABus.Node_ID[0] shr 16,
                      NMRABus.Node_ID[1],
                      NMRABus.Node_ID[1] shr 8,
                      NMRABus.Node_ID[1] shr 16,
                      True);
  CAN_Data_ListAddCANLayer(@Packet);                                            // Load the high priority transmitter buffer
end;

// *****************************************************************************
//  procedure TransmitAliasMapDefinitionFrame
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure TransmitAliasMapDefinitionFrame;
begin
  LoadFull48BitNodeIDFrame(CoreCANControlFramePacket or FT_AMD)
end;


procedure TransmitMessageFrame(Header: DWord; DestinationNodeID: DWord; ByteCount: Word; Byte7, Byte6, Byte5, Byte4, Byte3, Byte2, Byte1, Byte0: Byte);
var
  Packet: TCAN_Packet;
begin
  if DestinationNodeID <> 0 then
    Header := Header or (DestinationNodeID and $00000FFF);
    
  CAN_Data_LoadPacket(@Packet,
                      Header,
                      ByteCount,
                      Byte7,
                      Byte6,
                      Byte5,
                      Byte4,
                      Byte3,
                      Byte2,
                      Byte1,
                      Byte0,
                      True);
  CAN_Data_ListAddCANLayer(@Packet);                                            // Load the high priority transmitter buffer
end;

procedure NMRABus_Connect;
begin
  NMRABus.State := NMRABus.State and not BS_PERMITED;                           // Not permitted until we successfully get through this log in series
  if UniqueNodeIDTestPass(FT_CID0) then                                         // Wait 50ms+ for RID to be received
    if UniqueNodeIDTestPass(FT_CID1) then                                       // Wait 50ms+ for RID to be received
      if UniqueNodeIDTestPass(FT_CID2) then                                     // Wait 50ms+ for RID to be received
        if UniqueNodeIDTestPass(FT_CID3) then                                   // Wait 50ms+ for RID to be received
          if UniqueNodeIDTestPass(FT_RID) then                                  // Wait 50ms+ for RID to be received
          begin
            TransmitAliasMapDefinitionFrame;                                    // 6.2.2
            NMRABus.State := NMRABus.State or BS_PERMITED;
            LoadFull48BitNodeIDFrame(FT_INITIALIZATION_COMPLETE);
          end;
end;

// *****************************************************************************
//  procedure NMRABus_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Disconnect;
begin
  NMRABus.State := NMRABus.State and not BS_PERMITED;
end;

end.