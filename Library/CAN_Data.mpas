unit CAN_Data;

{$I Options.inc}

const
  MAX_CAN_LIST_LENGTH = 6;
  MAX_CAN_DATA_BYTES = 8;

type
  TCANData = array[8] of Byte;
  
  TCAN_Packet = record
    ID: DWord;                                                                  // Standard or Extended ID
    Count: Byte;                                                                // Number of Bytes in Packet
    Bytes: TCANData;                                                            // Packet Information
    ExtendedID: Boolean;                                                        //
  end;
  PCAN_Packet = ^TCAN_Packet;
  
  TCAN_List = record                                                            // Message Layer list of Packets
    List: array[0..MAX_CAN_LIST_LENGTH-1] of TCAN_Packet;
    Count: Byte;
    Head: Byte;
    Tail: Byte;
  end;
  PCAN_List = ^TCAN_List;
  
  TCAN_Layer_Buffer = record                                                    // CAN Layer Packets, since this layer is well defined as a high priority "question"/"response" type interchange only one level of buffing is used
    Packet: TCAN_Packet;
    Full,
    Transmitting,
    ReceivedRID: Boolean;
  end;
  PCAN_Layer_Buffer = ^TCAN_Layer_Buffer;
  
var
  CAN_Tx_List: TCAN_List;
  CAN_Rx_List: TCAN_List;
  CAN_Layer_Buffer: TCAN_Layer_Buffer;
  
// Initializes the unit
procedure CAN_Data_Initialize;
// Helper to load the passed packet reference with the passed data
procedure CAN_Data_LoadPacket(Packet: PCAN_Packet; ID: DWord; DataCount: Byte; Byte7, Byte6, Byte5, Byte4, Byte3, Byte2, Byte1, Byte0: Byte; IsExtended: Boolean);
// Queue the passed packet into the buffer.  The passed packet is copied and can be freed when function returns.  If Queue is full returns False
function CAN_Data_ListAddMessageLayer(List: PCAN_List; Packet: PCAN_Packet): Boolean;
// Receives the next received packet.  Returns False if there are none in the Queue
function CAN_Data_NextPacketMessageLayer(List: PCAN_List; var Packet: TCAN_Packet): Boolean;
// Queue the passed packet into the buffer.  The passed packet is copied and can be freed when function returns.
function CAN_Data_ListAddCANLayer(Packet: PCAN_Packet): Boolean;

implementation

procedure InitializeQueue(List: PCAN_List);
var
  i, j: Integer;
begin
  for i := 0 to MAX_CAN_LIST_LENGTH - 1 do
  begin
    List^.List[i].ID := 0;
    List^.List[i].Count := 0;
    for j := 0 to MAX_CAN_DATA_BYTES-1 do
      List^.List[i].Bytes[j] := 0;
    List^.Head := 0;
    List^.Tail := 0;
    List^.Count := 0;
  end;
end;

procedure CAN_Data_Initialize;
begin
  InitializeQueue(@CAN_Rx_List);
  InitializeQueue(@CAN_Tx_List);
  CAN_Layer_Buffer.Full := False;
  CAN_Layer_Buffer.Transmitting := False;
end;

procedure CAN_Data_LoadPacket(Packet: PCAN_Packet; ID: DWord; DataCount: Byte; Byte7, Byte6, Byte5, Byte4, Byte3, Byte2, Byte1, Byte0: Byte; IsExtended: Boolean);
begin
  Packet^.ID := ID;
  Packet^.Count := DataCount;
  Packet^.Bytes[0] := Byte0;
  Packet^.Bytes[1] := Byte1;
  Packet^.Bytes[2] := Byte2;
  Packet^.Bytes[3] := Byte3;
  Packet^.Bytes[4] := Byte4;
  Packet^.Bytes[5] := Byte5;
  Packet^.Bytes[6] := Byte6;
  Packet^.Bytes[7] := Byte7;
  Packet^.ExtendedID := IsExtended;
end;

function CAN_Data_List_Full(List: PCAN_List): Boolean;
begin
  Result := List^.Count = MAX_CAN_LIST_LENGTH
end;

procedure QueuePacket(Queue: PCAN_List; Packet: PCAN_Packet);
begin
  Queue^.List[CAN_Rx_List.Head] := Packet^;   // The head is already setup
  Inc(Queue^.Head);                            // Move to the next possible head
  if Queue^.Head >= MAX_CAN_LIST_LENGTH then   // Circular list
    Queue^.Head := 0;
  Inc(Queue^.Count);                           // Update the count
end;

function CAN_Data_ListAddMessageLayer(List: PCAN_List; Packet: PCAN_Packet): Boolean;
begin
  if not CAN_Data_List_Full(List) then
  begin
    QueuePacket(List, Packet);
    Result := True;
  end else
    Result := False
end;

function CAN_Data_NextPacketMessageLayer(List: PCAN_List; var Packet: TCAN_Packet): Boolean;
begin
  if List^.Count > 0 then
  begin
    Packet := List^.List[CAN_Rx_List.Tail];
    Inc(List^.Tail);
    if List^.Tail >= MAX_CAN_LIST_LENGTH then
      List^.Tail := 0;
    Dec(List^.Count);
    Result := True;
  end else
    Result := False
end;

function CAN_Data_ListAddCANLayer(Packet: PCAN_Packet): Boolean;
begin
  if not CAN_Layer_Buffer.Full then
  begin
    CAN_Layer_Buffer.Packet := Packet^;
    CAN_Layer_Buffer.Full := True;
    CAN_Layer_Buffer.Transmitting := True;
    Result := True
  end else
    Result := False
end;

function CAN_Data_GetBufferCANLayer: PCAN_Layer_Buffer;
begin
  if CAN_Layer_Buffer.Full then
    Result := @CAN_Layer_Buffer
  else
    Result := nil
end;


end.