program dsPIC33EP_NMRAnetCommandStation;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//     2012-11-13:   Converted to the dsPIC33EP
//     2012-11-13:   Updated to v2 of the NMRAbus Library
//
// * Description:
//    Implements a NMRABus based Command Station
//
//
//
// ******************************************************************************

uses
  NMRAnetStateMachine,
  NMRAnetDefines,
  NMRAnetAppCallbacks,
  NMRAnetDCC,
  MCU_Setup_dsPIC33EP64GP502,
  _25AAxxxx,
  NMRAnetBufferPools,
  NMRAnetNode,
  NodeIDs;

{$I Options.inc}

var
  // EEPROM SPI PINS
  CS_Bank_0                         : sbit at LATB6_bit;
  CS_Bank_0_Direction               : sbit at TRISB6_bit;
  EE_PROM_Hold                      : sbit at LATB5_bit;
  EEPROM_Hold_Direction             : sbit at TRISB5_bit;

  // DCC SIGNAL PINS
  H_Bridge_A_Lo                     : sbit at LATA1_bit;
  H_Bridge_A_Hi                     : sbit at LATB0_bit;
  H_Bridge_B_Lo                     : sbit at LATB1_bit;
  H_Bridge_B_Hi                     : sbit at LATB4_bit;

  H_Bridge_A_Lo_Direction           : sbit at TRISA1_bit;
  H_Bridge_A_Hi_Direction           : sbit at TRISB0_bit;
  H_Bridge_B_Lo_Direction           : sbit at TRISB1_bit;
  H_Bridge_B_Hi_Direction           : sbit at TRISB4_bit;

// *****************************************************************************
//  INTERRUPTS
// *****************************************************************************

procedure INTERRUPT_DCC_Timer(); iv IVT_ADDR_T1INTERRUPT;
begin
  T1IF_bit := 0;                                                                // Clear the Flag

      LATA4_bit := not LATA4_bit;


  // Toggle the Bridge
  H_Bridge_A_Lo := 0;                                                           // Bridge Off
  H_Bridge_A_Hi := 0;                                                           // Bridge Off
  H_Bridge_B_Lo := 0;                                                           // Bridge Off
  H_Bridge_B_Hi := 0;                                                           // Bridge Off
  if Track.TX_Flags.TRANSMITTING_FLAG_DCC_PIN_BIT = 1 then
  begin
    H_Bridge_A_Lo := 1;
    H_Bridge_B_Hi := 1;
  end else
  begin
    H_Bridge_A_Hi := 1;
    H_Bridge_B_Lo := 1;
  end;

  // Now we can update the xxxx_DCC_PIN_BIT flags for the next 56us time slot
  NMRA_DCC_56us_TimeTick(@Track);                                                         // < 1us
  NMRA_DCC_TransmitterStateMachine(@Track);                                               // < 5us
  NMRA_DCC_LoadPacketIntoTransmitterStateMachine(@Track, PREAMBLE_BIT_COUNT_NORMAL);      // < 11us    Max
end;

procedure INTERRUPT_1ms_Timer(); iv IVT_ADDR_T2INTERRUPT;
// Called once every 100m
var
  i: Integer;
begin
  T2IF_bit := 0;                                                                // Clear the Flag
  for i := 0 to Nodes.AllocatedCount - 1 do
    NMRAnetStateMachine_100ms_Timer(Nodes.AllocatedList[i]);
  NMRAnetBufferPools_100ms_TimeTick;
end;


procedure PrintDMABuffers;
var
  i: Integer;
begin
IntTohex(DMA0CON, s1);
  UART1_Write_Text('DMA0CON = '+s1+'  ');

  IntTohex(DMA0REQ, s1);
  UART1_Write_Text('DMA0REQ = '+s1+'  ');

  IntTohex(DMA0STAL, s1);
  UART1_Write_Text('DMA0STAL = '+s1+'  ');
  IntTohex(DMA0STAH, s1);
  UART1_Write_Text('DMA0STAH = '+s1+'  ');

  IntTohex(DMA0STBL, s1);
  UART1_Write_Text('DMA0STBL = '+s1+'  ');
  IntTohex(DMA0STBH, s1);
  UART1_Write_Text('DMA0STBH = '+s1+'  ');

  IntTohex(DMA0PAD, s1);
  UART1_Write_Text('DMA0PAD = '+s1+'  ');
  IntTohex(DMA0CNT, s1);
  UART1_Write_Text('DMA0CNT = '+s1+'  ');
  IntTohex(DMAPWC, s1);
  UART1_Write_Text('DMAPWC = '+s1+'  ');
  IntTohex(DMARQC, s1);
  UART1_Write_Text('DMARQC = '+s1+'  ');
  IntTohex(DMALCA, s1);
  UART1_Write_Text('DMALCA = '+s1+'  ');
  IntTohex(DMAPPS, s1);
  UART1_Write_Text('DMAPPS = '+s1+LF);



  IntTohex(DMA1CON, s1);
  UART1_Write_Text('DMA1CON = '+s1+'  ');

  IntTohex(DMA1REQ, s1);
  UART1_Write_Text('DMA1REQ = '+s1+'  ');

  IntTohex(DMA1STAL, s1);
  UART1_Write_Text('DMA1STAL = '+s1+'  ');
  IntTohex(DMA1STAH, s1);
  UART1_Write_Text('DMA1STAH = '+s1+'  ');

  IntTohex(DMA1STBL, s1);
  UART1_Write_Text('DMA1STBL = '+s1+'  ');
  IntTohex(DMA1STBH, s1);
  UART1_Write_Text('DMA1STBH = '+s1+'  ');

  IntTohex(DMA1PAD, s1);
  UART1_Write_Text('DMA1PAD = '+s1+'  ');
  IntTohex(DMA1CNT, s1);
  UART1_Write_Text('DMA1CNT = '+s1+'  ');
  IntTohex(DMAPWC, s1);
  UART1_Write_Text('DMAPWC = '+s1+'  ');
  IntTohex(DMARQC, s1);
  UART1_Write_Text('DMARQC = '+s1+'  ');
  IntTohex(DMALCA, s1);
  UART1_Write_Text('DMALCA = '+s1+'  ');
  IntTohex(DMAPPS, s1);
  UART1_Write_Text('DMAPPS = '+s1+LF);


  IntTohex(DMA2CON, s1);
  UART1_Write_Text('DMA2CON = '+s1+'  ');

  IntTohex(DMA2REQ, s1);
  UART1_Write_Text('DMA2REQ = '+s1+'  ');

  IntTohex(DMA2STAL, s1);
  UART1_Write_Text('DMA2STAL = '+s1+'  ');
  IntTohex(DMA2STAH, s1);
  UART1_Write_Text('DMA2STAH = '+s1+'  ');

  IntTohex(DMA2STBL, s1);
  UART1_Write_Text('DMA2STBL = '+s1+'  ');
  IntTohex(DMA2STBH, s1);
  UART1_Write_Text('DMA2STBH = '+s1+'  ');

  IntTohex(DMA2PAD, s1);
  UART1_Write_Text('DMA2PAD = '+s1+'  ');
  IntTohex(DMA2CNT, s1);
  UART1_Write_Text('DMA2CNT = '+s1+'  ');
  IntTohex(DMAPWC, s1);
  UART1_Write_Text('DMAPWC = '+s1+'  ');
  IntTohex(DMARQC, s1);
  UART1_Write_Text('DMARQC = '+s1+'  ');
  IntTohex(DMALCA, s1);
  UART1_Write_Text('DMALCA = '+s1+'  ');
  IntTohex(DMAPPS, s1);
  UART1_Write_Text('DMAPPS = '+s1+LF);


  IntTohex(DMA3CON, s1);
  UART1_Write_Text('DMA3CON = '+s1+'  ');

  IntTohex(DMA3REQ, s1);
  UART1_Write_Text('DMA3REQ = '+s1+'  ');

  IntTohex(DMA3STAL, s1);
  UART1_Write_Text('DMA3STAL = '+s1+'  ');
  IntTohex(DMA3STAH, s1);
  UART1_Write_Text('DMA3STAH = '+s1+'  ');

  IntTohex(DMA3STBL, s1);
  UART1_Write_Text('DMA3STBL = '+s1+'  ');
  IntTohex(DMA3STBH, s1);
  UART1_Write_Text('DMA3STBH = '+s1+'  ');

  IntTohex(DMA3PAD, s1);
  UART1_Write_Text('DMA3PAD = '+s1+'  ');
  IntTohex(DMA3CNT, s1);
  UART1_Write_Text('DMA3CNT = '+s1+'  ');
  IntTohex(DMAPWC, s1);
  UART1_Write_Text('DMAPWC = '+s1+'  ');
  IntTohex(DMARQC, s1);
  UART1_Write_Text('DMARQC = '+s1+'  ');
  IntTohex(DMALCA, s1);
  UART1_Write_Text('DMALCA = '+s1+'  ');
  IntTohex(DMAPPS, s1);
  UART1_Write_Text('DMAPPS = '+s1+LF);


  UART1_Write_Text('TX Buffer'+LF);

  for i := 0 to MAX_ECAN_TX_BUFFER - 1 do
  begin
    IntToHex(TX_Main_RawBufferArray[i].Word0, s1);
    UART1_Write_Text('Word0 = '+s1+'  ');
    IntToHex(TX_Main_RawBufferArray[i].Word1, s1);
    UART1_Write_Text('Word1 = '+s1+'  ');
    IntToHex(TX_Main_RawBufferArray[i].Word2, s1);
    UART1_Write_Text('Word2 = '+s1+'  ');
    IntToHex(TX_Main_RawBufferArray[i].Word3, s1);
    UART1_Write_Text('Word3 = '+s1+'  ');
    IntToHex(TX_Main_RawBufferArray[i].Word4, s1);
    UART1_Write_Text('Word4 = '+s1+'  ');
    IntToHex(TX_Main_RawBufferArray[i].Word5, s1);
    UART1_Write_Text('Word5 = '+s1+'  ');
    IntToHex(TX_Main_RawBufferArray[i].Word6, s1);
    UART1_Write_Text('Word6 = '+s1+'  ');
    IntToHex(TX_Main_RawBufferArray[i].Word7, s1);
    UART1_Write_Text('Word7 = '+s1+'  '+LF+LF);
  end;

  UART1_Write_Text('RX Buffer'+LF);

  for i := 0 to MAX_ECAN_RX_BUFFER - 1 do
  begin
    IntToHex(RX_Main_RawBufferArray[i].Word0, s1);
    UART1_Write_Text('Word0 = '+s1+'  ');
    IntToHex(RX_Main_RawBufferArray[i].Word1, s1);
    UART1_Write_Text('Word1 = '+s1+'  ');
    IntToHex(RX_Main_RawBufferArray[i].Word2, s1);
    UART1_Write_Text('Word2 = '+s1+'  ');
    IntToHex(RX_Main_RawBufferArray[i].Word3, s1);
    UART1_Write_Text('Word3 = '+s1+'  ');
    IntToHex(RX_Main_RawBufferArray[i].Word4, s1);
    UART1_Write_Text('Word4 = '+s1+'  ');
    IntToHex(RX_Main_RawBufferArray[i].Word5, s1);
    UART1_Write_Text('Word5 = '+s1+'  ');
    IntToHex(RX_Main_RawBufferArray[i].Word6, s1);
    UART1_Write_Text('Word6 = '+s1+'  ');
    IntToHex(RX_Main_RawBufferArray[i].Word7, s1);
    UART1_Write_Text('Word7 = '+s1+'  '+LF+LF);
  end;
end;


// *******************
// MAIN LOOP
// *******************
var
  ActiveNode: PNMRAnetNode;
  i, j: Integer;
  x, y: Word;
  


begin
  ANSELA := 0x0000;                                  // configure AN pins on Port A as digital I/O
  ANSELB := 0x0000;                                  // configure AN pins on Port B digital I/O

  TRISA4_bit := 0;
  LATA4_bit := 0;                                                   // Output

  _25AAxxxx_Initialize;
  NMRAnetStateMachine_Initialize(MUSTANGPEAK_ID_0_HI, MUSTANGPEAK_COMMANDSTATION_ID_0_LO);
  MCU_Setup_Initialize;                                                         // Start the timers and perpherials last
  NMRA_DCC_Initialize;

  H_Bridge_A_Lo := 0;                                                           // Bridge Off
  H_Bridge_A_Hi := 0;                                                           // Bridge Off
  H_Bridge_B_Lo := 0;                                                           // Bridge Off
  H_Bridge_B_Hi := 0;                                                           // Bridge Off
  H_Bridge_A_Lo_Direction := 0;                                                 // Output
  H_Bridge_A_Hi_Direction := 0;                                                 // Output
  H_Bridge_B_Lo_Direction := 0;                                                 // Output
  H_Bridge_B_Hi_Direction := 0;                                                 // Output


  TON_T1CON_bit := 1;                                                           // Start the DCC Timer
  NMRA_DCC_Packet_Init;                                                         // Send our 20 Idle Packets per the spec, note we are not on the OLCB bus yet so this will block until done.


  UART1_Write_Text('Starting'+LF);

  x := 0;
  y := 0;
  j := 0;
  i := 0;
  MaxTime_RX := 0;
  MaxTime_StateMachine := 0;



  j := 0;

  while (TRUE) do
  begin
 //   delay_ms(100);
 //   IntToStr(Track.TX_iStateMachine, s1);
  //  UART1_Write_Text(s1+LF+LF);
    ActiveNode := NMRAnetNode_NextNode;
    if ActiveNode <> PNMRAnetNode( nil) then
    begin
      NMRAnetStateMachine_Process(ActiveNode);

      if UART1_Data_Ready then
      begin
        case UART1_Read of
          'P' : begin
               PrintDMABuffers
             end;
          'X' : begin
                NMRAnetStateMachine_TrySendVerifyNodeID(ActiveNode, 0);
             end;
        end;
      end;


      if j = 10000 then
      begin
   //
        j := 0
      end;

      Inc(j);

    end;
  end;
end.