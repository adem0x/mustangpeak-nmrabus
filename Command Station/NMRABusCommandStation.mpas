program NMRABusCommandStation;

{*
 * Project name:
     NMRABusCommandStation
 * Copyright:
     (c) Mustangpeak Software 2012
 * Revision History:
     20120108:
       - initial release;
 * Description:

 * Test configuration:
     MCU:             dsPIC30F4013
                      http://ww1.microchip.com/downloads/en/DeviceDoc/70138F.pdf
     Dev.Board:       EasydsPIC6
                      http://www.mikroe.com/eng/products/view/434/easydspic6-development-system/
     Oscillator:      XT-PLL8, 10.000MHz
     ext. modules:    mikroe  module on portf
                      SmartADAPT Extra Development Board.
                      http://www.mikroe.com/eng/products/view/157/smartadapt/
     SW:              mikroPascal PRO for dsPIC30/33 and PIC24
                      http://www.mikroe.com/eng/products/view/230/mikropascal-pro-for-dspic30-33-and-pic24/
 * NOTES:
     - Consult the CAN standard about CAN bus termination resistance.
     - Turn on LEDs on PORTB.
 *}
 
uses
  NMRABus, MCP2515, CAN_Data, MCU_Setup;
  
{$I Options.inc}

const
  CAN_INTERRUPT_PIN = 4;


var
  CanSpi_CS_MCP2515                : sbit at LATF0_bit;
  CanSpi_CS_Direction_MCP2515      : sbit at TRISF0_bit;

// CANSPI module connections
var CanSpi_CS            : sbit at  LATF0_bit;
    CanSpi_CS_Direction  : sbit at TRISF0_bit;
    CanSpi_Rst           : sbit at LATF1_bit;
    CanSpi_Rst_Direction : sbit at TRISF1_bit;
// End CANSPI module connections

{$IFDEF UART_ENABLE}
procedure PrintMCP2515Registers(StartReg, Count: Byte);
var
  i: Integer;
  s_Temp2, s_Temp1: array[128] of char;
begin
  for i := 0 to Count -1 do
  begin
    s_Temp2 := 'Register $';
    ByteToHex(StartReg + i, s_Temp1);
    s_Temp2 := s_Temp2 + s_Temp1;
    s_Temp2 := s_Temp2 + ': $';
    ByteToHex(MCP2515_CANReadRegister(StartReg + i), s_Temp1);
    s_Temp2 := s_Temp2 + s_Temp1;
    s_Temp2 := s_Temp2 + char($0D);
    s_Temp2 := s_Temp2 + char($0A);
    UART1_Write_Text(s_Temp2);
  end;
end;
{$ENDIF}

procedure CheckForPendingCANLayerPacket;
var
  TxControl: Byte;
begin
  if CAN_Layer_Buffer.Transmitting then
  begin
    TXControl := MCP2515_CANReadRegister(TXB1CTRL_MCP2515);
    if TXControl.TXREQ_MCP2515 = 0 then
    begin
      MCP2515_CANWriteTXBuffer(CAN_TX_1, CAN_Layer_Buffer.Packet.ID, CAN_Layer_Buffer.Packet.Count, CAN_Layer_Buffer.Packet.Bytes, True, CAN_TX_PRIORITY_1);   // Yes, so move it into the CAN transmtter buffer
      MCP2515_CANModifyBit(CANINTE_MCP2515, TX1IF_MCP2515, False);              // Clear Transmitter Interrupt Flag, Buffer is no longer empty
      CAN_Layer_Buffer.Transmitting := False;                                   // Release the loop waiting for the transmission in NMRABus.mpas
      NMRABus.RIDTimeCounter := 0;                                              // Start timing out the spec time to wait to see if the Alais ID is a duplicate
    end
  end;
end;

procedure CheckForPendingMessageLayerPacket;
var
  TxControl: Byte;
  Packet: TCAN_Packet;
begin
  // This is the only place to tell when a message was actually put on the CANbus.  If the TX flag is set then the message was placed on the bus
  // and the TX buffer can be loaded with a new message

  // This assumes that the transmitter is not pending a transmission.  Due to the load Tx timer this needs to be carefully dealt with
  // The Tx timer currently will clear the TxF Flag so if the timer slips in "just before" this interrupt, that is signaling an empty transmitter,
  // the Tx timer will load the Tx buffer and clear the flag.  That means this will be called but the flag will be cleared and this branch will
  // not be called and we are safe from overwriting the Tx buffer in the MCP2515 with what was just loaded in the Tx Timer.
  if CAN_Data_NextPacketMessageLayer(@CAN_Tx_List, Packet) then                 // Is there a Message Level Packet in the list ready to be transmitted?
  begin
    TxControl := MCP2515_CANReadRegister(TXB0CTRL_MCP2515);
    if TxControl.TXREQ_MCP2515 = 0 then                                         // CAN Controller Buffer is not currently pending a transmission
    begin
      MCP2515_CANWriteTXBuffer(CAN_TX_0, Packet.ID, Packet.Count, Packet.Bytes, True, CAN_TX_PRIORITY_0);   // Yes, so move it into the CAN transmtter buffer, this also set the TXREQ flag to allow the transmission
      MCP2515_CANModifyBit(CANINTE_MCP2515, TX0IF_MCP2515, False)                                           // Clear Transmitter Interrupt Flag, Buffer is no longer empty
    end
  end;
end;

procedure PacketReceivedOnMessageLayer;
var
  Packet: TCAN_Packet;
begin
  MCP2515_CANReadRXBuffer(0, Packet.ID, Packet.Count, Packet.Bytes, Packet.ExtendedID);  // Flags AutoReset
  CAN_Data_ListAddMessageLayer(@CAN_Rx_List, @Packet);                                   // Queue the Packet into the circular recieve list
end;

procedure PacketReceivedOnCANLayer;
var
  Packet: TCAN_Packet;
  Decode: DWord;
begin
  MCP2515_CANReadRXBuffer(1, Packet.ID, Packet.Count, Packet.Bytes, Packet.ExtendedID);    // Flags AutoReset
  begin
    Decode := Packet.ID shr 12;                                                 // Strip off the lower 12 bits (Alias ID)
    if Decode and $7000 <> 0 then                                               // Is it a Check ID (CID) message?
    begin
      case Decode of
        $7000: begin         // Check ID (CID) Frame - “Most” Significant 12 Bits of 48 Bit Node ID
               end;
        $6000: begin         // Check ID (CID) Frame - 3rd 12 Bits of 48 Bit Node ID
               end;
        $5000: begin         // Check ID (CID) Frame - 2nd 12 Bits of 48 Bit Node ID
               end;
        $4000: begin         // Check ID (CID) Frame - “Least” Significant 12 Bits of 48 Bit Node ID
               end;
      end
    end else
    begin
      case Decode of
        $0700: begin          // Reserve ID Frame (RID)
                 // Someone is using the Alias ID we want to use
                 NMRABus.RIDTimeCounter := RID_TIME_COUNT_MAX;                             // Stop the clock waiting for the CAN Layer message response
                 CAN_Layer_Buffer.ReceivedRID := True;
               end;
        $0701: begin          // Alias Map Definition (AMD) Frame
               end;
        $0702: begin          // Alias Mapping Enquiry (AME) Frame
               end;
        $0703: begin          // Alias Map Reset (AMR) Frame
               end;
      end;
    end;
  end;
end;

procedure HandleMCP2515Error;
begin
  MCP2515_CANModifyBit(CANINTE_MCP2515, ERRIF_MCP2515, False);       // Clear Error Interrupt Flag
end;

procedure INTERRUPT_SPI_Transmitted(); iv IVT_ADDR_SPI1INTERRUPT;
begin
  SPI1IF_bit := 0;   // Clear the Flag
//  PORTD := not PORTD
end;

procedure INTERRUPT_DCC_Timer(); iv IVT_ADDR_T1INTERRUPT;
begin
  T1IF_bit := 0;  // Clear the Flag
  Delay_us(35);
//  PORTD := not PORTD
end;

procedure INTERRUPT_Global_Timer(); iv IVT_ADDR_T2INTERRUPT;
// Called once every 1m
begin
  T2IF_bit := 0;  // Clear the Flag
  NMRABus_GlobalTimer;
 // PORTD := not PORTD
end;

procedure INTERRUPT_CAN_TX_Timer(); iv IVT_ADDR_T3INTERRUPT;
begin
  T3IF_bit := 0;  // Clear the Flag
  
  LATD1_bit := 1;
  // We are safe in reading the CAN here as we have the same priority as the Pin Change. The CN not get interrupted in the middle of this routine so the SPI calls are safe.
  // It is possible that the Interrupt Flag is set and TxReq is low if this timer is called just before pin change notification interrupt is called.  If so it is
  // necessary to clear the interrupt flag since we have already handled loading the Tx register and the pin change notification interrupt does not check for TxReq to be
  // zero before loading the transmitter
  CheckForPendingCANLayerPacket;
  CheckForPendingMessageLayerPacket;
  
  LATD1_bit := 0
end;

procedure INTERRUPT_Pin_Change_Notification(); iv IVT_ADDR_CNINTERRUPT;
var
  Flags: Byte;
begin
  CNIF_bit := 0;     // Clear Flag
  
  LATD0_bit := 1;
  while (PORTF.CAN_INTERRUPT_PIN = 0) do                                        // ALWAYS check for the interrupt pin to be low as it won't go high until all are cleared
  begin
    Flags := MCP2515_CANReadRegister(CANINTF_MCP2515);
    
    if Flags.RX0IF_MCP2515 = 1 then                                           // Receiver 0 full
      PacketReceivedOnMessageLayer;
    if Flags.TX0IF_MCP2515 = 1 then                                           // Transmitter 0 empty, this means a Message Layer normal priority message was transmitted
      CheckForPendingMessageLayerPacket;                                      // If another Message Layer Packet is in the circular list load it into the CAN transmit buffer
      
    if Flags.RX1IF_MCP2515 = 1 then                                           // Receiver 1 full
      PacketReceivedOnCANLayer;
    if Flags.TX1IF_MCP2515 = 1 then                                           // Transmitter 1 empty, this is means CAN Layer high priority message was transmitted
      CheckForPendingCANLayerPacket;
    
    if Flags.ERRIF_MCP2515 = 1 then
      HandleMCP2515Error;
  end;
  PinChangeState := PORTF;
  LATD0_bit := 0;
end;

// *******************
// MAIN LOOP
// *******************

var
  Packet: TCAN_Packet;
  Tx_ID, Rx_ID : dword;                                   // can rx and tx ID
  i: Integer;
begin

  CAN_Data_Initialize;
  NMRABus_Initialize;
  MCP2515_Initialize;
  MCU_Setup_Initialize;
  
// Set initial data to be sent
  CAN_Data_LoadPacket(@Packet, ID_1st, 1, 0, 0, 0, 0, 0, 0, 0, 9, True);
  CAN_Data_ListAddMessageLayer(@CAN_Tx_List, @Packet);                          // send initial message
  
  NMRABus_Connect;
  while (TRUE) do
    begin
      if not NMRABus_Connected then
      begin
        RecreateAliasID;
        NMRABus_Connect;
      end;
      
      if NMRABus_Connected then
      begin
        if CAN_Data_NextPacketMessageLayer(@CAN_Rx_List, Packet) then
        begin
          if Packet.ID = ID_2nd then                                              // Message was received (interrupt) if it is ours then ...
          begin
            PORTB := Packet.Bytes[0];                                             // id correct, output data at PORTB
            Inc(Packet.Bytes[0]);
            CAN_Data_LoadPacket(@Packet, ID_1st, 1, 0, 0, 0, 0, 0, 0, 0, Packet.Bytes[0], True);    // increment received data
            Delay_ms(10);
            CAN_Data_ListAddMessageLayer(@CAN_Tx_List, @Packet);
          end
        end
      end
    end;
end.