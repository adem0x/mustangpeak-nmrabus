program NMRABusCommandStation;

{*
 * Project name:
     NMRABusCommandStation
 * Copyright:
     (c) Mustangpeak Software 2012
 * Revision History:
     20120108:
       - initial release;
 * Description:

 * Test configuration:
     MCU:             dsPIC30F4013
                      http://ww1.microchip.com/downloads/en/DeviceDoc/70138F.pdf
     Dev.Board:       EasydsPIC6
                      http://www.mikroe.com/eng/products/view/434/easydspic6-development-system/
     Oscillator:      XT-PLL8, 10.000MHz
     ext. modules:    mikroe  module on portf
                      SmartADAPT Extra Development Board.
                      http://www.mikroe.com/eng/products/view/157/smartadapt/
     SW:              mikroPascal PRO for dsPIC30/33 and PIC24
                      http://www.mikroe.com/eng/products/view/230/mikropascal-pro-for-dspic30-33-and-pic24/
 * NOTES:
     - Consult the CAN standard about CAN bus termination resistance.
     - Turn on LEDs on PORTB.
 *}
 
{$DEFINE DCCTIMER_DISABLE}
 
uses
  NMRABus, MCP2515, CAN_Data;
  
const ID_1st : longint = 12111;
const ID_2nd : longint = 3;

const
  CAN_INTERRUPT_PIN = 4;


const
  CAN_SWJ        = 1;             // Set up for 125Khz Baud Rate with a 16Mhz Crystal
  CAN_BRP        = 3+1;             // All in terms of number of Tq actual value in register will be BRP-1
  CAN_PROP_SEG   = 2+1;             // All in terms of number of Tq actual value in register will be CAN_PROP_SEG-1
  CAN_PHASESEG_1 = 5+1;             // All in terms of number of Tq actual value in register will be CAN_PHASESEG_1-1
  CAN_PHASESEG_2 = 5+1;             // All in terms of number of Tq actual value in register will be CAN_PHASESEG_2-1

var
  CanSpi_CS_MCP2515                : sbit at LATF0_bit;
  CanSpi_CS_Direction_MCP2515      : sbit at TRISF0_bit;

// CANSPI module connections
var CanSpi_CS            : sbit at  LATF0_bit;
    CanSpi_CS_Direction  : sbit at TRISF0_bit;
    CanSpi_Rst           : sbit at LATF1_bit;
    CanSpi_Rst_Direction : sbit at TRISF1_bit;
// End CANSPI module connections

var
  PinChangeState: Word;
  
procedure PrintMCP2515Registers(StartReg, Count: Byte);
var
  i: Integer;
  s_Temp2, s_Temp1: array[128] of char;
begin
  for i := 0 to Count -1 do
  begin
    s_Temp2 := 'Register $';
    ByteToHex(StartReg + i, s_Temp1);
    s_Temp2 := s_Temp2 + s_Temp1;
    s_Temp2 := s_Temp2 + ': $';
    ByteToHex(MCP2515_CANReadRegister(StartReg + i), s_Temp1);
    s_Temp2 := s_Temp2 + s_Temp1;
    s_Temp2 := s_Temp2 + char($0D);
    s_Temp2 := s_Temp2 + char($0A);
    UART1_Write_Text(s_Temp2);
  end;
end;

procedure LoadCAN_BufferFromList(ClearInterruptFlag: Boolean);
var
  Packet: TCAN_Packet;
//
//  This must only be called from the CAN interrupt (Pin Change) or the CAN Timer interrupt
//  so that the SPI does not have reentrant problems.
//
begin
  if CAN_Data_NextPacket(@CAN_Tx_List, Packet) then
    MCP2515_CANWriteTXBuffer(0, Packet.ID, Packet.Count, Packet.Bytes, True);
  if ClearInterruptFlag then
    MCP2515_CANModifyBit(CANINTE_MCP2515, TX0IF_MCP2515, False);    // Clear Transmitter Interrupt Flag, Buffer is no longer empty
end;

procedure INTERRUPT_SPI_Transmitted(); iv IVT_ADDR_SPI1INTERRUPT;
begin
  SPI1IF_bit := 0;   // Clear the Flag
//  PORTD := not PORTD
end;

procedure INTERRUPT_DCC_Timer(); iv IVT_ADDR_T1INTERRUPT;
begin
  T1IF_bit := 0;  // Clear the Flag
  Delay_us(35);
//  PORTD := not PORTD
end;

procedure INTERRUPT_Global_Timer(); iv IVT_ADDR_T2INTERRUPT;
// Called once every
begin
  T2IF_bit := 0;  // Clear the Flag
  NMRABus_GlobalTimer;
 // PORTD := not PORTD
end;

procedure INTERRUPT_CAN_Timer(); iv IVT_ADDR_T3INTERRUPT;
var
  TxControl: Byte;
begin
  T3IF_bit := 0;  // Clear the Flag
  
  LATD1_bit := 1;
  // We are safe in reading the CAN here as we have the same priority as the Pin Change.
  // The other will not get interrupted in the middle of the routine so the SPI calls
  // are safe.
  TxControl := MCP2515_CANReadRegister(TXB0CTRL_MCP2515);
  if TxControl.TXREQ_MCP2515 = 0 then                      // CAN Controller Buffer is not currently pending a transmission
    LoadCAN_BufferFromList(False);
  LATD1_bit := 0
end;

procedure INTERRUPT_Pin_Change_Notification(); iv IVT_ADDR_CNINTERRUPT;
var
  Packet: TCAN_Packet;
  Flags: Byte;
begin
  CNIF_bit := 0;     // Clear Flag
  
  LATD0_bit := 1;
  while (PORTF.CAN_INTERRUPT_PIN = 0) do                                        // ALWAYS check for the interrupt pin to be low as it won't go high until all are cleared
  begin
    Flags := MCP2515_CANReadRegister(CANINTF_MCP2515);
    if (Flags and CANINTF_RX_FLAGS_MASK) <> 0 then
    begin
      if Flags.RX0IF_MCP2515 = 1 then                                                         // Receiver 0 full
      begin
        MCP2515_CANReadRXBuffer(0, Packet.ID, Packet.Count, Packet.Bytes, Packet.ExtendedID)  // Flags AutoReset
      end else                                                                                // Receiver 1 full
      begin
        MCP2515_CANReadRXBuffer(1, Packet.ID, Packet.Count, Packet.Bytes, Packet.ExtendedID); // Flags AutoReset
      end;
      CAN_Data_List(@CAN_Rx_List, @Packet);                                                 // Queue the Packet into the circular recieve list
    end else
    if (Flags and CANINTF_TX_FLAGS_MASK) <> 0 then                              // See if any of the Transimitter Interrupt Flags are set
    begin
      if Flags.TX0IF_MCP2515 = 1 then                                           // Transmitter 0 empty, only using buffer 0
        LoadCAN_BufferFromList(True);
    end else
    if (Flags and CANINTF_ERROR_FLAG_MASK) <> 0 then
      MCP2515_CANModifyBit(CANINTE_MCP2515, ERRIF_MCP2515, False);       // Clear Error Interrupt Flag
  end;
  PinChangeState := PORTF;
  LATD0_bit := 0;
end;




// *******************
// MAIN LOOP
// *******************

var
  Packet: TCAN_Packet;
  Tx_ID, Rx_ID : dword;                                   // can rx and tx ID
  i: Integer;
begin
  ADPCFG := 0xFFFF;                                     // configure AN pins as digital I/O

  PORTB := 0;                                           // clear PORTB
  TRISB := 0;                                           // set PORTB as output
  PORTD := 0;                                           // set PORTD as output
  TRISD := 0;

  PinChangeState := 0;

  CAN_Data_Initialize;
  NMRABus_Initialize;
  MCP2515_Initialize;
                    
// Initialize UART
  UART1_Init(115200);                       // Initialize UART module a
  Delay_ms(100);                            // Wait for UART module to stabilize

  U1MODE.ALTIO := 1;     // Un-comment this line to have Rx and Tx pins on their alternate
                          // locations. This is used to free the pins for other module, namely the SPI.

  // Make sure on startup of the SPI I don't get into reentrant problems with the interrupts
  // i.e. enabling the interrupts before we are done calling initilization SPI commands for the
  // slaves.
  SPI1_Init();   // Initialize SPI1 module
  CANSPIInitialize(CAN_SWJ, CAN_BRP, CAN_PHASESEG_1, CAN_PHASESEG_2, CAN_PROP_SEG, _CANSPI_CONFIG_SAMPLE_THRICE and _CANSPI_CONFIG_PHSEG2_PRG_ON and _CANSPI_CONFIG_XTD_MSG and _CANSPI_CONFIG_VALID_XTD_MSG);   // Initialize external CANSPI module

  CANSPISetOperationMode(_CANSPI_MODE_CONFIG, 0xFF);                            // set CONFIGURATION mode
  CANSPISetMask(_CANSPI_MASK_B1, LongInt($FFFFFFFF), _CANSPI_CONFIG_XTD_MSG);   // set all mask1 bits to ones
  CANSPISetMask(_CANSPI_MASK_B2, LongInt($FFFFFFFF), _CANSPI_CONFIG_XTD_MSG);   // set all mask2 bits to ones
  CANSPISetFilter(_CANSPI_FILTER_B2_F4, ID_2nd, _CANSPI_CONFIG_XTD_MSG);        // set id of filter B2_F4 to 2nd node ID
  CANSPISetOperationMode(_CANSPI_MODE_NORMAL,0xFF);                             // set NORMAL mode
  MCP2515_CANModifyBit(CANINTE_MCP2515, RX0IE_MCP2515, True);
  MCP2515_CANModifyBit(CANINTE_MCP2515, RX1IE_MCP2515, True);           // Receive RX is Full Interrupts
  MCP2515_CANModifyBit(CANINTE_MCP2515, TX0IE_MCP2515, True);           // Transmit Buffer Empty Interrupt, only using Buffer 0

  SPIEN_bit := 0;    // Disable SPI
  SPI1CON := SPI1CON and $FFE0;  // Clear the prescaler bits
  SPI1CON := SPI1CON or $0003 or $0010;  // Setup for 5 Mhz (with the CAN plug in boards)     $10=5Mhz, $14=6.67Mhz, $18 = 10Mhz
  SPI1IF_bit := 0;   // Clear the Flag
  SPI1IE_bit := 1;   // Enable SPI 1 Interrupts
  SPI1IP_0_bit := 1; // Interrupt Priority of the SPI is 1 (001)
  SPI1IP_1_bit := 0;
  SPI1IP_2_bit := 0;
  SPIEN_bit := 1;    // Enable the SPI

  T1IP_0_bit := 1;   // Timer 1 Interrupt Priority = 7
  T1IP_1_bit := 1;
  T1IP_2_bit := 1;
  T1IF_bit := 0;             // Clear T1IF
  T1IE_bit := 1;             // Enable Timer1 interrupts
  PR1 := 1120;               // 56us timer with a 80Mhz clock
  {$IFNDEF DCCTIMER_DISABLE}TON_T1CON_bit := 1;{$ENDIF} // Turn on

  T2IF_bit := 0;     // Clear the Interrupt flag
  T2IP_0_bit := 1;   // Timer 2 Interrupt Priority = 1
  T2IP_1_bit := 0;
  T2IP_2_bit := 0;
  T2IE_bit := 1;     // Enable the Interrupt
  TON_T2CON_bit := 1; // Turn on
  
  T3IF_bit := 0;     // Clear the Interrupt flag
  T3IP_0_bit := 0;   // Timer 2 Interrupt Priority = 6 must be EQUAL to the Pin Change Notifier (SPI CAN)
  T3IP_1_bit := 1;
  T3IP_2_bit := 1;
  T3IE_bit := 1;     // Enable the Interrupt
  PR3 := 5000;       // Every 150us try to load a CAN message
  TON_T3CON_bit := 1; // Turn on
  
  CNIF_bit := 0;     // Clear Flag
  CNIP_0_bit := 0;   // Interrupt Priority = 6 (next below DCC)
  CNIP_1_bit := 1;
  CNIP_2_bit := 1;
  CN17IE_bit := 1;   // RF4 (CN17) set for interrupt
  CNIE_bit := 1;     // Enable the Interrupt for Pin Change
  
  // DO I NEED TO CLEAR ERROR FLAG, ETC IN SPI DEVICES BEFORE STARTING THE TIMERS/PIN CHANGE NOTFIERS
  // AS WE MAY HAVE BUFFER OVERFLOW ISSUES BETWEEN THE TIME WE INITIALIZED THE SPI DEVICES AND WE
  // START TO SERVICE THEM WITH THE INTERRUPTS..........
  
  PinChangeState := PORTF;
  
// Set initial data to be sent
  CAN_Data_LoadPacket(@Packet, ID_1st, 1, 0, 0, 0, 0, 0, 0, 0, 9, True);
  CAN_Data_List(@CAN_Tx_List, @Packet);                                       // send initial message
  
//  NMRABus_Connect;
  while (TRUE) do
    begin
//      if not NMRABus_Connected then
      begin
  //      RecreateAliasID;
  //      NMRABus_Connect;
      end;
      
   //   if NMRABus_Connected then
      begin
        if CAN_Data_NextPacket(@CAN_Rx_List, Packet) then
        begin
          if Packet.ID = ID_2nd then                                              // Message was received (interrupt) if it is ours then ...
          begin
            PORTB := Packet.Bytes[0];                                             // id correct, output data at PORTB
            Inc(Packet.Bytes[0]);
            CAN_Data_LoadPacket(@Packet, ID_1st, 1, 0, 0, 0, 0, 0, 0, 0, Packet.Bytes[0], True);    // increment received data
            Delay_ms(10);
            CAN_Data_List(@CAN_Tx_List, @Packet);
          end
        end
      end
    end;
end.