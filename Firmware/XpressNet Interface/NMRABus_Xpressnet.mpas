program NMRABus_Xpressnet;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:

//
// *****************************************************************************

uses
  NMRAnetEventDefines,
  NMRAnetStateMachine,
  MCU_Setup_dsPIC4013,
  CANDefines,
  CANStorage,
  dsPIC30_CAN,
  dsPIC30_Traps,
  XpressnetDefines,
  XpressnetStateMachine,
  NodeIDs;

{$I Options.inc}

var
  MainLoopState: Byte;

// ****************************************************************************
// procedure GetUniqueIDFunc
//
//  Description:   Callback from NMRABus to load the 48 Bit Unique ID
//
// ****************************************************************************
procedure GetUniqueIDFunc(var HiID, LoID: DWord);
begin
  LoID := MUSTANGPEAK_XPRESSNET_ID_0_LO;
  HiID := MUSTANGPEAK_ID_0_HI;
end;


// *****************************************************************************
//  INTERRUPTS
// *****************************************************************************

procedure INTERRUPT_Timer_840ms(); iv IVT_ADDR_T3INTERRUPT;
begin 
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  T3IF_bit := 0;
  
  XpressnetStateMachine_840ms_TimeTick;
end;

procedure INTERRUPT_Timer_1ms(); iv IVT_ADDR_T2INTERRUPT;
// Called once every 1m
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  T2IF_bit := 0;                                                                // Clear the Flag
  NMRAnetStateMachine_1ms_Timer;
end;

{$IFDEF XPRESSNET_UART_ENABLE}
procedure INTERRUPT_XPRESSNET_UART_RX(); iv IVT_ADDR_U2RXINTERRUPT;
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  U2RXIF_Bit := 0;              // Clear the interrupt flag to receive the next byte

  while (URXDA_U2STA_bit = 1) and (XpressnetStateMachineInfo.RS485.XPressNetData.StateMachineIndex < STATE_RS485_FULL)  do
  begin
    XpressnetStateMachine_UART_RX_StateMachine(@XpressnetStateMachineInfo, U2RXREG);
  end
end;
{$ENDIF}

{$IFDEF PINCHANGE_INTERRUPT_ENABLE}
procedure INTERRUPT_Pin_Change_Notification(); iv IVT_ADDR_CNINTERRUPT;         // 93us when a TransmitCompleteOnCANLayerPacket called with new Tx Packet waiting
var
  Flags: Byte;
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  CNIF_bit := 0;     // Clear Flag
  PinChangeState := PORTF;
end;
{$ENDIF}

procedure ComplexResponseCallback(Response: PQueuedResponse);
var
 ResponseNodeID: TNodeID;
begin
  case Response^.nCode of
    CRC_PRODUCER_IDENTIFIED :
      begin
        if NMRAnetUtilities_EqualEventID(@Response^.DataBytes, @EVENT_LC_DISTRICT_NODE) then
          XpressnetStateMachineInfo.CommandStationAlias := Response^.Alias
        else
        if NMRAnetUtilities_EqualEventID(@Response^.DataBytes, @EVENT_LC_PROGRAMMING_NODE) then
          XpressnetStateMachineInfo.ProgrammerAlias := Response^.Alias
      end;
    CRC_AMR :
      begin
        NMRAnetUtilities_PacketBytesToNodeID(@Response^.DataBytes, ResponseNodeID, 0);
        
      {  if NMRAnetUtilities_CompareAliasIDs(Response^.Alias, XpressnetStateMachineInfo.CommandStationAlias) or
           NMRAnetUtilities_CompareNodeIDs(ResponseNodeID, XpressnetStateMachineInfo.CommandStationNodeID) then
        begin
          XpressnetStateMachineInfo.CommandStationAlias := 0;
          MainLoopState := 0;
        end;
        if NMRAnetUtilities_CompareAliasIDs(Response^.Alias, XpressnetStateMachineInfo.ProgrammerAlias) or
           NMRAnetUtilities_CompareNodeIDs(ResponseNodeID, XpressnetStateMachineInfo.ProgrammerNodeID) then
        begin
          XpressnetStateMachineInfo.ProgrammerAlias := 0;
          MainLoopState := 0;
        end       }
      end;
    CRC_AMD :
      begin
         // Check Node ID here and update Alias if necessary
      end;
  end;
end;

procedure SimpleResponseCallback(Response: Word);
begin

end;


// *******************
// MAIN LOOP
// *******************
var
  Buffer: TCANBuffer;
begin
  CANStorage_Initialize;
  MCU_Setup_Initialize;
  NMRAnetStateMachine_Initialize;
  XpressnetStateMachine_Initialize;
  
  NMRAnetStateMachine_SetComplexCallbackFunc(@ComplexResponseCallback);
  NMRAnetStateMachine_SetSimpleCallbackFunc(@SimpleResponseCallback);
  
  MainLoopState := 0;

  while (TRUE) do
    begin
    
      NMRAnetStateMachine_Process;
      
      if NMRAnetCANReceive_Permited then
      begin
        case MainLoopState of
          0: begin
               // Gather Command Stations Nodes
               if NMRAnetStateMachine_TrySendIdentifyProducer(@Buffer, NMRABus.Node.AliasID, @EVENT_LC_DISTRICT_NODE) then
                 MainLoopState := 1;
             end;
          1: begin
               if XpressnetStateMachineInfo.CommandStationAlias <> 0 then
                 if NMRAnetStateMachine_TrySendVerifyNodeID(@Buffer, XpressnetStateMachineInfo.CommandStationAlias, NMRABus.Node.AliasID) then
                   MainLoopState := 2;     // Need to send AMD to get the Node ID for the CS
             end;
          2: begin
               // Gather Programming Stations Nodes
               if NMRAnetStateMachine_TrySendIdentifyProducer(@Buffer, NMRABus.Node.AliasID, @EVENT_LC_PROGRAMMING_NODE) then
                 MainLoopState := 3;
             end;
          3: begin
               if XpressnetStateMachineInfo.ProgrammerAlias <> 0 then
                 if NMRAnetStateMachine_TrySendVerifyNodeID(@Buffer, XpressnetStateMachineInfo.ProgrammerAlias, NMRABus.Node.AliasID) then
                   MainLoopState := 4;   // Need to send AMD to get the Node ID for the Programmer
             end;
          4: begin
               XpressnetStateMachine_Process;                                            // May want this outside of Permited block, look at the statemachine
             end;
        end;
      end
    end;
end.