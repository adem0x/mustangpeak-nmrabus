unit NMRAnetAppDefines;

uses
  CANDefines,
  NMRAnetEventDefines,
  NMRAnetDefines;
  
{$I Options.inc}

const
  MAX_NODE_COUNT = 1;        // The number of Physical and vNodes this physical node support.  Note that these nodes are defined as the Node ID defined + 1 up to VIRTUAL_NODE_COUNT past that
                              // If the lower bits of this node are $0300 then the first Virtual Node is $0301 and the last is $0309 if the VIRTUAL_NODE_COUNT = 9
                              // It also MUST fall within the lower 3 byte boundry (this is due to the way I have defined HI/LO as 3 byte) so the max virtual nodes is 4095 with a base
                              // physical node starting at $0000;

const
  MAX_BASE_BUFFER_POOL             = MAX_NODE_COUNT + 4;                        // Number of Base Buffers to allocate for Messages , JMRI Interleaves all the nodes so we need a Buffer for every Node <;^(
  MAX_DATA_BUFFER_POOL             = 4;                                         // Number of CAN DataByte Buffers to allocate for Messages
  MAX_DATAGRAM_BUFFER_POOL         = 2;                                         // Number of Datagram Buffers to allocate for Messages

const
  MAX_ACDI_ARRAY = 78;
  TACDI_NODE_STRINGS: array[0..MAX_ACDI_ARRAY - 1] of byte = (
      $31,  // Version = 1
      $4D,$75,$73,$74,$61,$6E,$67,$70,$65,$61,$6B,$00,  // Mustangpeak
      $58,$47,$31,$30,$30,$00,  // XG100
      $31,$2E,$30,$2E,$30,$00,  // 1.0.0
      $30,$2E,$30,$2E,$31,$00,  // 0.0.1
      $31,  // Version = 1
      $58,$70,$72,$65,$73,$73,$6E,$65,$74,$20,$47,$61,$74,$65,$77,$61,$79,$00,  // Xpressnet Gateway
      $58,$70,$72,$65,$73,$73,$6E,$65,$74,$20,$47,$61,$74,$65,$77,$61,$79,$20,$50,$72,$6F,$74,$6F,$74,$79,$70,$65,$00  // Xpressnet Gateway Prototype
    );
  
const
  MAX_VNODE_ACDI_ARRAY = 8;
  TACDI_VNODE_STRINGS: array[0..MAX_VNODE_ACDI_ARRAY - 1] of byte = (
      $31,  // Version = 1
      $00,  //
      $00,  //
      $00,  //
      $00,  //
      $31,  // Version = 1
      $00,  //
      $00  //
    );
  
const
  PIV_SUPPORTED_PROTOCOL_COUNT = 4;    // UPDATED THIS IF ADDING OR SUBTRACTING SUPPORTED PROTOCOLS
  PIV_SUPPORTED_PROTOCOLS: array[0..PIV_SUPPORTED_PROTOCOL_COUNT-1] of TPIVProtocolValueArray = (
    ($80, $00, $00, $00, $00, $00),                                             // PIV_PROTOCOL_ID_PROTOCOL
    ($40, $00, $00, $00, $00, $00),                                             // PIV_PROTOCOL_ID_DATAGRAM
    ($04, $00, $00, $00, $00, $00),                                             //PIV_PROTOCOL_ID_PRODUCER_CONSUMER
    ($00, $40, $00, $00, $00, $00)                                              // PIV_PROTOCOL_ID_CDI
    );
    
  // DEFINED IN OPTIONS.INC
  // Set the number of Events that are Consumed and Produced by this Node
  {$IFDEF SUPPORT_AT_LEAST_ONE_CONSUMED_EVENT} MAX_SUPPORTED_EVENTS_CONSUMED = 1; {$ELSE} MAX_SUPPORTED_EVENTS_CONSUMED = 0; {$ENDIF}
  {$IFDEF SUPPORT_AT_LEAST_ONE_PRODUCED_EVENT} MAX_SUPPORTED_EVENTS_PRODUCED = 2; {$ELSE} MAX_SUPPORTED_EVENTS_PRODUCED = 0; {$ENDIF}
  
  MAX_SUPPORTED_EVENTS = MAX_SUPPORTED_EVENTS_PRODUCED + MAX_SUPPORTED_EVENTS_CONSUMED;
  
  {$IFDEF SUPPORT_AT_LEAST_ONE_CONSUMED_EVENT}
  // Defined the Values of the Events that are Consumed and Produced by this Node
  SUPPORTED_EVENTS_CONSUMED: array[0..MAX_SUPPORTED_EVENTS_CONSUMED-1] of TEventID = (
    ($05, $01, $01, $01, $07, $05, $FF, $FF)
  );
  {$ENDIF}
  {$IFDEF SUPPORT_AT_LEAST_ONE_PRODUCED_EVENT}
  SUPPORTED_EVENTS_PRODUCED: array[0..MAX_SUPPORTED_EVENTS_PRODUCED-1] of TEventID = (
    ($01, $10, $00, $00, $00, $00, $01, $04),                                    // This node is a EVENT_LC_CONTROLLER_NODE
    ($01, $10, $00, $00, $00, $00, $FF, $FF)                                    // This node is a EVENT_EMGERGENCY_STOP
  );
  {$ENDIF}
  
  // Set the number of Events that are Consumed and Produced by this Node
  {$IFDEF SUPPORT_AT_LEAST_ONE_VNODE_CONSUMED_EVENT} MAX_VNODE_SUPPORTED_EVENTS_CONSUMED = 1; {$ELSE} MAX_VNODE_SUPPORTED_EVENTS_CONSUMED = 0; {$ENDIF}
  {$IFDEF SUPPORT_AT_LEAST_ONE_VNODE_PRODUCED_EVENT} MAX_VNODE_SUPPORTED_EVENTS_PRODUCED = 2; {$ELSE} MAX_VNODE_SUPPORTED_EVENTS_PRODUCED = 0; {$ENDIF}

   MAX_VNODE_SUPPORTED_EVENTS = MAX_VNODE_SUPPORTED_EVENTS_PRODUCED + MAX_VNODE_SUPPORTED_EVENTS_CONSUMED;

  // Defined the Values of the Events that are Consumed and Produced by this Node
  {$IFDEF SUPPORT_AT_LEAST_ONE_VNODE_CONSUMED_EVENT}
  SUPPORTED_VNODE_EVENTS_CONSUMED: array[0..MAX_VNODE_SUPPORTED_EVENTS_CONSUMED-1] of TEventID = (

  );
  {$ENDIF}
  {$IFDEF SUPPORT_AT_LEAST_ONE_VNODE_PRODUCED_EVENT}
  SUPPORTED_VNODE_EVENTS_PRODUCED: array[0..MAX_VNODE_SUPPORTED_EVENTS_PRODUCED-1] of TEventID = (

  );
  {$ENDIF}
  
implementation

end.