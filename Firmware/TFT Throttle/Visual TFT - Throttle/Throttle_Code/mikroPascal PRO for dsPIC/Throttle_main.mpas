{*
 * Project name:
     Throttle.vtft
 * Generated by:
     Visual TFT
 * Date of creation
     3/24/2012
 * Time of creation
     12:48:16 PM
 * Test configuration:
     MCU:             P33FJ256GP710A
     Dev.Board:       MikroMMB_for_dsPIC33_hw_rev_1.10
                      http://www.mikroe.com/eng/products/view/586/mikrommb-for-dspic33-board/
     Oscillator:      64000000 Hz
     SW:              mikroPascal PRO for dsPIC
                      http://www.mikroe.com/eng/products/view/230/mikropascal-pro-for-dspic30-33-and-pic24/
 *}

program Throttle_main;

uses
  Throttle_events_code,
  CANStorage,
  dsPIC33_CAN,
  dsPIC33_DMA;
  
var
  s1: array[0..64] of Char;
  
  TX_CANLayer_RawBufferArray: TCANRawBufferArray; absolute $7800;         // There are 10 - 8 Word Buffer in this Array = 160 Bytes
  TX_CANLayer_List: TCANRawBufferList;
  
procedure LoadBuffer(List: PCANRawBufferList; ID: DWORD; ByteCount, Byte0, Byte1, Byte2, Byte3, Byte4, Byte5, Byte6, Byte7: Byte; IsExtended: Boolean);
var
  Buffer: TCANBuffer;
begin
  Buffer.ID := ID;
  Buffer.DataCount := ByteCount;
  Buffer.DataBytes[0] := Byte0;
  Buffer.DataBytes[1] := Byte1;
  Buffer.DataBytes[2] := Byte2;
  Buffer.DataBytes[3] := Byte3;
  Buffer.DataBytes[4] := Byte4;
  Buffer.DataBytes[5] := Byte5;
  Buffer.DataBytes[6] := Byte6;
  Buffer.DataBytes[7] := Byte7;
  Buffer.IsExtended := IsExtended;
  CANStorage_WriteToList(List, Buffer)
end;


procedure WriteTXBuffer;
begin
  WordToHex(TX_CANLayer_List.Buffers^[0].Word0, s1);
  s1 := 'Word0: ' + s1 ;
  strcpy(ButtonRoundF18.Caption, s1);
  DrawRoundButton(@ButtonRoundF18);

  WordToHex(TX_CANLayer_List.Buffers^[0].Word1, s1);
  s1 := 'Word1: ' + s1 ;
  strcpy(ButtonRoundF19.Caption, s1);
  DrawRoundButton(@ButtonRoundF19);

  WordToHex(TX_CANLayer_List.Buffers^[0].Word2, s1);
   s1 := 'Word2: ' + s1 ;
  strcpy(ButtonRoundF20.Caption, s1);
  DrawRoundButton(@ButtonRoundF20);

  WordToHex(TX_CANLayer_List.Buffers^[0].Word3, s1);
  s1 := 'Word3: ' + s1 ;
  strcpy(ButtonRoundF21.Caption, s1);
  DrawRoundButton(@ButtonRoundF21);

  WordToHex(TX_CANLayer_List.Buffers^[0].Word4, s1);
  s1 := 'Word4: ' + s1 ;
  strcpy(ButtonRoundF22.Caption, s1);
  DrawRoundButton(@ButtonRoundF22);

  WordToHex(TX_CANLayer_List.Buffers^[0].Word5, s1);
  s1 := 'Word5: ' + s1 ;
  strcpy(ButtonRoundF23.Caption, s1);
  DrawRoundButton(@ButtonRoundF23);

  WordToHex(TX_CANLayer_List.Buffers^[0].Word6, s1);
  s1 := 'Word6: ' + s1 ;
  strcpy(ButtonRoundF24.Caption, s1);
  DrawRoundButton(@ButtonRoundF24);
end;

procedure WriteDMAInfo;
begin
  WordToHex(DMA0CON, s1); 
  s1 := 'DMA0CON: ' + s1 ;
  strcpy(ButtonRoundF18.Caption, s1);
  DrawRoundButton(@ButtonRoundF18);

  WordToHex(DMA0REQ, s1);   
  s1 := 'DMA0REQ: ' + s1 ;
  strcpy(ButtonRoundF19.Caption, s1);
  DrawRoundButton(@ButtonRoundF19);

  WordToHex(DMA0STA, s1); 
  s1 := 'DMA0STA: ' + s1 ;
  strcpy(ButtonRoundF20.Caption, s1);
  DrawRoundButton(@ButtonRoundF20);

  WordToHex(DMA0STB, s1); 
  s1 := 'DMA0STB: ' + s1 ;
  strcpy(ButtonRoundF21.Caption, s1);
  DrawRoundButton(@ButtonRoundF21);

  WordToHex(DMA0PAD, s1); 
  s1 := 'DMA0PAD: ' + s1 ;
  strcpy(ButtonRoundF22.Caption, s1);
  DrawRoundButton(@ButtonRoundF22);

  WordToHex(DMA0CNT, s1); 
  s1 := 'DMA0CNT: ' + s1 ;
  strcpy(ButtonRoundF23.Caption, s1);
  DrawRoundButton(@ButtonRoundF23);

  WordToHex(DSADR, s1);
  s1 := 'DSADR: ' + s1 ;
  strcpy(ButtonRoundF24.Caption, s1);
  DrawRoundButton(@ButtonRoundF24);
  
  WordToHex(DMACS0, s1);
  s1 := 'DMACS0: ' + s1 ;
  strcpy(ButtonRoundF25.Caption, s1);
  DrawRoundButton(@ButtonRoundF25);
  
  WordToHex(DMACS1, s1);
  s1 := 'DMACS1: ' + s1;
  strcpy(ButtonRoundF26.Caption, s1);
  DrawRoundButton(@ButtonRoundF26);
end;

procedure WriteCANInfo;
begin
  WordToHex(C1CFG1, s1);
  s1 := 'C1CFG1: ' + s1 ;
  strcpy(ButtonRoundF18.Caption, s1);
  DrawRoundButton(@ButtonRoundF18);

  WordToHex(C1CFG2, s1);
  s1 := 'C1CFG2: ' + s1 ;
  strcpy(ButtonRoundF19.Caption, s1);
  DrawRoundButton(@ButtonRoundF19);

  WordToHex(C1FEN1, s1);
  s1 := 'C1FEN1: ' + s1 ;
  strcpy(ButtonRoundF20.Caption, s1);
  DrawRoundButton(@ButtonRoundF20);

  WordToHex(C1FMSKSEL1, s1);
  s1 := 'C1FMSKSEL1: ' + s1 ;
  strcpy(ButtonRoundF21.Caption, s1);
  DrawRoundButton(@ButtonRoundF21);

  WordToHex(C1FMSKSEL2, s1);
  s1 := 'C1FMSKSEL2: ' + s1 ;
  strcpy(ButtonRoundF22.Caption, s1);
  DrawRoundButton(@ButtonRoundF22);

  WIN_Bit := 0;
  WordToHex(C1FCTRL, s1);
  s1 := 'C1FCTRL: ' + s1 ;
  strcpy(ButtonRoundF23.Caption, s1);
  DrawRoundButton(@ButtonRoundF23);

  WIN_Bit := 0;
  WordToHex(C1FIFO, s1);
  s1 := 'C1FIFO: ' + s1 ;
  strcpy(ButtonRoundF24.Caption, s1);
  DrawRoundButton(@ButtonRoundF24);

  WordToHex(C1CTRL1, s1);
  s1 := 'C1CTRL1: ' + s1 ;
  strcpy(ButtonRoundF25.Caption, s1);
  DrawRoundButton(@ButtonRoundF25);

  WordToHex(C1CTRL2, s1);
  s1 := 'C1CTRL2: ' + s1;
  strcpy(ButtonRoundF26.Caption, s1);
  DrawRoundButton(@ButtonRoundF26);
end;

procedure WriteCAN_TX_Info;
begin
  WordToHex(C1TR01CON, s1);
  s1 := 'C1TR01CON: ' + s1 ;
  strcpy(ButtonRoundF18.Caption, s1);
  DrawRoundButton(@ButtonRoundF18);

  WordToHex(C1TR23CON, s1);
  s1 := 'C1TR23CON: ' + s1 ;
  strcpy(ButtonRoundF19.Caption, s1);
  DrawRoundButton(@ButtonRoundF19);

  WordToHex(C1TR45CON, s1);
  s1 := 'C1TR45CON: ' + s1 ;
  strcpy(ButtonRoundF20.Caption, s1);
  DrawRoundButton(@ButtonRoundF20);

  WordToHex(C1TR67CON, s1);
  s1 := 'C1TR671CON: ' + s1 ;
  strcpy(ButtonRoundF21.Caption, s1);
  DrawRoundButton(@ButtonRoundF21);

  WordToHex(C1EC, s1);
  s1 := 'C1EC: ' + s1 ;
  strcpy(ButtonRoundF22.Caption, s1);
  DrawRoundButton(@ButtonRoundF22);

  WordToHex(C1RXD, s1);
  s1 := 'C1RXD: ' + s1 ;
  strcpy(ButtonRoundF23.Caption, s1);
  DrawRoundButton(@ButtonRoundF23);

  WIN_Bit := 0;
  WordToHex(C1TXD, s1);
  s1 := 'C1TXD: ' + s1 ;
  strcpy(ButtonRoundF24.Caption, s1);
  DrawRoundButton(@ButtonRoundF24);
end;

procedure Interrupt_CAN_Event(); iv IVT_ADDR_C1INTERRUPT; ics ICS_AUTO;
var
  Next: PCANRawBuffer;
begin
  dsPIC33_CAN_GlobalInterruptFlagCAN_Event(True);
  // WIN_bit := 0;                                                              // If not using the dsPIC33_CAN_xxx functions don't forget to set the correct bank to access C1VEC
  while dsPIC33_CAN_InterruptCode <> ICODE_NO_INTERRUPT do
  begin
    case dsPIC33_CAN_InterruptCode of
      ICODE_TRB0: begin
           // Setup as a TX Buffer so should have reset the Transmit Buffer Interrupt Flag (TBIF)
           dsPIC33_CAN_InterruptFlagTXBuffer(True);                              // TX Interrupt Flag Reset
           
           CANStorage_ReleaseFirstFullBuffer(@TX_CANLayer_List);                          // Release the Buffer that was just sent
           Next := CANStorage_FirstFullBuffer(@TX_CANLayer_List);                         // Grab the Next in the List to send
           if Next <> nil then
           begin
             dsPIC33_DMA_AddressOffsetA(0, Next);                               // Address Offset from the DAM RAM Start Address is 0
             dsPIC33_DMA_TransferCount(0, dsPIC33_CAN_CalculateBufferSizeForRegAddressWithAutoIncrement(Next)); // Calculate the number of Words that Transmitter needs to send in Register Mode with Auto Increment
             dsPIC33_CAN_RequestTransmit(0);
           end
         end;
    end
  end;
end;

begin
  MCU_Setup_Initialize;
  CANStorage_InitializeList(@TX_CANLayer_List, @TX_CANLayer_RawBufferArray, 10);            // Overlays DMA RAM and is 10 Buffer Array long (8 Bytes)

  Start_TP();

  dsPIC33_CAN_EnterConfigMode;                                                  // Place the module in Configuration Mode
  dsPIC33_CAN_SetBaud(CAN_SWJ, CAN_BRP, CAN_PHASESEG_2, CAN_PHASESEG_1, CAN_PROP_SEG, True); // Setup the Baud Rate for 125kHz with a 64Mhz Clock
  dsPIC33_CAN_SetBufferAsTransmitter(0, True);                                  // Setup Buffer 0 as a Transmit Buffer
  dsPIC33_CAN_SetBufferAsTransmitter(1, True);                                  // Setup Buffer 1 as a Transmit Buffer
  dsPIC33_CAN_EnableDisableRXFilters($0000);                                    // Disable all RX Filters
  dsPIC33_CAN_EnterNormalMode;                                                  // Place the module in Normal Mode

  dsPIC33_DMA_DataSize(0, DATASIZE_WORD);                                       // DMA Data Size is a Word
  dsPIC33_DMA_Direction(0, DIRECTION_RAM_TO_PERIPHERAL);                        // Transmit move data from RAM to the Module
  dsPIC33_DMA_AddressMode(0, ADDRESS_MODE_REG_INDIRECT_POST_INCREMENT);         // Don't use the buggy Perpherial Addressing Mode
  dsPIC33_DMA_OperatingMode(0, OPERATING_MODE_CONTINIOUS);                      // Continious Mode (as apposed to one shot)
  dsPIC33_DMA_ManualDMATransfer(0, False);                                      // Automatic DMA Transfers
  dsPIC33_DMA_PeripheralAddress(0, @C1TXD);                                     // Assign the DMA Channel to the Transmit Register of the CAN module
  dsPIC33_DMA_InterruptSelect(0, IRQ_ECAN1_TX_DATA_READY);                      // Assign the DMA Channel to the ECAN 1 TX to Trigger the Transfer
  dsPIC33_DMA_Enable(0, True);                                                  // Enable DMA Channel 0
  
  dsPIC33_CAN_TXBufferInterrupt(True);                                          // Enable the TX Done Event Interrupt
  
  dsPIC33_CAN_GlobalInterruptCAN_EventPriority(6);                              // CAN Event Interrupt has a priority of 6 out of 7
  dsPIC33_CAN_GlobalInterruptCAN_Event(True);                                   // Enable the CAN Event Interrupt

  LoadBuffer(@TX_CANLayer_List, $00000010, 8, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBuffer(@TX_CANLayer_List, $00000009, 7, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBuffer(@TX_CANLayer_List, $00000008, 6, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBuffer(@TX_CANLayer_List, $00000007, 5, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBuffer(@TX_CANLayer_List, $00000006, 4, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBuffer(@TX_CANLayer_List, $00000005, 3, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBuffer(@TX_CANLayer_List, $00000004, 2, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBuffer(@TX_CANLayer_List, $00000003, 1, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBuffer(@TX_CANLayer_List, $00000002, 0, 1, 2, 3, 4, 5, 6, 7, 8, True);

  WriteTXBuffer;
 //WriteDMAInfo;
// WriteCANInfo;
 //WriteCAN_TX_Info;
 
  if TX_CANLayer_List.Count > 0 then
  begin
    dsPIC33_DMA_AddressOffsetA(0, CANStorage_FirstFullBuffer(@TX_CANLayer_List));                                    // Address Offset from the DAM RAM Start Address is 0
    dsPIC33_DMA_TransferCount(0, dsPIC33_CAN_CalculateBufferSizeForRegAddressWithAutoIncrement(CANStorage_FirstFullBuffer(@TX_CANLayer_List)));
    dsPIC33_CAN_RequestTransmit(0);
  end;

  while true do
  begin
    Check_TP();

  end;

end.
