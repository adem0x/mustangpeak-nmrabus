{*
 * Project name:
     Throttle.vtft
 * Generated by:
     Visual TFT
 * Date of creation
     3/24/2012
 * Time of creation
     12:48:16 PM
 * Test configuration:
     MCU:             P33FJ256GP710A
     Dev.Board:       MikroMMB_for_dsPIC33_hw_rev_1.10
                      http://www.mikroe.com/eng/products/view/586/mikrommb-for-dspic33-board/
     Oscillator:      64000000 Hz
     SW:              mikroPascal PRO for dsPIC
                      http://www.mikroe.com/eng/products/view/230/mikropascal-pro-for-dspic30-33-and-pic24/
 *}

program Throttle_main;

uses
  Throttle_events_code,
  MCU_Setup_dsPIC33FJ256GP710A,
  CANStorage,
  dsPIC33_CAN,
  dsPIC33_DMA;
  
var
  s1, s2: array[0..64] of Char;
  Update: Boolean;
  
// ****************************************************************************
// procedure LoadCAN_EngineWithPendingList;
//
// Loads the highest priority list with a message pending or nil if all are empty
// The result is stored in the CAN_Engine.TransmittingList so withing the interrupt
// we can remove this item from the list.
// For more (or less) priority buffer transmit lists edit this function and
// add/intialize more TCANRawBufferLists
//
// ****************************************************************************
procedure LoadCAN_EngineWithPendingList;
begin
   if TX_CANLayer_List.Count > 0 then
    CAN_Engine.TransmittingList := @TX_CANLayer_List                            // Highest Priority List
  else
  if TX_NMRABusLayer_List.Count > 0 then                                        // Least Priority List
    CAN_Engine.TransmittingList := @TX_NMRABusLayer_List
  else
    CAN_Engine.TransmittingList := PCANRawBufferList( nil)
end;

// ****************************************************************************
// function StartTransmission: Boolean;
//
// Starts the transmission if there are no current transmits in procress
//
// ****************************************************************************
function StartTransmission: Boolean;
var
  WordCount: Word;
  NextBuffer: PCANRawBuffer;
begin
  Result := False;

  // Pick the highest Priority List to send next
  LoadCAN_EngineWithPendingList;

  if CAN_Engine.TransmittingList <> nil then
  begin
    // Get a pointer to the Buffer to transmit
    NextBuffer := CANStorage_Tail(CAN_Engine.TransmittingList);
    // If there is something to send then send it
    if NextBuffer <> nil then
    begin
      // In Register Indirect Mode we have to set the offset from the start of the Buffer Manually
      dsPIC33_DMA_AddressOffsetA(0, Word( NextBuffer));
      // In Register Indirect Mode we also have to change the number of words the transmit module will
      // send manually
      WordCount := dsPIC33_CAN_CalculateTransmitCountForRegAddressWithAutoIncrement(NextBuffer);
      dsPIC33_DMA_TransferCount(0, WordCount);
      // Set the Flag to start the transmission
      dsPIC33_CAN_RequestTransmit(0);
      Result := True;
    end
  end
end;

// ****************************************************************************
// procedure StartCANMessageEngine;
//
// Starts the transmitter engine if there are no current transmits in procress
//
// ****************************************************************************
procedure StartCANMessageEngine;
begin
  // Can't let the interrupt be called "right after" we make the comparison to see if the list is empty.
  // That would be a race condition that may not start the next message from being sent.  By
  // shutting off the interrupt we can be guarenteed that the interrupt can't not be called
  // during our comparison and any newly added messages will get sent
  dsPIC33_CAN_TXBufferInterrupt(False);

  // If the CAN_Engine is not transmitting we need to start the transmission of any
  // messages in the buffer list.  If it is already running then the interrupt that
  // is called after the current message is finished will auto load any new messages
  if not dsPIC33_CAN_EngineTransmitting then
    StartTransmission;

  // Re-enable the Transmit interrupt
  dsPIC33_CAN_TXBufferInterrupt(True);
end;


procedure Interrupt_CAN_Event(); iv IVT_ADDR_C1INTERRUPT; ics ICS_AUTO;
var
  Next: PCANRawBuffer;
  TargetList: PCANRawBufferList;
begin
  dsPIC33_CAN_GlobalInterruptFlagCAN_Event(True);                              // Reset the Global CAN Event Interrupt Flag

  while dsPIC33_CAN_InterruptCode <> ICODE_NO_INTERRUPT do                      // Use the Interrupt Code to decode the Events that are both Enabled and Flags are set
  begin
    case dsPIC33_CAN_InterruptCode of
      ICODE_TRB0 :
      begin
        dsPIC33_CAN_InterruptFlagTXBuffer(True);                                // TX Interrupt Flag Reset

        // Must release the Buffer slot that was just sent
        // CAN_Engine.TransmittingList should NEVER be nil if we enter this interrupt
        // and if it is there is an error in the code
        CANStorage_IncTail(CAN_Engine.TransmittingList);

        if not StartTransmission then
        begin
          CAN_Engine.State := CAN_Engine.State and not CES_TRANSMITTING;
          CAN_Engine.TransmittingList := PCANRawBufferList( nil)
        end
      end;
      ICODE_TRB1 :
      begin  LATG3_bit := 1;
        // CAN Layer Reception
        dsPIC33_CAN_InterruptFlagRXBuffer(True);                                // RX Interrupt Flag Reset
        
        if RX_Funnel_RawBufferArray[0].Word7 = 0 then                           // Test what Filter passed the message and filter to the correct List
          TargetList := @RX_CANLayer_List
        else
          TargetList := @RX_NMRABusLayer_List;

        Next := CANStorage_Head(TargetList);
        if Next <> nil then
        begin
          Next^ := RX_Funnel_RawBufferArray[0];
          CANStorage_IncHead(TargetList);
        end else
        begin
            // Have overrun problem
        end;
        dsPIC33_DMA_AddressOffsetA(1, @RX_Funnel_RawBufferArray[0]);            // Point the Receive Buffer Offset
        dsPIC33_CAN_RX_Full(1, True);                                           // Reset the Full Flag
        Update := True;
        LATG3_bit := 0;
      end;
    end
  end;
end;

var
  xx,
  CANLayerCount,
  NMRABusLayerCount: Word;

begin
  MCU_Setup_Initialize;
  dsPIC33_CAN_Initialize;
  CANStorage_InitializeList(@TX_CANLayer_List, @TX_CANLayer_RawBufferArray, 10);            // Overlays DMA RAM and is 10 Buffer Array long (8 Bytes)
  CANStorage_InitializeList(@TX_NMRABusLayer_List, @TX_NMRABusLayer_RawBufferArray, 10);    // Overlays DMA RAM and is 10 Buffer Array long (8 Bytes)
  CANStorage_InitializeList(@RX_CANLayer_List, @RX_CANLayer_RawBufferArray, 10);            // Overlays DMA RAM and is 10 Buffer Array long (8 Bytes)
  CANStorage_InitializeList(@RX_NMRABusLayer_List, @RX_NMRABusLayer_RawBufferArray, 10);    // Overlays DMA RAM and is 10 Buffer Array long (8 Bytes)

  Start_TP();

  dsPIC33_CAN_EnterConfigMode;                                                  // Place the module in Configuration Mode
  // Setup the CAN Baud Rate
  dsPIC33_CAN_SetBaud(CAN_SWJ, CAN_BRP, CAN_PHASESEG_2, CAN_PHASESEG_1, CAN_PROP_SEG, True); // Setup the Baud Rate for 125kHz with a 64Mhz Clock
  dsPIC33_CAN_EnterNormalMode;                                                  // Place the module in Normal Mode

  // Setup the CAN Transmitter
  dsPIC33_CAN_SetBufferAsTransmitter(0, True);                                  // Setup Buffer 0 as a Transmit Buffer
  // Setup the CAN Receiver
  dsPIC33_CAN_SetMask(2, $08000000, True);                                      // Mask 2 looks only at bit 27 for the Filters
  dsPIC33_CAN_SetFilter(0, $00000000, True);                                    // Look for a 0 in bit 27  (CAN Layer Messsage)
  dsPIC33_CAN_SetFilter(1, $08000000, True);                                    // Look for a 1 in bit 27  (NMRABus Layer Message)
  dsPIC33_CAN_AssociateFilterWithMask(0, 2);                                    // Link Filter 0 and Mask 2 which looks only at bit 27 = 0
  dsPIC33_CAN_AssociateFilterWithMask(1, 2);                                    // Link Filter 1 and Mask 2 which looks only at bit 27 = 1
  dsPIC33_CAN_EnableDisableRXFilters($0003);                                    // Enable Filters 0 and 1
  dsPIC33_CAN_RegisterBufferWithFilter(0, 1);                                   // Filter 0 to be sent to Buffer 1
  dsPIC33_CAN_RegisterBufferWithFilter(1, 1);                                   // Filter 1 to be sent to Buffer 2

  // Set up the Transmit DMA
  dsPIC33_DMA_DataSize(0, DATASIZE_WORD);                                       // DMA Data Size is a Word
  dsPIC33_DMA_Direction(0, DIRECTION_RAM_TO_PERIPHERAL);                        // Transmit move data from RAM to the Module
  dsPIC33_DMA_AddressMode(0, ADDRESS_MODE_REG_INDIRECT_POST_INCREMENT);         // Don't use the buggy Perpherial Addressing Mode
  dsPIC33_DMA_OperatingMode(0, OPERATING_MODE_CONTINIOUS);                      // Continious Mode (as apposed to one shot)
  dsPIC33_DMA_ManualDMATransfer(0, False);                                      // Automatic DMA Transfers
  dsPIC33_DMA_PeripheralAddress(0, @C1TXD);                                     // Assign the DMA Channel to the Transmit Register of the CAN module
  dsPIC33_DMA_InterruptSelect(0, IRQ_ECAN1_TX_DATA_READY);                      // Assign the DMA Channel to the ECAN 1 TX to Trigger the Transfer
  dsPIC33_DMA_Enable(0, True);                                                  // Enable DMA Channel 0
  
  // Setup the Receive DMA
  dsPIC33_DMA_DataSize(1, DATASIZE_WORD);                                       // DMA Data Size is a Word
  dsPIC33_DMA_Direction(1, DIRECTION_PERIPHERAL_TO_RAM);                        // Transmit move data from the Module to RAM
  dsPIC33_DMA_AddressMode(1, ADDRESS_MODE_REG_INDIRECT_POST_INCREMENT);         // Don't use the buggy Perpherial Addressing Mode
  dsPIC33_DMA_OperatingMode(1, OPERATING_MODE_CONTINIOUS);                      // Continious Mode (as apposed to one shot)
  dsPIC33_DMA_TransferCount(1, 8);                                              // Transfers 8 Words (0 counts as 1)
  dsPIC33_DMA_ManualDMATransfer(1, False);                                      // Automatic DMA Transfers
  dsPIC33_DMA_PeripheralAddress(1, @C1RXD);                                     // Assign the DMA Channel to the Receive Register of the CAN module
  dsPIC33_DMA_InterruptSelect(1, IRQ_ECAN1_RX_DATA_READY);                      // Assign the DMA Channel to the ECAN 1 RX to Trigger the Transfer
  dsPIC33_DMA_AddressOffsetA(1, @RX_Funnel_RawBufferArray[0]);                  // Point the Receive Buffer Offset into the CAN Layer Buffer
  dsPIC33_DMA_Enable(1, True);                                                  // Enable DMA Channel 1
  
  dsPIC33_CAN_TXBufferInterrupt(True);                                          // Enable the TX Done Event Interrupt
  dsPIC33_CAN_RXBufferInterrupt(True);                                          // Enable the RX Done Event Interrupt
  
  dsPIC33_CAN_GlobalInterruptCAN_EventPriority(6);                              // CAN Event Interrupt has a priority of 6 out of 7
  dsPIC33_CAN_GlobalInterruptCAN_Event(True);                                   // Enable the CAN Event Interrupt
  

 { LoadBufferAndWriteToList(@TX_CANLayer_List, $00000010, 8, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000009, 7, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000008, 6, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000007, 5, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000006, 4, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000005, 3, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000004, 2, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000003, 1, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000002, 0, 1, 2, 3, 4, 5, 6, 7, 8, True);
  
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000001, 8, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000000, 8, 1, 2, 3, 4, 5, 6, 7, 8, True);
  
  LoadBufferAndWriteToList(@TX_NMRABusLayer_List, $1FFFFFFF, 8, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_NMRABusLayer_List, $1FFFFFFF, 7, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_NMRABusLayer_List, $1FFFFFFF, 6, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_NMRABusLayer_List, $1FFFFFFF, 5, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_NMRABusLayer_List, $1FFFFFFF, 4, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_NMRABusLayer_List, $1FFFFFFF, 3, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_NMRABusLayer_List, $1FFFFFFF, 2, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_NMRABusLayer_List, $1FFFFFFF, 1, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_NMRABusLayer_List, $1FFFFFFF, 0, 1, 2, 3, 4, 5, 6, 7, 8, True);

  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000001, 8, 1, 2, 3, 4, 5, 6, 7, 8, True);
  LoadBufferAndWriteToList(@TX_CANLayer_List, $00000000, 8, 1, 2, 3, 4, 5, 6, 7, 8, True);

  StartCANMessageEngine;   }

  xx := 0;
  CANLayerCount := 0;
  NMRABusLayerCount := 0;
 // WriteBufferInfo;
 
  Update := False;
 // Base := $79E0;
  Base := $7940;
  //Base := $7800;
  Offset := 0;
  ECAN_RegPage := 0;
  DMA_RegPage := 0;
 
  while true do
  begin
    Check_TP();
    Inc(xx);
    if Update then
    begin
   //   WriteBuffer(Base + (Offset*8), Offset);
   //   Update := False
    end;
    
    if xx mod 1000 = 0 then
    begin

    end
  end;

end.