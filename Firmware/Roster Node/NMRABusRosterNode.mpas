program NMRABusRosterNode;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements a NMRABus based Command Station
//
// BUGS, BUGS, BUGS,
//
//  July 14, 2012
//  Response to the Memory Configuration Protocol can respond with Datagrams MUCH larger than 72 bytes.......Ok per Bob
//  Memory Config not working with VNodes
//
// ******************************************************************************
 
uses
  NMRAnetStateMachine,
  NMRAnetDefines,
  CANDefines,
  CANStorage,
  MCU_Setup_dsPIC4013,
  _25AAxxxx,
  NMRAnetEventDefines,
  NMRAnetBufferPools,
  NMRAnetBufferPoolsDefines,
  NMRAnetNode,
  dsPIC30_Traps,
  NodeIDs;
  
{$I Options.inc}

var
  // EEPROM SPI PINS
  CS_Bank_0                         : sbit at LATB12_bit;
  CS_Bank_1                         : sbit at LATB11_bit;
  CS_Bank_0_Direction               : sbit at TRISB12_bit;
  CS_Bank_1_Direction               : sbit at TRISB12_bit;
  
  TrapFlagPin                       : sbit at LATD0_bit;


// *****************************************************************************
//  INTERRUPTS
// *****************************************************************************

procedure INTERRUPT_Timer1(); iv IVT_ADDR_T1INTERRUPT;
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  T1IF_bit := 0;                                                                // Clear the Flag
end;

procedure INTERRUPT_1ms_Timer(); iv IVT_ADDR_T2INTERRUPT;
// Called once every 100m
var
  i: Integer;
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  T2IF_bit := 0;                                                                // Clear the Flag
  for i := 0 to Nodes.Count - 1 do
    NMRAnetStateMachine_100ms_Timer(Nodes.AllocatedList[i]);
end;

{$IFDEF PINCHANGE_INTERRUPT_ENABLE}
procedure INTERRUPT_Pin_Change_Notification(); iv IVT_ADDR_CNINTERRUPT;         // 93us when a TransmitCompleteOnCANLayerPacket called with new Tx Packet waiting
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  CNIF_bit := 0;     // Clear Flag
  PinChangeState := PORTF;
end;
{$ENDIF}

procedure TrainControlCallback(Node: PNMRAnetNode; Datagram: PDatagramBuffer);
//
// The Interrupts are LOCKED within the callbacks.
//
var
  i: Integer;
  TxDatagramBuffer: PDatagramBuffer;
begin
 // UART1_Write_Text('Train Datagram:'+LF);
  if Datagram <> nil then
  begin
    TxDatagramBuffer := nil;
    if NMRAnetBufferPools_AllocateDatagramBuffer(TxDatagramBuffer, True) then
    begin
      TxDatagramBuffer^.Alias := Datagram^.Alias;
      TxDatagramBuffer^.SourceNodePtr := Generic16BitPointer( Node);
      TxDatagramBuffer^.DataBytes[0] := $C0;
      for i := 1 to Datagram^.DataBytes[1] do
        TxDatagramBuffer^.Databytes[i] := i;
      TxDatagramBuffer^.iByteCount := Datagram^.DataBytes[1] + 1;
    end;
  end
end;

procedure MemConfigurationCallback(Node: PNMRAnetNode; Datagram: PDatagramBuffer);
var
  j, i: Integer;
begin
 { j := Datagram^.iByteCount;
  UART1_Write_Text('MemConfig Datagram:'+LF);
  ByteToStr(j, s1);
  UART1_Write_Text('  ByteCount: '+s1+' Data: ');
  for i := 0 to j-1 do
  begin
    ByteToHex(Datagram^.DataBytes[i], s1);
    UART1_Write_Text(s1);
  end;
  UART1_Write_Text(LF);  }
end;

{$IFDEF UART_ENABLE}
procedure PrintBufferPools(var j: DWORD);
begin
  if j = 200000 then
  begin
   NMRAnetBufferPools_Print;
   j := 0;
  end;
  Inc(j);
end;
{$ENDIF}

{$IFDEF UART_ENABLE}
procedure PrintMaxLoopTimes(var PrintCount: DWord; var x, y: Word);
begin
  Inc(PrintCount);
  if PrintCount > 200000 then
  begin
    if x <> MaxTime_RX then
    begin
      FloatToStr(double( MaxTime_RX)*50e-3, s1);
      UART1_Write_Text('Interrupt Time: '+s1+'us'+LF);
      x := MaxTime_RX
    end;

    if y <> MaxTime_StateMachine then
    begin
      FloatToStr(double( MaxTime_StateMachine)*50e-3, s1);
      UART1_Write_Text('Statemachine Time: '+s1+'us'+LF);
      y := MaxTime_StateMachine
    end;
    PrintCount := 0;
  end;
end;
{$ENDIF}

// *******************
// MAIN LOOP
// *******************
var
  ActiveNode: PNMRAnetNode;
  i, j: Integer;
  x, y: Word;
  PrintCount, Print2Count: DWord;

begin


  LATD0_bit := 0;         // Debugging output     // THIS IS FOR TRAPS RIGHT NOW
  TRISD0_bit := 0;        // Debugging output

  _25AAxxxx_Initialize;
  CANStorage_Initialize;
  NMRAnetStateMachine_Initialize(MUSTANGPEAK_ID_0_HI, MUSTANGPEAK_ROSTER_NODE_ID_0_LO);
  MCU_Setup_Initialize;                                                         // Start the timers and perpherials last

  NMRAnetDatagrams_SetCallback(DatagramTrainControlCallbackFunc, @TrainControlCallback);
  NMRAnetDatagrams_SetCallback(DatagramMemConfigurationCallbackFunc, @MemConfigurationCallback);
  
  for i := 0 to 50 do
    NMRAnetNode_Allocate;
  x := 0;
  y := 0;
  j := 0;
  i := 0;
  PrintCount := 0;
  Print2Count := 0;
  MaxTime_RX := 0;
  MaxTime_StateMachine := 0;
  
  UART1_Write_Text('Startup');

  while (TRUE) do
  begin
  
  //LATD0_bit := not LATD0_bit;
  
  //  delay_us(1000);   // Slows the Statemachine down enough to work withon the CAN/USB adapter
      
    PrintBufferPools(PrintCount);
    PrintMaxLoopTimes(Print2Count, x, y);


    
    LATD0_bit := 1;
     ActiveNode := NMRAnetNode_NextNode;
    if ActiveNode <> PNMRAnetNode( nil) then
    begin
    
      TMR3 := 0;
      NMRAnetStateMachine_Process(ActiveNode);
      if TMR3 > MaxTime_StateMachine then MaxTime_StateMachine := TMR3;

      if NMRAnetNode_TestStateFlag(ActiveNode, NS_PERMITTED) then
      begin

      end;
    end;
    
    LATD0_bit := 0;
  //  PrintMaxLoopTimes(x, y);
  end;
end.