program NMRABusCommandStation;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements a NMRABus based Command Station
//
// ******************************************************************************
 
uses
  NMRAnetMobileNode,
  NMRAnetStateMachine,
  NMRAnetDefines,
  NMRAnetDCC,
  CANDefines,
  CANStorage,
  MCU_Setup_dsPIC4013,
  _25AAxxxx,
  NMRAnetEventDefines,
 // NMRABusNodeItems,
 // NMRAnetUtilities,
 // NMRABusAddressSlots,
 // NMRAnetDatagrams,
  dsPIC30_Traps,
  NodeIDs;
  
{$I Options.inc}

var
  // DCC SIGNAL PINS
  Track_DCC_Out_Pin                 : sbit at LATB10_bit;
  Track_DCC_Out_Bar_Pin             : sbit at LATB9_bit;
  Track_DCC_Out_Pin_Direction       : sbit at TRISB10_bit;
  Track_DCC_Out_Pin_Bar_Direction   : sbit at TRISB9_bit;
  
  // EEPROM SPI PINS
  CS_Bank_0                         : sbit at LATB12_bit;
  CS_Bank_1                         : sbit at LATB11_bit;
  CS_Bank_0_Direction               : sbit at TRISB12_bit;
  CS_Bank_1_Direction               : sbit at TRISB12_bit;


// ****************************************************************************
// procedure GetUniqueIDFunc
//
//  Description:   Callback from NMRABus to load the 48 Bit Unique ID
//
// ****************************************************************************
procedure GetUniqueIDFunc(var HiID, LoID: DWord);
begin
  LoID := MUSTANGPEAK_COMMANDSTATION_ID_0_LO;
  HiID := MUSTANGPEAK_ID_0_HI;
end;


// *****************************************************************************
//  INTERRUPTS
// *****************************************************************************

procedure INTERRUPT_DCC_Timer(); iv IVT_ADDR_T1INTERRUPT;
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  T1IF_bit := 0;                                                                // Clear the Flag
  
  Track_DCC_Out_Pin := Track.TX_Flags.TRANSMITTING_FLAG_DCC_PIN_BIT;
  Track_DCC_Out_Bar_Pin := not Track_DCC_Out_Pin;
  
  // Now we can update the xxxx_DCC_PIN_BIT flags for the next 56us time slot
  NMRA_DCC_56us_TimeTick(@Track);                                                          // < 1us
  NMRA_DCC_TransmitterStateMachine(@Track);                                                // < 5us
  NMRA_DCC_LoadPacketIntoTransmitterStateMachine(@Track, PREAMBLE_BIT_COUNT_NORMAL);      // < 11us    Max
end;

procedure INTERRUPT_1ms_Timer(); iv IVT_ADDR_T2INTERRUPT;
// Called once every 1m
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  T2IF_bit := 0;                                                                // Clear the Flag
  NMRAnetStateMachine_1ms_Timer(@NMRAnetNodeBuffer); // TODO ENUMERATE ALL THE ACTIVE NODE BUFFERS!!!!!!!!!!!!
end;

{$IFDEF PINCHANGE_INTERRUPT_ENABLE}
procedure INTERRUPT_Pin_Change_Notification(); iv IVT_ADDR_CNINTERRUPT;         // 93us when a TransmitCompleteOnCANLayerPacket called with new Tx Packet waiting
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  CNIF_bit := 0;     // Clear Flag
  PinChangeState := PORTF;
end;
{$ENDIF}

var
  s1: array[8] of char;
  s2: array[32] of char;
  delay: word;


procedure TrainControlCallback(NodeBuffer: PNMRAnetNodeBuffer; Datagram: PDatagramBuffer; var Handled: Boolean);
var
  i: Integer;
begin
  Handled := True;
  
  NodeBuffer^.DatagramTransmit.List[0].Databytes[0] := $C0;
  for i := 1 to Datagram^.DataBytes[1] do
    NodeBuffer^.DatagramTransmit.List[0].Databytes[i] := i;
  NodeBuffer^.DatagramTransmit.List[0].iByteCount := Datagram^.DataBytes[1] + 1;
  NodeBuffer^.DatagramTransmit.List[0].Alias := $ee9;
  NodeBuffer^.DatagramTransmit.List[0].State := DATAGRAM_BUFFER_IN_PROCESS;  // Kick it off.

end;

procedure MemConfigurationCallback(NodeBuffer: PNMRAnetNodeBuffer; Datagram: PDatagramBuffer; var Handled: Boolean);
//var
 // j, i: Integer;
begin
  Handled := True;
 { j := Datagram^.iByteCount;
  UART1_Write_Text('MemConfig Datagram:'+LF);
  ByteToStr(j, s1);
  UART1_Write_Text('  ByteCount: '+s1+' Data: ');
  for i := 0 to j-1 do
  begin
    ByteToHex(Datagram^.DataBytes[i], s1);
    UART1_Write_Text(s1);
  end;
  UART1_Write_Text(LF);  }
end;

procedure AbbriviatedCDICallback(NodeBuffer: PNMRAnetNodeBuffer; ACDI_Buffer: PACDI_ReceiveBuffer);
var

 i: Integer;
  s1: string[32];
  
begin
 { UART1_Write_Text('Mfg Address: ') ;
  WordToHex(@Buffer^.Mfg[i], s1);
  UART1_Write_Text(s1+LF) ;
  
  for i := 0 to ACDI_LEN_MFG-1 do
  begin
    byteToHex(Buffer^.Mfg[i], s1);
    UART1_Write_Text(s1 + ' ');
  end;
  
  UART1_Write_Text(LF+'MfgName Address: ') ;
  WordToHex(@Buffer^.MfgName[0], s1);
  UART1_Write_Text(s1+LF) ;
  
  for i := 0 to ACDI_LEN_MFG_NAME-1 do
  begin
    byteToHex(Buffer^.MfgName[i], s1);
    UART1_Write_Text(s1 + ' ');
  end;
  
  UART1_Write_Text(LF+'MfgHWVer Address: ') ;
  WordToHex(@Buffer^.MfgHWVer[0], s1);
  UART1_Write_Text(s1+LF) ;

  for i := 0 to ACDI_LEN_MFG_HW_VER-1 do
  begin
    byteToHex(Buffer^.MfgHWVer[i], s1);
    UART1_Write_Text(s1 + ' ');
  end;
  
  UART1_Write_Text(LF+'MfgSWVer Address: ') ;
  WordToHex(@Buffer^.MfgSWVer[0], s1);
  UART1_Write_Text(s1+LF) ;
  
  for i := 0 to ACDI_LEN_MFG_SW_VER-1 do
  begin
    byteToHex(Buffer^.MfgSWVer[i], s1);
    UART1_Write_Text(s1 + ' ');
  end;
  
  UART1_Write_Text(LF+'UserName Address: ') ;
  WordToHex(@Buffer^.UserName[0], s1);
  UART1_Write_Text(s1+LF) ;
  
  for i := 0 to ACDI_LEN_USER_NAME-1 do
  begin
    byteToHex(Buffer^.UserName[i], s1);
    UART1_Write_Text(s1 + ' ');
  end;

 UART1_Write_Text(LF+'UserDesc Address: ') ;
  WordToHex(@Buffer^.UserDesc[0], s1);
  UART1_Write_Text(s1+LF) ;

  for i := 0 to ACDI_LEN_USER_DESC-1 do
  begin
    byteToHex(Buffer^.UserDesc[i], s1);
    UART1_Write_Text(s1 + ' ');
  end;
  UART1_Write_Text(LF) ;
  
  }
  ByteToStr(ACDI_Buffer^.MfgVersion, s1);
  UART1_Write_Text('Mfg Version: ' + s1+LF);
  ByteToStr(ACDI_Buffer^.UserVersion, s1);
  UART1_Write_Text('User Version: ' + s1+LF);
  WordToHex(ACDI_Buffer^.SourceAlias, s1);
  UART1_Write_Text('Source Alias: ' + s1+LF);
  
  UART1_Write_Text(ACDI_Buffer^.Mfg+LF);
  UART1_Write_Text(ACDI_Buffer^.MfgName+LF);
  UART1_Write_Text(ACDI_Buffer^.MfgHWVer+LF);
  UART1_Write_Text(ACDI_Buffer^.MfgSWVer+LF);
  UART1_Write_Text(ACDI_Buffer^.UserName+LF);
  UART1_Write_Text(ACDI_Buffer^.UserDesc+LF);
  ACDI_Buffer^.State := ACDI_BUFFER_STATE_EMPTY;                                     // Release the buffer
end;

procedure ComplexResponseCallback(Response: PQueuedResponse);
begin
 // case Response^.nCode of
  
 // end;
end;

// *******************
// MAIN LOOP
// *******************
var
  Packet: TCANBuffer;
  DCC_Message: TDCCPacket;
  laststate, Rlaststate: word;
  
  s_float: array[23] of char;
  
  xx: Word;
  rr: real;
  ii: Integer;
  ii2: Integer;
  
begin

  Track_DCC_Out_Pin := 0;
  Track_DCC_Out_Pin := 0;
  Track_DCC_Out_Pin_Direction := 0;      // Output
  Track_DCC_Out_Pin_Bar_Direction := 0;  // Output
  
  LATD0_bit := 0;         // Debugging output
  TRISD0_bit := 0;        // Debugging output

  _25AAxxxx_Initialize;
  CANStorage_Initialize;
  NMRAnetStateMachine_Initialize(@NMRAnetNodeBuffer);
  MCU_Setup_Initialize;
  NMRA_DCC_Initialize;

  NMRAnetDatagrams_SetCallback(DatagramTrainControlCallbackFunc, @TrainControlCallback);
//  NMRAnetDatagrams_SetCallback(DatagramMemConfigurationCallbackFunc, @MemConfigurationCallback);
//  NMRAnetStateMachine_SetComplexCallbackFunc(@ComplexResponseCallback);
 // NMRAnetAbbreviatedConfigurationProtocol_ReplyCallback(@AbbriviatedCDICallback);
  

 // UART1_Write_Text('Connecting'+LF);
  
  laststate := $FF;
  Rlaststate := 0;
  MaxTime_StateMachine := 0;
  MaxTime_RX := 0;
  delay := 0;
  
 // NMRAnetMobileNode_InitializeEEPROM;
  


  while (TRUE) do
  begin

  

    {   if laststate <> ACDI_ReceiveBufferList.List[0].iState then
       begin
         ByteToStr(ACDI_ReceiveBufferList.List[0].iState, s1);
         UART1_Write_Text(s1+LF);
         laststate := ACDI_ReceiveBufferList.List[0].iState
       end;    }
       
       
    TMR3 := 0;
    NMRAnetStateMachine_Process(@NMRAnetNodeBuffer);
  
  {  if TMR3 > MaxTime_StateMachine then
    begin
      MaxTime_StateMachine := TMR3;
      FloatToStr((50e-9*double( MaxTime_StateMachine))*1e6, s_float);
      UART1_Write_Text('StateMachine Max: ' + s_float+'us'+LF);
    end;
    
    if MaxTime_RX <> Rlaststate then
    begin
      FloatToStr((50e-9*double( MaxTime_RX))*1e6, s_float);
      UART1_Write_Text('CAN RX Max: ' + s_float+'us'+LF);
      Rlaststate := MaxTime_RX
    end;      }
    


    delay_us(600);    // Slows the Statemachine down enough to work with 115k Baud on the CAN/USB adapter

    if NMRAnetCANReceive_Permited(@NMRAnetNodeBuffer) then
    begin

    end;
  end;
end.