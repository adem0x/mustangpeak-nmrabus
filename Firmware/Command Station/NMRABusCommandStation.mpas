program NMRABusCommandStation;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements a NMRABus based Command Station
//
// ******************************************************************************
 
uses
  NMRABus,
  CANDefines,
  CANStorage,
  MCU_Setup_dsPIC4013,
  _25AAxxxx,
  NMRABusDCC,
  NMRABusNodeItems,
  NMRABusUtilities,
  NMRABusAddressSlots,
  NMRABusDatagrams,
  dsPIC30_Traps,
  NodeIDs;
  
{$I Options.inc}

const
  LF = #13+#10;

var
  // DCC SIGNAL PINS
  Track_DCC_Out_Pin                 : sbit at LATB10_bit;
  Track_DCC_Out_Bar_Pin             : sbit at LATB9_bit;
  Track_DCC_Out_Pin_Direction       : sbit at TRISB10_bit;
  Track_DCC_Out_Pin_Bar_Direction   : sbit at TRISB9_bit;
  
  // EEPROM SPI PINS
  CS_Bank_0                         : sbit at LATB12_bit;
  CS_Bank_1                         : sbit at LATB11_bit;
  CS_Bank_0_Direction               : sbit at TRISB12_bit;
  CS_Bank_1_Direction               : sbit at TRISB12_bit;


// ****************************************************************************
// procedure GetUniqueIDFunc
//
//  Description:   Callback from NMRABus to load the 48 Bit Unique ID
//
// ****************************************************************************
procedure GetUniqueIDFunc(var HiID, LoID: DWord);
begin
  LoID := MUSTANGPEAK_COMMANDSTATION_ID_0_LO;
  HiID := MUSTANGPEAK_ID_0_HI;
end;


// *****************************************************************************
//  INTERRUPTS
// *****************************************************************************

procedure INTERRUPT_DCC_Timer(); iv IVT_ADDR_T1INTERRUPT;
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  T1IF_bit := 0;                                                                // Clear the Flag
  
  Track_DCC_Out_Pin := Track.TX_Flags.TRANSMITTING_FLAG_DCC_PIN_BIT;
  Track_DCC_Out_Bar_Pin := not Track_DCC_Out_Pin;
  
  // Now we can update the xxxx_DCC_PIN_BIT flags for the next 56us time slot
  NMRA_DCC_56us_TimeTick(@Track);                                                          // < 1us
  NMRA_DCC_TransmitterStateMachine(@Track);                                                // < 5us
  NMRA_DCC_LoadPacketIntoTransmitterStateMachine(@Track, PREAMBLE_BIT_COUNT_NORMAL);      // < 11us    Max
end;

procedure INTERRUPT_Global_Timer(); iv IVT_ADDR_T2INTERRUPT;
// Called once every 1m
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  T2IF_bit := 0;                                                                // Clear the Flag
  NMRABus_GlobalTimer;
  EnableCANInterrupt(False);
  NMRABusDatagrams_840ms_TimeTick;
  EnableCANInterrupt(True);
end;

{$IFDEF PINCHANGE_INTERRUPT_ENABLE}
procedure INTERRUPT_Pin_Change_Notification(); iv IVT_ADDR_CNINTERRUPT;         // 93us when a TransmitCompleteOnCANLayerPacket called with new Tx Packet waiting
begin
  // Silicon Bug in the 4013, if Interrupt is disabled, then Interrupt 2 of higher priority is called (nested) an Address Trap can be thrown
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #2; end; {$ENDIF}
  CNIF_bit := 0;     // Clear Flag
  PinChangeState := PORTF;
end;
{$ENDIF}

procedure NMRABusPacketHandler(CANBuffer: PCANBuffer; var DoDefault: Boolean);
var
  s1: array[64] of char;
  s2: array[8] of char;
  i: Integer;
begin

Exit;

  LongIntToHex(CANBuffer^.ID, s2);
  s1 := 'NMRA: ' + s2;
  UART1_Write_Text(s1+LF);
  
  ByteToStr(CANBuffer^.DataCount, s2);
  s1 := 'Count: ' + s2;
  UART1_Write_Text(s1+LF);
  
  for i := 0 to CANBuffer^.DataCount-1 do
  begin
    ByteToStr(CANBuffer^.DataBytes[i], s2);
    s1 := 'Byte: ' + s2;
    UART1_Write_Text(s1+LF);
  end;

end;

procedure CANBusPacketHook(CANBuffer: PCANBuffer; var DoDefault: Boolean);
// WARNING: THIS IS CALLED IN THE CONTEXT OF THE INTERRUPT AND CAN NOT BE LONGER THAN
// IT TAKES TO RECEIVE THE NEXT CAN MESSAGE!!!!!!!!
begin

end;


// *******************
// MAIN LOOP
// *******************

var
  Packet: TCANBuffer;
  DCC_Message: TDCCPacket;
  Loop: DWord;
  s1: array[8] of char;
  s2: array[32] of char;
begin

  Track_DCC_Out_Pin := 0;
  Track_DCC_Out_Pin := 0;
  Track_DCC_Out_Pin_Direction := 0;      // Output
  Track_DCC_Out_Pin_Bar_Direction := 0;  // Output
  
  LATD0_bit := 0;         // Debugging output
  TRISD0_bit := 0;        // Debugging output

  _25AAxxxx_Initialize;
  NMRABusNodeItems_Initialize;
  CANStorage_Initialize;
  NMRABus_Initialize;
  MCU_Setup_Initialize;
  NMRA_DCC_Initialize;
  AddressSlots_Initialize;
  
  NMRABus_SetCANLayerReceiveHook(@CANBusPacketHook);
 
  UART1_Write_Text('Connecting'+LF);
  
  Loop := 0;
  NMRABus_Connect;
  while (TRUE) do
    begin
      if not NMRABus_Permitted then
      begin
        UART1_Write_Text('Reconnecting'+LF);
        NMRABusUtilities_RecreateAliasID;
        NMRABus_Connect;
      end;
      
      if NMRABus_Permitted then
      begin
        
        UART1_Write_Text('Connected'+LF);

        NMRA_DCC_Packet_Init;                                                   // Send the 20 Idle Packets per the NMRA Spec
        
        UART1_Write_Text('DCC Packets Done'+LF);
        
        while NMRABus_Permitted do
        begin
          HandlePacketReceivedOnNMRABusLayer(@NMRABusPacketHandler);
          
          if Loop mod 100000 = 0 then
          begin
        {    ByteToStr(TX_CANLayer_List.MaxCount, s1);
            s2 := 'CAN TX:  ';
            s2 := s2 + s1;
            UART1_Write_Text(s2 + LF);
            
            ByteToStr(RX_CANLayer_List.MaxCount, s1);
            s2 := 'CAN RX:  ';
            s2 := s2 + s1;
            UART1_Write_Text(s2 + LF);
            
            ByteToStr(TX_NMRABUsLayer_List.MaxCount, s1);
            s2 := 'NMRA TX: ';
            s2 := s2 + s1;
            UART1_Write_Text(s2 + LF);
            
            ByteToStr(RX_NMRABusLayer_List.MaxCount, s1);
            s2 := 'NMRA RX: ';
            s2 := s2 + s1;
            UART1_Write_Text(s2 + LF);   }
          end;
          Inc(Loop);
          
        end
      end
    end;
end.