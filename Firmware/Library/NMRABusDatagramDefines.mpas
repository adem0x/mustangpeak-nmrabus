unit NMRABusDatagramDefines;

uses
  CANDefines,
  NMRABusDefines;

const
  DATAGRAM_REJECTED                                     = $0000;
  // Errors that will cause sender to not retry
  DATAGRAM_REJECTED_PERMANENT_ERROR                     = $0100;
  DATAGRAM_REJECTED_INFORMATION_LOGGED                  = $0101;
  DATAGRAM_REJECTED_SOURCE_NOT_PERMITTED                = $0102;
  DATAGRAM_REJECTED_SOURCE_DATAGRAMS_NOT_ACCEPTED       = $0104;
  DATAGRAM_REJECTED_BUFFER_FULL                         = $0200;
  DATAGRAM_REJECTED_OUT_OF_ORDER                        = $0600;

  DATAGRAM_REJECTED_NO_RESENT_MASK                      = $0100;
  DATAGRAM_REJECTED_RESEND_MASK                         = $0200;
  DATAGRAM_REJECTED_TRANSPORT_ERROR_MASK                = $0400;


  LEN_DATAGRAM       = 72;                                                      // How many Bytes in the datagram
  LEN_DATAGRAM_ARRAY = 1;                                                       // How many Datagram buffers to have

  STATE_DATAGRAM_EMPTY             = 0;                                         // The Datagram Packet Buffer is empty
  STATE_DATAGRAM_RECEIVING         = 1;                                         // The Datagram Packet Buffer is currently collecting frames
  STATE_DATAGRAM_TRANSFER_FULL     = 3;                                         // The Datagram Packet has responded to the sender and ready for use (DATAGRAM_REJECTED_BUFFER_FULL response needed)
  STATE_DATAGRAM_FRAME_OUTOFORDER  = 4;                                         // The Datagram frames were corrupted (greater than DATAGRAM_MAX_FRAME_COUNT ect.) (DATAGRAM_REJECTED_OUT_OF_ORDER response needed)
  STATE_DATAGRAM_READY             = 5;                                         // The Datagram is ready for consumption by the application

  STATE_DATAGRAM_PROCESSOR_START           = 0;
  STATE_DATAGRAM_PROCESSOR_ABANDONED       = 1;
  STATE_DATAGRAM_PROCESSOR_ERROR           = 2;
  STATE_DATAGRAM_PROCESSOR_OK              = 3;
  STATE_DATAGRAM_PROCESSOR_NEXT            = 4;

  DATAGRAM_WATCHDOG_MAX = 10000;                                                // 1ms counts before the datagram is declared abandon
  
  DATAGRAM_MAX_FRAME_COUNT = 9;                                                 // Maximum number of Frames (segments) in a Datagram
  

  
type  
  TDatagram = array[0..LEN_DATAGRAM-1] of Byte;
  
  TDatagramBuffer = record
    DataBytes: TDatagram;                                                       // The bytes sent in the datagram
    SourceAlias: Word;                                                          // The Node that sent the datagram
    iState: Byte;                                                               // The State of the Packet Buffer,
    iFrameCount: Byte;                                                          // Counts the number of bytes recevied as they come in, used to index where to add the next 8 bytes
    iWatchdog: Word;                                                            // Increments every 1ms or so to allow detecting a datagram that was abandon and never sent the End message
  end;
  PDatagramBuffer = ^TDatagramBuffer;
  TDatagramBufferArray = array[0..LEN_DATAGRAM_ARRAY-1] of TDatagramBuffer;

  TDatagramProcessor = record
    iState: Byte;                                                               // State of the Processor
    iBuffer: Byte;                                                              // Index to the next item in the array
  end;
var
  DatagramList: TDatagramBufferArray;
  DatagramProcessor: TDatagramProcessor;
  
implementation

end.