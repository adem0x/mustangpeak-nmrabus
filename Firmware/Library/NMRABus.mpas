// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRABus specifications
//
// ******************************************************************************
unit NMRABus;

uses
  NMRABusDefines,
  NMRABusUtilities,
  CAN_Storage;
  
{$I Options.inc}

type
  TGetUniqueIDFunc = procedure(var Hi, Lo: DWord);
  PGetUniqueIDFunc = ^TGetUniqueIDFunc;
{  TSignalTransmitOnCANLayerFunc = procedure();
  PSignalTransmitOnCANLayerFunc = ^TSignalTransmitOnCANLayerFunc;
  TSignalTransmitOnNMRALayerFunc = procedure();
  PSignalTransmitOnNMRALayerFunc = ^TSignalTransmitOnNMRALayerFunc;   }
  
var
  GetUniqueIDFunc: PGetUniqueIDFunc; external;
 // SignalTransmitOnCANLayerFunc: PSignalTransmitOnCANLayerFunc; external;
 // SignalTransmitOnNMRALayerFunc: PSignalTransmitOnNMRALayerFunc; external;
  
  Transmit_CANLayer_List: PCANRawBufferList; external;
  Transmit_NMRABusLayer_List: PCANRawBufferList; external;
  Receive_CANLayer_List: PCANRawBufferList; external;
  Receive_NMRABusLayer_List: PCANRawBufferList; external;

  procedure NMRABus_Connect;
  function NMRABus_Connected: Boolean;
  procedure NMRABus_Disconnect;
  procedure NMRABus_Initialize;
  procedure NMRABus_GlobalTimer;

  procedure HandleTransmitCompleteOnNMRALayerPacket;
  procedure HandlePacketReceivedOnNMRABusLayer;
  procedure HandleTransmitCompleteOnCANLayerPacket;
  procedure HandlePacketReceivedOnCANLayer;
  procedure HandleCANError;
  procedure HandleLoPriorityReceivedNMRABusLayerPackets;
  procedure HandleLoPriorityReceivedCANLayerPackets;

  

implementation

// *****************************************************************************
//  procedure NMRABus_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Initialize;
begin
  NMRABus.State := 0;
  NMRABus.Interrupt_State := 0;
  GetUniqueIDFunc(NMRABus.Node_ID[1], NMRABus.Node_ID[0]);
  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Node_ID[0];
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Node_ID[1];
  NMRABusUtilities_CreateAliasID(False);
end;

// *****************************************************************************
//  function NMRABus_Connected
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRABus_Connected: Boolean;
begin
  Result := NMRABus.State and BS_PERMITED <> 0
end;

// *****************************************************************************
//  procedure NMRABus_GlobalTimer
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_GlobalTimer;
begin
  Inc(NMRABus.BusLoginCount);
end;

// *****************************************************************************
//  function NMRABus_Connect
//     Parameters:
//     Returns:
//
//     Description:  Returns True if all went well, False if the Alias is already
//                   used
//
// *****************************************************************************
function BusLogoutTimeout: Boolean;
begin
  Result := True;
  NMRABus.BusLoginCount := 0;
  while NMRABus.BusLoginCount < MAX_BUS_LOGIN_TIMEOUT do
  begin
    // The interrupt is looking for problems
  end;
end;

// *****************************************************************************
//  function NMRABus_Connect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Connect;
var
  Packet: TCANBuffer;
begin
  CANStorage_FlushList(Transmit_CANLayer_List);                                      // Flush any pending packets
  CANStorage_FlushList(Receive_CANLayer_List);
  while CANStorage_Transmitting do;                                             // Wait for the last transmited packet
  Delay_ms(10);
 { NMRABus_WaitForTransmitToFinish;                                              // Allow all pending CAN Controller messages to clear
  NMRABus.State := NMRABus.State and not BS_PERMITED;                           // Not permitted until we successfully get through this log in series
  

  if SendAndWaitForCheckIDPacket(FT_CID0) then
    if SendAndWaitForCheckIDPacket(FT_CID1) then
      if SendAndWaitForCheckIDPacket(FT_CID2) then
        if SendAndWaitForCheckIDPacket(FT_CID3) then                            // Queue up the Check ID Messages in the Transmit Buffer for the CAN Layer
          if BusLogoutTimeout then
            if SendAndWaitForCheckIDPacket(FT_AMD) then
            begin
              NMRABus.State := NMRABus.State or BS_PERMITED;
              NMRABusUtilities_CreateNMRABusMessagePacket(FT_INITIALIZATION_COMPLETE, 0, @Packet);
              CAN_Data_TxListAddNMRABusLayerThroughLockedList(@Packet);
              NMRABus_WaitForTransmitToStart;
              NMRABus_WaitForTransmitToFinish;
              NMRABus.State := NMRABus.State or BS_INITIALIZED;
            end;     }
end;


// *****************************************************************************
//  procedure NMRABus_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Disconnect;
begin
  NMRABus.State := NMRABus.State and not BS_PERMITED;
end;

// ****************************************************************************
// procedure HandleTransmitCompleteOnNMRALayerPacket
//
//  Description:
//
// ****************************************************************************
procedure HandleTransmitCompleteOnNMRALayerPacket;
var
  Packet: PCANBuffer;
begin
 { if CAN_Data_TxNextPacketNMRABusLayer(Packet) then
  begin
    NMRABus.Interrupt_State := NMRABus.Interrupt_State or BSI_TRANSMITTING_NMRABUS_LAYER;
    CANWriteTXBuffer(CAN_TX_1, Packet.Header, Packet.Count, Packet.Bytes, True, CAN_TX_PRIORITY_0);   // Yes, so move it into the CAN transmtter buffer, this also set the TXREQ flag to allow the transmission
  end else
    NMRABus.Interrupt_State := NMRABus.Interrupt_State and not BSI_TRANSMITTING_NMRABUS_LAYER;     }
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnNMRABusLayer
//
//  Description:
//                 All NMRABus Layer messages are low priority and placed in the List for
//     handling in the main message loop
//
// ****************************************************************************
procedure HandlePacketReceivedOnNMRABusLayer;
var
  Packet: TCANBuffer;
begin
{  CANReadRXBuffer(CAN_RX_1, Packet.Header, Packet.Count, Packet.Bytes, Packet.ExtendedID);         // Flags AutoReset
  if not CAN_Data_RxListAddNMRABusLayer(@Packet) then                                              // Queue the Packet into the circular recieve list
  begin
    // Buffer Overrun......
  end     }
end;

// ****************************************************************************
// procedure HandleTransmitCompleteOnCANLayerPacket
//
//  Description:
//
// ****************************************************************************
procedure HandleTransmitCompleteOnCANLayerPacket;
var
  Packet: TCANBuffer;
begin
 { if CAN_Data_TxNextPacketCANLayer(Packet) then                                 // Is there a CAN Level Packet in the list ready to be transmitted?
  begin
    NMRABus.Interrupt_State := NMRABus.Interrupt_State or BSI_TRANSMITTING_CAN_LAYER;
    CANWriteTXBuffer(CAN_TX_0, Packet.Header, Packet.Count, Packet.Bytes, True, CAN_TX_PRIORITY_1);   // Yes, so move it into the CAN transmtter buffer, this also set the TXREQ flag to allow the transmission, 52.25us
  end else
    NMRABus.Interrupt_State := NMRABus.Interrupt_State and not BSI_TRANSMITTING_CAN_LAYER; }
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnCANLayer
//
//  Description:
//                 All CAN Layer messages are high priority and are dealt with immediately
//
// ****************************************************************************
procedure HandlePacketReceivedOnCANLayer;
var
  RxPacket, TxPacket: TCANBuffer;
begin
 { CANReadRXBuffer(CAN_RX_0, RxPacket.Header, RxPacket.Count, RxPacket.Bytes, RxPacket.ExtendedID);

  if NMRABusUtilities_EqualAliasID(RxPacket.Header and $00000FFF) then                   // Is the Alias equal to ours?
  begin

    if RxPacket.Header and FT_CID_MASK <> 0 then                                // If it is a CID message then force node to try again for an Alias
    begin
      NMRABusUtilities_CreateCANControlFramePacket(FT_RID, @TxPacket);
      CAN_Data_TxListAddCANLayerThroughLockedList(@TxPacket);
    end else
    begin
      if NMRABus_Connected then                                                 // Detected a duplicate Alias, we need to shut down and restart with a fresh Alais ID
      begin
        CAN_Data_Flush_Lists;                                                   // Clear any queued packets
        NMRABus_Disconnect;                                                     // Take the node off line
        NMRABusUtilities_CreateCANControlFramePacket(FT_AMR, @TxPacket);                 // Send an Alias Map Reset
        CAN_Data_TxListAddCANLayerThroughLockedList(@TxPacket);
      end
    end
  end else
  begin
    CAN_Data_RxListAddCANLayer(@RxPacket);                                   // Low priority Packet queue and and handle it in the main loop
  end   }
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnCANLayer
//
//  Description:
//                 All CAN Layer messages are high priority and are dealt with immediately
//
// ****************************************************************************
procedure HandleCANError;
begin
  ERRIF_bit := 0;
  if NMRABus.State and BS_PERMITED = 0 then                                     // Only look during the time the node is attempting to log onto the bus (Inhibited) and become Permitted
  begin

  end
end;

// ****************************************************************************
// procedure HandleLoPriorityReceivedNMRABusLayerPackets
//
//  Description:
//                 All CAN Layer messages are high priority and are dealt with immediately
//
// ****************************************************************************
procedure HandleLoPriorityReceivedNMRABusLayerPackets;
var
  RxPacket, TxPacket: TCANBuffer;
begin
 { TxPacket.Header := 0;
  if CAN_Data_RxNextPacketNMRABusLayer(RxPacket) then
  begin
    TxPacket.Header := 0;
 //   EqualAliasIDTest(@RxPacket, @TxPacket);

    /// what to do here??????

    if RxPacket.Header and FT_VERIFY_NODE_ID_NUMBER_DEST = FT_VERIFY_NODE_ID_NUMBER_DEST then
    begin
    end
  end;   }
end;

// ****************************************************************************
// procedure HandleLoPriorityReceivedCANLayerPackets
//
//  Description:
//
//
// ****************************************************************************
procedure HandleLoPriorityReceivedCANLayerPackets;
var
  RxPacket, TxPacket: TCANBuffer;
  NodeID: TNodeID;
  SendPacket: Boolean;
begin
 { if CAN_Data_RxNextPacketCANLayer(RxPacket) then                               // Do we have a CAN received message waiting to be handled?
  begin
    if RxPacket.Header and FT_AMD = FT_AMD then                                 // Alias Map Definition Message
    begin
      NMRABusUtilities_PacketBytesToNodeID(@RxPacket, NodeID);
      if NMRABusUtilities_EqualNodeID(NodeID) then                                       // Is the 48 Bit node ID equal to ours?
      begin
        if NMRABus_Connected then
        begin
          // Send PCER Message with Duplicate Node ID Detected (Optional), Go Offline (Optional)
        end else
        begin
          // User Defined Action
        end
      end;
    end else
    if RxPacket.Header and FT_AME = FT_AME then                                // Alias Mapping Enquiry
    begin
      if NMRABus_Connected then
      begin
        SendPacket := True;
        if RxPacket.Count > 0 then
        begin
          NMRABusUtilities_PacketBytesToNodeID(@RxPacket, NodeID);
          SendPacket := NMRABusUtilities_EqualNodeID(NodeID)                             // Is the 48 Bit node ID equal to ours?
        end ;
        if SendPacket then
        begin
          NMRABusUtilities_CreateCANControlFramePacket(FT_AMD, @TxPacket);               // Send an Alias Map Definition
          CAN_Data_TxListAddCANLayerThroughLockedList(@TxPacket);
        end
      end
    end else
    if RxPacket.Header and FT_AMD = FT_AMD then                                // Alias Map Definition
    begin
      if RxPacket.Header and FT_AMD = FT_AMD then NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_AMD;
    end else
    if RxPacket.Header and FT_AMR = FT_AMR then                                // Alias Map Reset
    begin
      if RxPacket.Header and FT_AMR = FT_AMR then NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_AMD;
    end;

    if (TxPacket.Header <> 0) and (NMRABus.State and BSI_TRANSMITTING_CAN_LAYER = 0) then // If a CAN Packet is transmitting the Tx Done flag will be called anyway so we don't have to set this in that case
      SignalTransmitOnCANLayerFunc()                                                            // Set Transmit Done Flag to start the Transmit Engine
  end     }
end;

end.