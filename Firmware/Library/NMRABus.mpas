unit NMRABus;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRABus specifications
//
// ******************************************************************************


uses
  NMRABusDefines,
  NMRABusUtilities,
  CANStorage,
  CANDefines,
  NMRABusDatagrams,
  NMRABusDatagramDefines;

{$I Options.inc}

type
  TPacketHandlerFunc = procedure(CANBuffer: PCANBuffer; var DoDefault: Boolean);
  PPacketHandlerFunc = ^TPacketHandlerFunc;
  TDatagramPacketHandlerFunc = procedure(DatagramBuffer: PDatagramBuffer; var DoDefault: Boolean);
  PDatagramPacketHandlerFunc = ^TDatagramPacketHandlerFunc;
  TStreamPacketHandlerFunc = procedure(CANBuffer: PCANBuffer; var DoDefault: Boolean);
  PStreamPacketHandlerFunc = ^TStreamPacketHandlerFunc;


  procedure NMRABus_Connect;
  function NMRABus_Permitted: Boolean;
  procedure NMRABus_Disconnect;
  procedure NMRABus_Initialize;
  procedure NMRABus_GlobalTimer;
  procedure HandlePacketReceivedOnNMRABusLayer(NMRABusPacketHandler: PPacketHandlerFunc);
  procedure NMRABus_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);       // WARNING:  The Hook is called from within the Interrupt Handler.....


  // callbacks from the CAN interrupts used in the xxxxx_CAN_Interrupt.mpas units
  procedure ReceivedOnFilter0(Buffer: PCANBuffer);
  procedure ReceivedOnFilter1(Buffer: PCANBuffer);
  procedure ReceivedOnFilter2(Buffer: PCANBuffer);
  procedure ReceivedOnFilter3(Buffer: PCANBuffer);
  procedure ReceivedOnFilter4(Buffer: PCANBuffer);
  procedure ReceivedOnFilter5(Buffer: PCANBuffer);
  procedure ReceivedOnFilter6(Buffer: PCANBuffer);


  // defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;

  // defined in the user program
  procedure GetUniqueIDFunc(var HiID, LoID: DWord); external;
  
var
  RX_CANBufferList: TCANBufferList; external;
  TX_CANBufferList: TCANBufferList; external;
  RX_NMRAnetBufferList: TCANBufferList; external;
  TX_NMRAnetBufferList: TCANBufferList; external;


implementation

var
  CANLayerReceiveHook: PPacketHandlerFunc;

procedure NMRABus_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  CANLayerReceiveHook := HookFunc
end;

// *****************************************************************************
//  procedure FlushLists
//     Parameters:
//     Returns:
//
//     Description: Clears the lists
//
// *****************************************************************************
procedure FlushLists;
begin
  CANStorage_FlushList(@TX_CANBufferList);                                      // Flush any pending packets
  CANStorage_FlushList(@TX_NMRAnetBufferList);
  CANStorage_FlushList(@RX_CANBufferList);                                      // Flush any pending packets
  CANStorage_FlushList(@RX_NMRAnetBufferList);
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnCANLayer
//
//  Description:
//                 All CAN Layer messages are high priority and are dealt with immediately
//
// ****************************************************************************
procedure HandlePacketReceivedOnCANLayer;
var
  CANBuffer: TCANBuffer;
  NodeID: TNodeID;
  DoDefault: Boolean;
begin       
  while CANStorage_ExtractFromList(@RX_CANBufferList, CANBuffer) do                        // Pull all the Received Messages out (should be only one)
  begin
    DoDefault := True;
    if CANLayerReceiveHook <> nil then
      CANLayerReceiveHook(@CANBuffer, DoDefault);
    if DoDefault then
    begin
      if CANBuffer.ID and FT_AMD = FT_AMD then                                    // Alias Map Definition Message
      begin
        NMRABusUtilities_PacketBytesToNodeID(@CANBuffer, NodeID);
        if NMRABusUtilities_EqualNodeID(NodeID) then                              // Is the 48 Bit node ID equal to ours?
        begin                                                                     // Big error, there are duplicate 48 Bit ID on the bus
          if NMRABus_Permitted then
          begin
            // TODO
            // Send PCER Message with Duplicate Node ID Detected (Optional), Go Offline (Optional)
          end else
          begin
            // TODO
            // User Defined Action
          end
        end;
      end else
      if NMRABusUtilities_EqualAliasID(CANBuffer.ID and MASK_SOURCE_ALIAS) then           // Is the 12 Bit Alias equal to ours?
      begin
        if (CANBuffer.ID and FT_CID_MASK <= FT_CID0) and (CANBuffer.ID and FT_CID_MASK >= FT_CID6) then // If it is a CID message then force calling node to try again for an Alias this one is ours
        begin
          NMRABusUtilities_CreateCANControlFramePacket(FT_RID, @CANBuffer);
          CANStorage_AddToList(@TX_CANBufferList, CANBuffer);
          StartCANMessageEngine;
        end else
        begin
          if NMRABus_Permitted then                                               // Detected a duplicate Alias, we need to shut down and restart with a fresh Alais ID
          begin
            FlushLists();                                                         // Clear any queued packets
            NMRABus_Disconnect;                                                   // Take the node off line
            NMRABusUtilities_CreateCANControlFramePacket(FT_AMR, @CANBuffer);     // Send an Alias Map Reset
            CANStorage_AddToList(@TX_CANBufferList, CANBuffer);
            StartCANMessageEngine;
          end
        end
      end else
      begin
        if NMRABus_Permitted then
        begin
          if CANBuffer.ID and FT_AME = FT_AME then                                // Alias Mapping Enquiry
          begin
            if CANBuffer.DataCount > 0 then
            begin                                                                 // The Data contain a valid 48 Bit ID to compare with?
              NMRABusUtilities_PacketBytesToNodeID(@CANBuffer, NodeID);           // Extract the 48 Bit ID
              if NMRABusUtilities_EqualNodeID(NodeID) then
              begin                                                               // The 48 Bit node ID is equal to ours
                NMRABusUtilities_CreateCANControlFramePacket(FT_AMD, @CANBuffer); // Send an Alias Map Definition
                StartCANMessageEngine;
              end
            end else
            begin                                                                 // No Data so just send the AMD
              NMRABusUtilities_CreateCANControlFramePacket(FT_AMD, @CANBuffer);   // Send an Alias Map Definition
              StartCANMessageEngine;
            end
          end
        end
      end
    end
  end;
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnNMRABusLayer
//
//  Description:
//                 All NMRABus Layer messages are low priority and placed in the List for
//     handling in the main message loop
//
// ****************************************************************************
procedure HandlePacketReceivedOnNMRABusLayer(NMRABusPacketHandler: PPacketHandlerFunc);
var
  CANBuffer: TCANBuffer;
  DoDefault: Boolean;
begin
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #4; end; {$ENDIF}
  C1IE_bit := 0;
  if CANStorage_ExtractFromList(@RX_NMRAnetBufferList, CANBuffer) then                     // Pull next Received Messages out
  begin
    DoDefault := True;
    NMRABusPacketHandler(@CANBuffer, DoDefault);
    if DoDefault then
    begin
      if (CANBuffer.ID and FT_VERIFY_NODE_ID_NUMBER_DEST = FT_VERIFY_NODE_ID_NUMBER_DEST) and (CANBuffer.DataBytes[0] = SFT_VERIFY_NODE_DEST) then
      begin
        if NMRABusUtilities_EqualDestinationAlias(@CANBuffer) then
        begin
          NMRABusUtilities_CreateNMRABusMessagePacket(FT_VERIFIED_NODE_ID_NUMBER, 0, @CANBuffer);
          StartCANMessageEngine;
        end;
      end else
      if CANBuffer.ID and FT_VERIFY_NODE_ID_NUMBER_NO_DEST = FT_VERIFY_NODE_ID_NUMBER_NO_DEST then
      begin
        NMRABusUtilities_CreateNMRABusMessagePacket(FT_VERIFIED_NODE_ID_NUMBER, 0, @CANBuffer);
        StartCANMessageEngine;
      end
    end
  end;
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #4; end; {$ENDIF}
   C1IE_bit := 1;
end;

// *****************************************************************************
//  procedure ReceivedOnFilter0
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 0 which is defined
//                  as any CAN level message (bit 26 = 0)
//
// *****************************************************************************
procedure ReceivedOnFilter0(Buffer: PCANBuffer);
var
  Next: PCANBuffer;
begin
  Next := CANStorage_Head(@RX_CANBufferList);                                   // A little inefficient but keeps it consistent, move the message in to the buffer
  if Next <> nil then
  begin
    Next^ := Buffer^;
    CANStorage_IncHead(@RX_CANBufferList);
    HandlePacketReceivedOnCANLayer                                              // On the CAN Layer the messages are dealt with in real time
  end else
  begin
      // Have overrun problem
  end;
end;

// *****************************************************************************
//  procedure ReceivedOnFilter1
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 1 which is defined
//                  as any NMRABus level message (bit 26 = 1)
//
// *****************************************************************************
procedure ReceivedOnFilter1(Buffer: PCANBuffer);
var
  Next: PCANBuffer;
begin
  Next := CANStorage_Head(@RX_NMRAnetBufferList);
  if Next <> nil then
  begin
    Next^ := Buffer^;
    CANStorage_IncHead(@RX_NMRAnetBufferList);
  end else
  begin
      // Have overrun problem
  end;
end;

// *****************************************************************************
//  procedure ReceivedOnFilter2
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 2
//
// *****************************************************************************
procedure ReceivedOnFilter2(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter3
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 3
//
// *****************************************************************************
procedure ReceivedOnFilter3(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter4
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 4
//
// *****************************************************************************
procedure ReceivedOnFilter4(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter5
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 5
//
// *****************************************************************************
procedure ReceivedOnFilter5(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter6
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 6
//
// *****************************************************************************
procedure ReceivedOnFilter6(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure NMRABus_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the BufferArray
//              LasterBuffer   : Pointer to the last item in the BufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure NMRABus_InitializeList(ListPtr: PCANBufferList; BufferArrayPtr: PCANBufferArray; ListLength: Byte);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.Size := ListLength;
  ListPtr^.Head := @BufferArrayPtr^[0];
  ListPtr^.Tail := @BufferArrayPtr^[0];
  ListPtr^.Count := 0;
  ListPtr^.MaxCount := 0;
end;

// *****************************************************************************
//  procedure NMRABus_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Initialize;
begin
  NMRABus.State := 0;
  NMRABus.Interrupt_State := 0;
  GetUniqueIDFunc(NMRABus.Node_ID[1], NMRABus.Node_ID[0]);
  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Node_ID[0];
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Node_ID[1];
  NMRABusUtilities_CreateAliasID(False);
  CANLayerReceiveHook := PPacketHandlerFunc( nil);
  NMRABus_InitializeList(@RX_CANBufferList, @RX_CANBuffer, RX_CAN_BUFFER_LEN);
  NMRABus_InitializeList(@TX_CANBufferList, @TX_CANBuffer, TX_CAN_BUFFER_LEN);
  NMRABus_InitializeList(@RX_NMRAnetBufferList, @RX_NMRAnet_Buffer, RX_NMRANET_BUFFER_LEN);
  NMRABus_InitializeList(@TX_NMRAnetBufferList, @TX_NMRAnet_Buffer, RX_NMRANET_BUFFER_LEN);
  NMRABusDatagrams_Initialize;
end;

// *****************************************************************************
//  function NMRABus_Permitted
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRABus_Permitted: Boolean;
begin
  Result := NMRABus.State and BS_PERMITED <> 0
end;

// *****************************************************************************
//  procedure NMRABus_GlobalTimer
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_GlobalTimer;
begin
  Inc(NMRABus.BusLoginCount);
end;

// *****************************************************************************
//  function NMRABus_Connect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Connect;
var
  Buffer: TCANBuffer;
  DuplicateCID: Boolean;
begin
  FlushLists;
  while CANStorage_Transmitting do;                                             // Wait for the last transmited packet
  Delay_ms(10);
  NMRABusUtilities_CreateCANControlFramePacket(FT_CID0, @Buffer);               // Queue up
  CANStorage_AddToList(@TX_CANBufferList, Buffer);
  NMRABusUtilities_CreateCANControlFramePacket(FT_CID1, @Buffer);
  CANStorage_AddToList(@TX_CANBufferList, Buffer);
  NMRABusUtilities_CreateCANControlFramePacket(FT_CID2, @Buffer);
  CANStorage_AddToList(@TX_CANBufferList, Buffer);
  NMRABusUtilities_CreateCANControlFramePacket(FT_CID3, @Buffer);
  CANStorage_AddToList(@TX_CANBufferList, Buffer);
  StartCANMessageEngine();
  DuplicateCID := False;
  while CANStorage_Transmitting and not DuplicateCID do
  begin
    if CANStorage_ExtractFromList(@RX_CANBufferList, Buffer) then
      DuplicateCID := NMRABusUtilities_EqualAliasID(Buffer.ID and $00000FFF) and (Buffer.ID and FT_RID = FT_RID);
  end;
  if not DuplicateCID then
  begin
    NMRABus.BusLoginCount := 0;
    while NMRABus.BusLoginCount < MAX_BUS_LOGIN_TIMEOUT do
    begin
      if CANStorage_ExtractFromList(@RX_CANBufferList, Buffer) then
        DuplicateCID := NMRABusUtilities_EqualAliasID(Buffer.ID and $00000FFF) and (Buffer.ID and FT_RID = FT_RID);
    end;
    
    if not DuplicateCID then
    begin
      NMRABus.State := NMRABus.State or BS_PERMITED;
      NMRABusUtilities_CreateCANControlFramePacket(FT_AMD, @Buffer);
      CANStorage_AddToList(@TX_CANBufferList, Buffer);
      NMRABusUtilities_CreateNMRABusMessagePacket(FT_INITIALIZATION_COMPLETE, 0, @Buffer);
      CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer);
      StartCANMessageEngine();
      while CANStorage_Transmitting do;                                         // Just wait
      NMRABus.State := NMRABus.State or BS_INITIALIZED;
    end;
  end;
end;


// *****************************************************************************
//  procedure NMRABus_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Disconnect;
begin
  NMRABus.State := NMRABus.State and not BS_PERMITED;
end;

end.