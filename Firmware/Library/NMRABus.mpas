// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRABus specifications
//
// ******************************************************************************
unit NMRABus;

uses
  CAN_Data;
  
{$I Options.inc}

const
  MAX_BUS_LOGIN_TIMEOUT = 51;              // Number of 1ms time tick to wait for a node to send a RID to signal a duplicate Alais
  
  CAN_TX_0 = 0;
  CAN_TX_1 = 1;
  CAN_TX_2 = 2;

  CAN_RX_0 = 0;
  CAN_RX_1 = 1;

  CAN_TX_PRIORITY_0 = 0;
  CAN_TX_PRIORITY_1 = 1;
  CAN_TX_PRIORITY_2 = 2;
  CAN_TX_PRIORITY_3 = 3;

// *****************************************************************************
//  Extended CAN Frames
//  29 Bits Divided as follows:
//     - 1 Bit = Priority (1 = Low Priority typical)
//     - 4 Bits = Frame Type (FT_xxxx Constants)
//     - 12 Bits = Destination Node Address Alias or Message Type (MT_xxx Constants)
//     - 12 Bits = Source Node Address Alias
//
// Frame Types.  These define what the Frame of the CAN message consists of.
const
  FT_CAN                            = $00000000;  // Frame Type CAN Control Message
  FT_CID0                           = $07000000;  // First 12 Bits of 48 bit Node ID
  FT_CID1                           = $06000000;  // 2rd 12 Bits of 48 bit Node ID
  FT_CID2                           = $05000000;  // 3nd 12 Bits of 48 bit Node ID
  FT_CID3                           = $04000000;  // Last 12 Bits of 48 bit Node ID
  FT_CID_MASK                       = $07000000;
  FT_RID                            = $00700000;  // Reserve ID
  FT_AMD                            = $00701000;  // Alias Map Definition
  FT_AME                            = $00702000;  // Alias Mapping Enquiry
  FT_AMR                            = $00703000;  // Alias Map Reset Frame
  
  
  FT_INITIALIZATION_COMPLETE        = $09017000;
  FT_VERIFY_NODE_ID_NUMBER_DEST     = $0E000000;
  FT_VERIFY_NODE_ID_NUMBER_NO_DEST  = $080A7000;
  FT_VERIFIED_NODE_ID_NUMBER        = $080B7000;
  FT_OPTIONAL_INTERACTION_REJECTED  = $0E000000;
  FT_TERMINATE_DUE_TO_ERROR         = $0E000000;

  FT_BROADCAST_1     = $08;  // Broadcast Message
  FT_BROADCAST_2     = $09;  // Broadcast Message again....
  FT_DATAGRAM_FIRST  = $0C;  // First Frame of Datagram
  FT_DATAGRAM_LAST   = $0D;  // Last Frame of Datagram
  FT_DATAGRAM_SINGLE = $0E;  // Single Frame Datagram
  FT_STREAM          = $0F;  // Stream Data
  
  // NMRABus States
  BS_PERMITED          = $01;    // CAN Frame Layer is permitted (Node ID's resolved with bus)
  BS_INITIALIZED       = $02;    // Message Layer has sent its first Initialize Complete Message

  BSI_TRANSMITTING_CAN_LAYER      = $01;     // The CAN Transmit engine is placing a CAN Layer packet on the Bus
  BSI_TRANSMITTING_NMRABUS_LAYER  = $02;     // The CAN Transmit engine is placing a NRMABus Layer packet on the Bus
  BSI_TRANSMITTING_ANY_LAYER      =  BSI_TRANSMITTING_CAN_LAYER or BSI_TRANSMITTING_NMRABUS_LAYER;
  
  BRM_CID0                        = $0001;   // Received a Check ID Frame with the Most Significant Bits (Variable Field= 7)
  BRM_CID1                        = $0002;   // Received a Check ID Frame with the Most Significant Bits (Variable Field= 7)
  BRM_CID2                        = $0004;   // Received a Check ID Frame with the Most Significant Bits (Variable Field= 7)
  BRM_CID3                        = $0008;   // Received a Check ID Frame with the Most Significant Bits (Variable Field= 7)
  BRM_RID                         = $0010;   // Received a Reserve ID Frame
  BRM_AMD                         = $0020;   // Received a Alias Map Definition Frame
  BRM_AME                         = $0040;   // Received a Alias Mapping Enquiry Frame
  BRM_AMR                         = $0080;   // Received a Alias Map Reset Frame

type
  TNodeID = array[0..1] of DWORD;    // The Bottom 3 Bytes = [0] and the Top 3 Bytes = [1]
  TNodeAliasID = Word;
  

  TNMRABus = record
    Node_ID: TNodeID;                // Unique 48 Bit ID for Node
    Unique_ID_Global_Seed: TNodeID;  // Seed for Random Number Generator in case we have to reseed because of a duplicate ID
    Node_Alias_ID: TNodeAliasID;     // 12 Bit Alias ID
    BusLoginCount: Integer;          // Increment through the Global Timer to time out when the Spec for waiting for other nodes to send the RID for a duplicate Alias ID
    State: Word;                     // See the BS_xxxx flags; State of the Bus; these are ONLY CHANGED OUTSIDE OF an interrupt and concedered READ-ONLY inside of an interrupt
    Interrupt_State: Byte;           // See the BSI_xxxx flags; State of the Bus Messaging System that is running through the interrupts, these are ONLY CHANGED FROM WITHIN the interrupt and concidered READ-ONLY outside of the interrupt
    ReceivedMessages: Word;          // Allows tracking what messages have been received.  Use the BRM_xxxx flags.  The user may clear these states and wait until it is set but be aware they may set in the interrupts
  end;
  
  TGetUniqueIDFunc = procedure(var Hi, Lo: DWord);
  PGetUniqueIDFunc = ^TGetUniqueIDFunc;


var
  NMRABus: TNMRABus;
  
  GetUniqueID: PGetUniqueIDFunc; external;

  procedure NMRABus_Connect;
  function NMRABus_Connected: Boolean;
  procedure NMRABus_Disconnect;
  procedure NMRABus_Initialize;
  procedure NMRABus_GlobalTimer;
  procedure NMRABus_RecreateAliasID;
  function NMRABus_EqualAliasID(AliasID: Word): Boolean;
  procedure NMRABus_CreateCANControlFramePacket(VariableField: DWord; Packet: PCAN_Packet);
  function NMRABus_EqualNodeID(var NodeID: TNodeID): boolean;
  procedure NMRABus_PacketBytesToNodeID(Packet: PCAN_Packet; var NodeID: TNodeID);
  procedure NMRABus_WaitForTransmitToFinish;
  procedure NMRABus_WaitForTransmitToStart;
  
  procedure HandleTransmitCompleteOnNMRALayerPacket;
  procedure HandlePacketReceivedOnNMRABusLayer;
  procedure HandleTransmitCompleteOnCANLayerPacket;
  procedure HandlePacketReceivedOnCANLayer;
  procedure HandleCANError;
  procedure CANReadRXBuffer(Buffer: Byte; var ID: DWord; var DataCount: Byte; var DataBytes: TCANData; var IsExtended: Boolean);
  procedure CANWriteTXBuffer(Buffer: Byte; ID: DWord; DataCount: Byte; var DataBytes: TCANData; IsExtended: Boolean; Priority: Byte);
  procedure HandleLoPriorityReceivedNMRABusLayerPackets;
  procedure HandleLoPriorityReceivedCANLayerPackets;

  

implementation

// *****************************************************************************
//  function NMRABus_PacketBytesToNodeID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_PacketBytesToNodeID(Packet: PCAN_Packet; var NodeID: TNodeID);
begin
  NodeID[0] := Packet^.Bytes[0];
  NodeID[0] := NodeID[0] or Packet^.Bytes[1] shl 8;
  NodeID[0] := NodeID[0] or Packet^.Bytes[2] shl 16;
  NodeID[1] := Packet^.Bytes[3];
  NodeID[1] := NodeID[1] or Packet^.Bytes[4] shl 8;
  NodeID[1] := NodeID[1] or Packet^.Bytes[5] shl 16;
end;

// *****************************************************************************
//  function NMRABus_EqualAliasID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRABus_EqualNodeID(var NodeID: TNodeID): boolean;
begin
  Result := (NodeID[1] = NMRABus.Node_ID[1]) and (NodeID[0] = NMRABus.Node_ID[0])
end;

// *****************************************************************************
//  function NMRABus_EqualAliasID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRABus_EqualAliasID(AliasID: Word): Boolean;
begin
  Result := AliasID = NMRABus.Node_Alias_ID
end;

// *****************************************************************************
//  procedure LoadNodeID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_LoadNodeID(var NodeID: TNodeID; Upper, Lower: DWORD);
begin
  NodeID[0] := Lower;
  NodeID[1] := Upper;
end;

// *****************************************************************************
//  procedure PsudoRandomNumberGenerator
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_PsudoRandomNumberGenerator;
var
  temp1,              // Upper 24 Bits of temp 48 bit number
  temp2: DWORD;       // Lower 24 Bits of temp 48 Bit number
begin
  temp1 := ((NMRABus.Unique_ID_Global_Seed[1] shl 9) or ((NMRABus.Unique_ID_Global_Seed[0] shr 15) and $000001FF)) and $00FFFFFF;   // x(i+1)(2^9 + 1)*x(i) + C  = 2^9 * x(i) + x(i) + C
  temp2 := (NMRABus.Unique_ID_Global_Seed[0] shl 9) and $00FFFFFF;                                                                  // Calculate 2^9 * x
  
  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Unique_ID_Global_Seed[0] + temp2 + $7A4BA9;   // Now y = 2^9 * x so all we have left is x(i+1) = y + x + c
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Unique_ID_Global_Seed[1] + temp1 + $1B0CA3;

  NMRABus.Unique_ID_Global_Seed[1] := (NMRABus.Unique_ID_Global_Seed[1] and $00FFFFFF) or (NMRABus.Unique_ID_Global_Seed[0] and $FF000000) shr 24;   // Handle the carries of the lower 24 bits into the upper
  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Unique_ID_Global_Seed[0] and $00FFFFFF;
end;

// *****************************************************************************
//  function NMRABus_GenerateID_Alias_From_Global_Seed
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRABus_GenerateID_Alias_From_Global_Seed: Word;
begin
  Result := (NMRABus.Unique_ID_Global_Seed[0] xor NMRABus.Unique_ID_Global_Seed[1] xor (NMRABus.Unique_ID_Global_Seed[0] shr 12) xor (NMRABus.Unique_ID_Global_Seed[1] shr 12)) and $00000FFF;
end;

// *****************************************************************************
//  procedure CreateAliasID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_CreateAliasID(Regenerate: Boolean);
begin
  if Regenerate then
    NMRABus_PsudoRandomNumberGenerator;
  NMRABus.Node_Alias_ID := NMRABus_GenerateID_Alias_From_Global_Seed;
  if NMRABus.Node_Alias_ID = 0 then
  begin
    NMRABus_PsudoRandomNumberGenerator;
    NMRABus.Node_Alias_ID := NMRABus_GenerateID_Alias_From_Global_Seed;
  end
end;

// *****************************************************************************
//  procedure NMRABus_RecreateAliasID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_RecreateAliasID;
begin
  NMRABus_CreateAliasID(True)
end;

// *****************************************************************************
//  procedure NMRABus_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Initialize;
begin
  NMRABus.State := 0;
  NMRABus.Interrupt_State := 0;
  NMRABus.ReceivedMessages := 0;
  GetUniqueID(NMRABus.Node_ID[1], NMRABus.Node_ID[0]);
  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Node_ID[0];
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Node_ID[1];

  NMRABus_CreateAliasID(False);
end;

// *****************************************************************************
//  function NMRABus_Connected
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRABus_Connected: Boolean;
begin
  Result := NMRABus.State and BS_PERMITED <> 0
end;

// *****************************************************************************
//  procedure NMRABus_GlobalTimer
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_GlobalTimer;
begin
  Inc(NMRABus.BusLoginCount);
end;

// *****************************************************************************
//  procedure NMRABus_LoadFramePacketDataWith48BitNodeID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_LoadFramePacketDataWith48BitNodeID(Packet: PCAN_Packet);
begin
  Packet^.Count := 6;
  Packet^.Bytes[0] := NMRABus.Node_ID[1] shr 16;  // But these all need the 48 Bit Full ID in the Byte Fields
  Packet^.Bytes[1] := NMRABus.Node_ID[1] shr 8;
  Packet^.Bytes[2] := NMRABus.Node_ID[1];
  Packet^.Bytes[3] := NMRABus.Node_ID[0] shr 16;
  Packet^.Bytes[4] := NMRABus.Node_ID[0] shr 8;
  Packet^.Bytes[5] := NMRABus.Node_ID[0];
end;

// *****************************************************************************
//  procedure NMRABus_CreateCANControlFramePacket
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_CreateCANControlFramePacket(VariableField: DWord; Packet: PCAN_Packet);
begin
  Packet^.Count := 0;
  Packet^.ExtendedID := True;
  Packet^.Header := $10000000 or VariableField or NMRABus.Node_Alias_ID;  // RID, AMD, AME, AMR are all covered with the Reserved bit, Variable Field value and Source Node Alias
  if VariableField = FT_CID0 then Packet^.Header := Packet^.Header or (NMRABus.Node_ID[1] and $00FFF000) else
  if VariableField = FT_CID1 then Packet^.Header := Packet^.Header or ((NMRABus.Node_ID[1] shl 12) and $00FFF000) else
  if VariableField = FT_CID2 then Packet^.Header := Packet^.Header or (NMRABus.Node_ID[0] and $00FFF000) else
  if VariableField = FT_CID3 then Packet^.Header := Packet^.Header or ((NMRABus.Node_ID[0] shl 12) and $00FFF000);
  
  if (VariableField = FT_AMD) or (VariableField = FT_AME) or (VariableField = FT_AMR) then
    NMRABus_LoadFramePacketDataWith48BitNodeID(Packet);
end;

// *****************************************************************************
//  procedure NMRABus_CreateNMRABusMessagePacket
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_CreateNMRABusMessagePacket(VariableField: DWord; DestinationAliasID: DWord; Packet: PCAN_Packet);
begin
  Packet^.Count := 0;
  Packet^.ExtendedID := True;
  if DestinationAliasID <> 0 then Packet^.Header := Packet^.Header or (DestinationAliasID shl 12);
  Packet^.Header := $10000000 or VariableField or NMRABus.Node_Alias_ID;
  
  if (VariableField = FT_INITIALIZATION_COMPLETE) or (VariableField = FT_VERIFIED_NODE_ID_NUMBER) then
    NMRABus_LoadFramePacketDataWith48BitNodeID(Packet);
end;


// *****************************************************************************
//  procedure NMRABus_WaitForTransmitToFinish
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_WaitForTransmitToFinish;
begin
  while NMRABus.Interrupt_State and BSI_TRANSMITTING_ANY_LAYER <> 0 do;
end;

// *****************************************************************************
//  procedure NMRABus_WaitForTransmitToFinish
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_WaitForTransmitToStart;
begin
  while NMRABus.Interrupt_State and BSI_TRANSMITTING_ANY_LAYER = 0 do;
end;

// *****************************************************************************
//  function SendAndWaitForCheckIDPacket
//     Parameters:
//     Returns:
//
//     Description:  Returns True if all went well, False if the Alias is already
//                   used
//
// *****************************************************************************
function SendAndWaitForCheckIDPacket(MessageType: DWord): Boolean;
var
  Packet: TCAN_Packet;
begin
  Result := True;
  NMRABus_CreateCANControlFramePacket(MessageType, @Packet);                    // Load the high priority transmitter buffer = 14us
  CAN_Data_TxListAddCANLayerThroughLockedList(@Packet);                         // 150us
  NMRABus_WaitForTransmitToStart;
  NMRABus_WaitForTransmitToFinish;
  Result := NMRABus.ReceivedMessages and BRM_RID = 0;                           // Set in the CAN Rx Interrupt
end;

// *****************************************************************************
//  function NMRABus_Connect
//     Parameters:
//     Returns:
//
//     Description:  Returns True if all went well, False if the Alias is already
//                   used
//
// *****************************************************************************
function BusLogoutTimeout: Boolean;
begin
  Result := True;
  NMRABus.BusLoginCount := 0;
  while NMRABus.BusLoginCount < MAX_BUS_LOGIN_TIMEOUT do
  begin
    // The interrupt is looking for problems
  end;
  Result := NMRABus.ReceivedMessages and BRM_RID = 0;                           // Set in the CAN Rx Interrupt
end;

// *****************************************************************************
//  function NMRABus_Connect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Connect;
var
  Packet: TCAN_Packet;
begin
  CAN_Data_Flush_Lists;                                                         // Flush any pending packets
  Delay_ms(10);
  NMRABus_WaitForTransmitToFinish;                                              // Allow all pending CAN Controller messages to clear
  NMRABus.State := NMRABus.State and not BS_PERMITED;                           // Not permitted until we successfully get through this log in series
  NMRABus.ReceivedMessages := NMRABus.ReceivedMessages and not BRM_RID;         // Clear the Reserve ID Flag so we can monitor it to see if we get a reply to our login
  if SendAndWaitForCheckIDPacket(FT_CID0) then
    if SendAndWaitForCheckIDPacket(FT_CID1) then
      if SendAndWaitForCheckIDPacket(FT_CID2) then
        if SendAndWaitForCheckIDPacket(FT_CID3) then                            // Queue up the Check ID Messages in the Transmit Buffer for the CAN Layer
          if BusLogoutTimeout then
            if SendAndWaitForCheckIDPacket(FT_AMD) then
            begin
              NMRABus.State := NMRABus.State or BS_PERMITED;
              NMRABus_CreateNMRABusMessagePacket(FT_INITIALIZATION_COMPLETE, 0, @Packet);
              CAN_Data_TxListAddNMRABusLayerThroughLockedList(@Packet);
              NMRABus_WaitForTransmitToStart;
              NMRABus_WaitForTransmitToFinish;
              NMRABus.State := NMRABus.State or BS_INITIALIZED;
            end;
end;


// *****************************************************************************
//  procedure NMRABus_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Disconnect;
begin
  NMRABus.State := NMRABus.State and not BS_PERMITED;
end;

// ****************************************************************************
// procedure HandleTransmitCompleteOnNMRALayerPacket
//
//  Description:
//
// ****************************************************************************
procedure HandleTransmitCompleteOnNMRALayerPacket;
var
  Packet: TCAN_Packet;
begin
  TXB1IF_bit := 0;                                                              // Clear Transmitter Interrupt Flag
  if CAN_Data_TxNextPacketNMRABusLayer(Packet) then
  begin
    NMRABus.Interrupt_State := NMRABus.Interrupt_State or BSI_TRANSMITTING_NMRABUS_LAYER;
    CANWriteTXBuffer(CAN_TX_1, Packet.Header, Packet.Count, Packet.Bytes, True, CAN_TX_PRIORITY_0);   // Yes, so move it into the CAN transmtter buffer, this also set the TXREQ flag to allow the transmission
  end else
    NMRABus.Interrupt_State := NMRABus.Interrupt_State and not BSI_TRANSMITTING_NMRABUS_LAYER;
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnNMRABusLayer
//
//  Description:
//                 All NMRABus Layer messages are low priority and placed in the List for
//     handling in the main message loop
//
// ****************************************************************************
procedure HandlePacketReceivedOnNMRABusLayer;
var
  Packet: TCAN_Packet;
begin
  RXB1IF_bit := 0;
  CANReadRXBuffer(CAN_RX_1, Packet.Header, Packet.Count, Packet.Bytes, Packet.ExtendedID);         // Flags AutoReset
  if not CAN_Data_RxListAddNMRABusLayer(@Packet) then                                              // Queue the Packet into the circular recieve list
  begin
    // Buffer Overrun......
  end
end;

// ****************************************************************************
// procedure HandleTransmitCompleteOnCANLayerPacket
//
//  Description:
//
// ****************************************************************************
procedure HandleTransmitCompleteOnCANLayerPacket;
var
  Packet: TCAN_Packet;
begin
  TXB0IF_bit := 0;                                                              // Clear Transmitter Interrupt Flag
  if CAN_Data_TxNextPacketCANLayer(Packet) then                                 // Is there a CAN Level Packet in the list ready to be transmitted?
  begin
    NMRABus.Interrupt_State := NMRABus.Interrupt_State or BSI_TRANSMITTING_CAN_LAYER;
    CANWriteTXBuffer(CAN_TX_0, Packet.Header, Packet.Count, Packet.Bytes, True, CAN_TX_PRIORITY_1);   // Yes, so move it into the CAN transmtter buffer, this also set the TXREQ flag to allow the transmission, 52.25us
  end else
    NMRABus.Interrupt_State := NMRABus.Interrupt_State and not BSI_TRANSMITTING_CAN_LAYER;
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnCANLayer
//
//  Description:
//                 All CAN Layer messages are high priority and are dealt with immediately
//
// ****************************************************************************
procedure HandlePacketReceivedOnCANLayer;
var
  RxPacket, TxPacket: TCAN_Packet;
begin
  RXB0IF_bit := 0;
  CANReadRXBuffer(CAN_RX_0, RxPacket.Header, RxPacket.Count, RxPacket.Bytes, RxPacket.ExtendedID);

  if NMRABus_EqualAliasID(RxPacket.Header and $00000FFF) then                   // Is the Alias equal to ours?
  begin
    if RxPacket.Header and FT_RID = FT_RID then                                 // Reserve ID
      NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_RID;

    if RxPacket.Header and FT_CID_MASK <> 0 then                                // If it is a CID message then force node to try again for an Alias
    begin
      if RxPacket.Header and FT_CID0 = FT_CID0 then NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_CID0;
      if RxPacket.Header and FT_CID1 = FT_CID1 then NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_CID1;
      if RxPacket.Header and FT_CID2 = FT_CID2 then NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_CID2;
      if RxPacket.Header and FT_CID3 = FT_CID3 then NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_CID3;
      NMRABus_CreateCANControlFramePacket(FT_RID, @TxPacket);
      CAN_Data_TxListAddCANLayerThroughLockedList(@TxPacket);
    end else
    begin
      if NMRABus_Connected then                                                 // Detected a duplicate Alias, we need to shut down and restart with a fresh Alais ID
      begin
        CAN_Data_Flush_Lists;                                                   // Clear any queued packets
        NMRABus_Disconnect;                                                     // Take the node off line
        NMRABus_CreateCANControlFramePacket(FT_AMR, @TxPacket);                 // Send an Alias Map Reset
        CAN_Data_TxListAddCANLayerThroughLockedList(@TxPacket);
      end
    end
  end else
  begin
    CAN_Data_RxListAddCANLayer(@RxPacket);                                   // Low priority Packet queue and and handle it in the main loop
  end
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnCANLayer
//
//  Description:
//                 All CAN Layer messages are high priority and are dealt with immediately
//
// ****************************************************************************
procedure HandleCANError;
begin
  ERRIF_bit := 0;
  if NMRABus.State and BS_PERMITED = 0 then                                     // Only look during the time the node is attempting to log onto the bus (Inhibited) and become Permitted
  begin

  end
end;

// ****************************************************************************
// procedure HandleLoPriorityReceivedNMRABusLayerPackets
//
//  Description:
//                 All CAN Layer messages are high priority and are dealt with immediately
//
// ****************************************************************************
procedure HandleLoPriorityReceivedNMRABusLayerPackets;
var
  RxPacket, TxPacket: TCAN_Packet;
begin
  TxPacket.Header := 0;
  if CAN_Data_RxNextPacketNMRABusLayer(RxPacket) then
  begin
    TxPacket.Header := 0;
 //   EqualAliasIDTest(@RxPacket, @TxPacket);

    /// what to do here??????

    if RxPacket.Header and FT_VERIFY_NODE_ID_NUMBER_DEST = FT_VERIFY_NODE_ID_NUMBER_DEST then
    begin
    end
  end;
end;

// ****************************************************************************
// procedure HandleLoPriorityReceivedCANLayerPackets
//
//  Description:
//
//
// ****************************************************************************
procedure HandleLoPriorityReceivedCANLayerPackets;
var
  RxPacket, TxPacket: TCAN_Packet;
  NodeID: TNodeID;
  SendPacket: Boolean;
begin
  TxPacket.Header := 0;
  if CAN_Data_RxNextPacketCANLayer(RxPacket) then                               // Do we have a CAN received message waiting to be handled?
  begin
    if RxPacket.Header and FT_AMD = FT_AMD then                                 // Alias Map Definition Message
    begin
      if RxPacket.Header and FT_RID = FT_RID then NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_RID;
      NMRABus_PacketBytesToNodeID(@RxPacket, NodeID);
      if NMRABus_EqualNodeID(NodeID) then                                       // Is the 48 Bit node ID equal to ours?
      begin
        if NMRABus_Connected then
        begin
          // Send PCER Message with Duplicate Node ID Detected (Optional), Go Offline (Optional)
        end else
        begin
          // User Defined Action
        end
      end;
    end else
    if RxPacket.Header and FT_AME = FT_AME then                                // Alias Mapping Enquiry
    begin
      if NMRABus_Connected then
      begin
        if RxPacket.Header and FT_AME = FT_AME then NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_AME;
        SendPacket := True;
        if RxPacket.Count > 0 then
        begin
          NMRABus_PacketBytesToNodeID(@RxPacket, NodeID);
          SendPacket := NMRABus_EqualNodeID(NodeID)                             // Is the 48 Bit node ID equal to ours?
        end ;
        if SendPacket then
        begin
          NMRABus_CreateCANControlFramePacket(FT_AMD, @TxPacket);               // Send an Alias Map Definition
          CAN_Data_TxListAddCANLayerThroughLockedList(@TxPacket);
        end
      end
    end else
    if RxPacket.Header and FT_AMD = FT_AMD then                                // Alias Map Definition
    begin
      if RxPacket.Header and FT_AMD = FT_AMD then NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_AMD;
    end else
    if RxPacket.Header and FT_AMR = FT_AMR then                                // Alias Map Reset
    begin
      if RxPacket.Header and FT_AMR = FT_AMR then NMRABus.ReceivedMessages := NMRABus.ReceivedMessages or BRM_AMD;
    end;

    if (TxPacket.Header <> 0) and (NMRABus.State and BSI_TRANSMITTING_CAN_LAYER = 0) then // If a CAN Packet is transmitting the Tx Done flag will be called anyway so we don't have to set this in that case
      TXB0IF_bit := 1;                                                          // Set Transmit Done Flag to start the Transmit Engine
  end
end;

// ****************************************************************************
// procedure CANReadRXBuffer
//
// parameters:
//     Buffer:        TX Buffer to use.  See CAN_RX_n constants
//     Header:        The SID and EID for the CAN header
//     DataCount:     Number of Data Bytes
//     DataBytes:     Bytes to send
//     IsExtended:    If the Header is a Standard or Extended
//
//  Description:  16us
//
// ****************************************************************************
procedure CANReadRXBuffer(Buffer: Byte; var Header: DWord; var DataCount: Byte; var DataBytes: TCANData; var IsExtended: Boolean);
var
  CANPtr: ^Word;
  SID, EID: DWORD;
begin
  case Buffer of
    0: CANPtr := @C1RX0SID;
    1: CANPtr := @C1RX1SID;
  end;
  SID := ((DWORD( CANPtr^ shr 2)) and $000007FF);                               // Get the Standard ID
  IsExtended := CANPtr^ and $0001 <> 0;
  Inc(CANPtr);                                                                  // Move to the RXnEID Register
  if IsExtended then
  begin
    EID := ((DWORD( CANPtr^) shl 6) and $0003FFC0);                             // Pull out the info from the RXnEID
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
    EID := EID or (DWORD( CANPtr^) shr 10);                                     // Pull out the rest of the Extended ID
  end else
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
  Header := (SID shl 18) or EID;                                                // Build the EID
  DataCount := CANPtr^ and $000F;
  Inc(CANPtr);                                                                  // Move to C1RXnB1
  DataBytes[0] := CANPtr^;
  DataBytes[1] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnB2
  DataBytes[2] := CANPtr^;
  DataBytes[3] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnB3
  DataBytes[4] := CANPtr^;
  DataBytes[5] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnB4
  DataBytes[6] := CANPtr^;
  DataBytes[7] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnCON
  CANPtr^ := CANPtr^ and $FF7F;                                                 // Clear the RXFUL flag
end;

// ****************************************************************************
// procedure CANWriteTXBuffer
//
// parameters:
//     Buffer:        TX Buffer to use.  See CAN_TX_n constants
//     Header:        The SID and EID for the CAN header
//     DataCount:     Number of Data Bytes
//     DataBytes:     Bytes to send
//     IsExtended:    If the Header is a Standard or Extended
//     Priority:      Transmit Priority.  See CAN_TX_PRIORITY_n constants
//
//  Description:  16us
//
// ****************************************************************************
procedure CANWriteTXBuffer(Buffer: Byte; Header: DWord; DataCount: Byte; var DataBytes: TCANData; IsExtended: Boolean; Priority: Byte);
var
  CANPtr: ^Word;
  SID, EID: DWORD;
begin
  SID := (Header and $1FFC0000) shr 18;
  EID := Header and $0003FFFF;

  case Buffer of
    0: CANPtr := @C1TX0SID;
    1: CANPtr := @C1TX1SID;
    2: CANPtr := @C1TX2SID;
  end;
  CANPtr^ := ((SID shl 2) and $00FC) or ((SID shl 5) and $F800);
  if IsExtended then
  begin
    CANPtr^ := CANPtr^ or $0001;
    Inc(CANPtr);                                                                // Move to C1TXnEID
    CANPtr^ := ((EID shr 6) and $00FF) or ((EID shr 2) and $F000);
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
    CANPtr^ := ((EID shl 10) and $FC00);
  end else
  begin
    Inc(CANPtr);                                                                // Move to C1TXnEID
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
  end;
  CANPtr^ := (CANPtr^ and $FF87) or (WORD( DataCount) shl 3);
  Inc(CANPtr);                                                                  // Move to C1TXnB1
  CANPtr^ := DataBytes[0] or (DataBytes[1] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnB2
  CANPtr^ := DataBytes[2] or (DataBytes[3] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnB3
  CANPtr^ := DataBytes[4] or (DataBytes[5] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnB4
  CANPtr^ := DataBytes[6] or (DataBytes[7] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnCON
  CANPtr^ := (CANPtr^ and $FFFC) or Priority or $0008;                          // Set Priority and Set TXREQ to start transmit
end;

end.