unit NMRABus;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRABus specifications
//
// ******************************************************************************


uses
  NMRABusDefines,
  NMRABusUtilities,
  CANStorage,
  CANDefines,
  NMRABusDatagrams,
  NMRABusDatagramDefines;

{$I Options.inc}

type
  TPacketHandlerFunc = procedure(CANBuffer: PCANBuffer; var DoDefault: Boolean);
  PPacketHandlerFunc = ^TPacketHandlerFunc;
  TDatagramPacketHandlerFunc = procedure(DatagramBuffer: PDatagramBuffer; var DoDefault: Boolean);
  PDatagramPacketHandlerFunc = ^TDatagramPacketHandlerFunc;
  TStreamPacketHandlerFunc = procedure(CANBuffer: PCANBuffer; var DoDefault: Boolean);
  PStreamPacketHandlerFunc = ^TStreamPacketHandlerFunc;


  procedure NMRABus_Process;
//  procedure NMRABus_Connect;
  function NMRABus_Permitted: Boolean;
  procedure NMRABus_Disconnect;
  procedure NMRABus_Initialize;
  procedure NMRABus_GlobalTimer;
  procedure NMRABus_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);       // WARNING:  The Hook is called from within the Interrupt Handler.....
  procedure NMRABus_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);   // WARNING:  The Hook is called from within the Interrupt Handler.....


  // callbacks from the CAN interrupts used in the xxxxx_CAN_Interrupt.mpas units
  procedure ReceivedOnFilter0(Buffer: PCANBuffer);
  procedure ReceivedOnFilter1(Buffer: PCANBuffer);
  procedure ReceivedOnFilter2(Buffer: PCANBuffer);
  procedure ReceivedOnFilter3(Buffer: PCANBuffer);
  procedure ReceivedOnFilter4(Buffer: PCANBuffer);
  procedure ReceivedOnFilter5(Buffer: PCANBuffer);
  procedure ReceivedOnFilter6(Buffer: PCANBuffer);


  // defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure EnableCANInterrupt(Enable: Boolean); external;

  // defined in the user program
  procedure GetUniqueIDFunc(var HiID, LoID: DWord); external;
  
var
  RX_CANBufferList: TCANBufferList; external;
  TX_CANBufferList: TCANBufferList; external;
  RX_NMRAnetBufferList: TCANBufferList; external;
  TX_NMRAnetBufferList: TCANBufferList; external;


implementation

var
  CANLayerReceiveHook: PPacketHandlerFunc;
  NMRAnetLayerReceiveHook: PPacketHandlerFunc;
  

procedure NMRABus_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  CANLayerReceiveHook := HookFunc
end;

procedure NMRABus_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  NMRAnetLayerReceiveHook := HookFunc
end;

// *****************************************************************************
//  procedure FlushLists
//     Parameters:
//     Returns:
//
//     Description: Clears the lists
//
// *****************************************************************************
procedure FlushLists;
begin
  CANStorage_FlushList(@TX_CANBufferList);                                      // Flush any pending packets
  CANStorage_FlushList(@TX_NMRAnetBufferList);
  CANStorage_FlushList(@RX_CANBufferList);                                      // Flush any pending packets
  CANStorage_FlushList(@RX_NMRAnetBufferList);
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnCANLayer
//
//  Description:
//                 All CAN Layer messages are high priority and are dealt with immediately
//
// ****************************************************************************
procedure HandlePacketReceivedOnCANLayer;
var
  CANBuffer: TCANBuffer;
  NodeID: TNodeID;
  DoDefault: Boolean;
  LocalFlags: Word;
begin
  while CANStorage_ExtractFromList(@RX_CANBufferList, CANBuffer) do             // Pull all the Received Messages out (should be only one)
  begin
    DoDefault := True;
    if CANLayerReceiveHook <> nil then
      CANLayerReceiveHook(@CANBuffer, DoDefault);
    if DoDefault then
    begin
      LocalFlags := 0;
      // This is ALWAYS checked regardless of permitted state
      if NMRABusUtilities_EqualAliasID(CANBuffer.ID and MASK_SOURCE_ALIAS) then           // Is the 12 Bit Alias equal to ours?
      begin
        LocalFlags := LocalFlags or RMF_DUPLICATE_ALIAS_DETECTED;
        if (CANBuffer.ID and FT_CID_MASK <= FT_CID0) and (CANBuffer.ID and FT_CID_MASK >= FT_CID6) then // If it is a CID message then force calling node to try again for an Alias this one is ours
        begin
          LocalFlags := LocalFlags or RMF_SEND_RID;
        end;
      end;
      if NMRABus_Permitted then
      begin
        if CANBuffer.ID and FT_AME = FT_AME then                                // Alias Mapping Enquiry
        begin
          if CANBuffer.DataCount > 0 then
          begin
            NMRABusUtilities_PacketBytesToNodeID(@CANBuffer, NodeID);           // Extract the 48 Bit ID
            if NMRABusUtilities_EqualNodeID(NodeID) then                        // If addressed to us then respond
              LocalFlags := LocalFlags or RMF_SEND_AMD;
          end else
            LocalFlags := LocalFlags or RMF_SEND_AMD;
        end else
        if CANBuffer.ID and FT_AMD = FT_AMD then
        begin
          NMRABusUtilities_PacketBytesToNodeID(@CANBuffer, NodeID);           // Extract the 48 Bit ID
          if NMRABusUtilities_EqualNodeID(NodeID) then                        // If addressed to us then respond
            LocalFlags := LocalFlags or RMF_SEND_PCER
        end;
      end;
      NMRABus.ReceivedMsgFlags := NMRABus.ReceivedMsgFlags or LocalFlags
    end
  end
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnNMRABusLayer
//
//  Description:
//                 All NMRABus Layer messages are low priority and placed in the List for
//     handling in the main message loop
//
// ****************************************************************************
procedure HandlePacketReceivedOnNMRABusLayer;
var
  CANBuffer: TCANBuffer;
  DoDefault: Boolean;
  LocalFlags: Word;
  
    s1: array[8] of char;
    
begin
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #4; end; {$ENDIF}
  C1IE_bit := 0;
  if CANStorage_ExtractFromList(@RX_NMRAnetBufferList, CANBuffer) then                     // Pull next Received Messages out
  begin
  
 //   LongWordToStr(CANBuffer.ID, s1);
 //  UART1_Write_Text(s1+LF);
   
    if NMRABus_Permitted then
    begin
      DoDefault := True;
      if NMRAnetLayerReceiveHook <> nil then
        NMRAnetLayerReceiveHook(@CANBuffer, DoDefault);
      if DoDefault then
      begin
        LocalFlags := 0;
        if not NMRABusUtilities_IsAddressedMessage(@CANBuffer) then
        begin
        
    //    UART1_Write_Text('na'+LF);
        
          // Not and addressed message
          if CANBuffer.ID and FT_VERIFY_NODE_ID_NUMBER_NO_DEST = FT_VERIFY_NODE_ID_NUMBER_NO_DEST then
            LocalFlags := LocalFlags or RMF_SEND_VERIFIED_NODE
        end else
        if NMRABusUtilities_IsAddressedMessageToNode(@CANBuffer) then
        begin
        
     //     UART1_Write_Text('atn'+LF);
          // Address message to this node
          if (CANBuffer.ID and FT_VERIFY_NODE_ID_NUMBER_DEST = FT_VERIFY_NODE_ID_NUMBER_DEST) and (CANBuffer.DataBytes[0] = SFT_VERIFY_NODE_DEST) then
            LocalFlags := LocalFlags or RMF_SEND_VERIFIED_NODE
        end else
        begin
          // Addressed message not to this node
    //      UART1_Write_Text('antn'+LF);
        end;
        NMRABus.ReceivedMsgFlags := NMRABus.ReceivedMsgFlags or LocalFlags
      end
    end
  end;
  {$IFDEF FIX_NESTED_INTERRUPT_SILICON_BUG} asm DISI #4; end; {$ENDIF}
   C1IE_bit := 1;
end;

// *****************************************************************************
//  procedure ReceivedOnFilter0
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 0 which is defined
//                  as any CAN level message (bit 26 = 0)
//
// *****************************************************************************
procedure ReceivedOnFilter0(Buffer: PCANBuffer);
var
  Next: PCANBuffer;
begin
  Next := CANStorage_Head(@RX_CANBufferList);                                   // A little inefficient but keeps it consistent, move the message in to the buffer
  if Next <> nil then
  begin
    Next^ := Buffer^;
    CANStorage_IncHead(@RX_CANBufferList);
    HandlePacketReceivedOnCANLayer                                              // On the CAN Layer the messages are dealt with in real time
  end else
  begin
      // Have overrun problem
  end;
end;

// *****************************************************************************
//  procedure ReceivedOnFilter1
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 1 which is defined
//                  as any NMRABus level message (bit 26 = 1)
//
// *****************************************************************************
procedure ReceivedOnFilter1(Buffer: PCANBuffer);
var
  Next: PCANBuffer;
begin
  Next := CANStorage_Head(@RX_NMRAnetBufferList);
  if Next <> nil then
  begin
    Next^ := Buffer^;
    CANStorage_IncHead(@RX_NMRAnetBufferList);
    HandlePacketReceivedOnNMRABusLayer
  end else
  begin
      // Have overrun problem
  end;
end;

// *****************************************************************************
//  procedure ReceivedOnFilter2
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 2
//
// *****************************************************************************
procedure ReceivedOnFilter2(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter3
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 3
//
// *****************************************************************************
procedure ReceivedOnFilter3(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter4
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 4
//
// *****************************************************************************
procedure ReceivedOnFilter4(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter5
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 5
//
// *****************************************************************************
procedure ReceivedOnFilter5(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter6
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 6
//
// *****************************************************************************
procedure ReceivedOnFilter6(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure NMRABus_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the BufferArray
//              LasterBuffer   : Pointer to the last item in the BufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure NMRABus_InitializeList(ListPtr: PCANBufferList; BufferArrayPtr: PCANBufferArray; ListLength: Byte);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.Size := ListLength;
  ListPtr^.Head := @BufferArrayPtr^[0];
  ListPtr^.Tail := @BufferArrayPtr^[0];
  ListPtr^.Count := 0;
  ListPtr^.MaxCount := 0;
end;

// *****************************************************************************
//  procedure NMRABus_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Initialize;
begin
  NMRABus.State := 0;
  NMRABus.Interrupt_State := 0;
  GetUniqueIDFunc(NMRABus.Node_ID[1], NMRABus.Node_ID[0]);
  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Node_ID[0];
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Node_ID[1];
  NMRABus.iState := STATE_NMRABUS_START;
  NMRABus.ReceivedMsgFlags := 0;
  CANLayerReceiveHook := PPacketHandlerFunc( nil);
  NMRAnetLayerReceiveHook := PPacketHandlerFunc( nil);
  NMRABus_InitializeList(@RX_CANBufferList, @RX_CANBuffer, RX_CAN_BUFFER_LEN);
  NMRABus_InitializeList(@TX_CANBufferList, @TX_CANBuffer, TX_CAN_BUFFER_LEN);
  NMRABus_InitializeList(@RX_NMRAnetBufferList, @RX_NMRAnet_Buffer, RX_NMRANET_BUFFER_LEN);
  NMRABus_InitializeList(@TX_NMRAnetBufferList, @TX_NMRAnet_Buffer, RX_NMRANET_BUFFER_LEN);
  NMRABusDatagrams_Initialize;
end;

// *****************************************************************************
//  function NMRABus_Permitted
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRABus_Permitted: Boolean;
begin
  Result := NMRABus.State and BS_PERMITED = BS_PERMITED
end;

// *****************************************************************************
//  procedure NMRABus_GlobalTimer
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_GlobalTimer;
begin
  Inc(NMRABus.LoginTimeCount);
end;

function TransmitBufferEmptyCAN: Boolean;
begin
  Result := True
end;

function TestReceivedMsgFlags(Flag: Word): Boolean;
var
  Temp: Word;
begin
  EnableCANInterrupt(False);
  Temp := NMRABus.ReceivedMsgFlags;
  NMRABus.ReceivedMsgFlags := NMRABus.ReceivedMsgFlags and not Flag;
  Result := Temp and Flag = Flag;
  EnableCANInterrupt(True);
end;

procedure NMRABus_Process;
var
  Buffer: TCANBuffer;
begin
  case NMRABus.iState of
    STATE_NMRABUS_START :
      begin
        NMRABus.State := BS_INHIBITED or BS_UNITIALIZED;
        FlushLists;
        while CANStorage_Transmitting do;                                             // Wait for the last transmited packet
        NMRABus.iState := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_GENERATE_NODE_ALIAS :
      begin
        NMRABusUtilities_CreateAliasID(False);
        NMRABus.MTI := 0;
        NMRABus.iState := STATE_NMRABUS_TRANSMIT_CID;
      end;
    STATE_RANDOM_NUMBER_GENERATOR :
      begin
        NMRABusUtilities_PsudoRandomNumberGenerator;
        NMRABus.iState := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_TRANSMIT_CID :
      begin
        case NMRABus.MTI of
          0 : NMRABusUtilities_CreateCANControlFramePacket(FT_CID0, @Buffer);   // Queue up
          1 : NMRABusUtilities_CreateCANControlFramePacket(FT_CID1, @Buffer);
          2 : NMRABusUtilities_CreateCANControlFramePacket(FT_CID2, @Buffer);
          3 : NMRABusUtilities_CreateCANControlFramePacket(FT_CID3, @Buffer);
        end;
        if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
        begin
          StartCANMessageEngine();
          NMRABus.iState := STATE_NMRABUS_NEXT_MTI;
        end
      end;
    STATE_NMRABUS_NEXT_MTI :
      begin
        if NMRABus.MTI < 3 then
        begin
          Inc(NMRABus.MTI);
          NMRABus.iState := STATE_NMRABUS_TRANSMIT_CID
        end else 
        begin
          if not CANStorage_Transmitting then                                   // Wait until the transmission is complete before waiting the 200ms
          begin
            NMRABus.iState := STATE_NMRABUS_WAITSTATE;
            NMRABus.LoginTimeCount := 0;
          end
        end
      end;
    STATE_NMRABUS_WAITSTATE :
      begin
        if NMRABus.LoginTimeCount > MAX_BUS_LOGIN_TIMEOUT then
          NMRABus.iState := STATE_NMRABUS_SEND_LOGIN_RID;
      end;
    STATE_NMRABUS_SEND_LOGIN_RID :
      begin
        if TestReceivedMsgFlags(RMF_DUPLICATE_ALIAS_DETECTED) then
          NMRABus.iState := STATE_RANDOM_NUMBER_GENERATOR
        else begin
          NMRABusUtilities_CreateCANControlFramePacket(FT_RID, @Buffer);
          if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
          begin
            StartCANMessageEngine();
            NMRABus.iState := STATE_NMRABUS_SEND_LOGIN_AMD
          end
        end
      end;
    STATE_NMRABUS_SEND_NODE_VERIFIED :
      begin
        NMRABusUtilities_CreateCANControlFramePacket(FT_VERIFIED_NODE_ID_NUMBER, @Buffer);
        if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
        begin
          StartCANMessageEngine();
          NMRABus.iState := STATE_NMRABUS_PERMITTED;
        end
      end;
    STATE_NMRABUS_SEND_LOGIN_AMD :
      begin
        NMRABusUtilities_CreateCANControlFramePacket(FT_AMD, @Buffer);
        if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
        begin
          StartCANMessageEngine();
          NMRABus.iState := STATE_NMRABUS_INITIALIZED;
          NMRABus.State := NMRABus.State or BS_PERMITED and not BS_INHIBITED
        end
      end;
    STATE_NMRABUS_INITIALIZED :
      begin
        NMRABusUtilities_CreateNMRABusMessagePacket(FT_INITIALIZATION_COMPLETE, 0, @Buffer);
        CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer);
        begin
          StartCANMessageEngine();
          NMRABus.iState := STATE_NMRABUS_PERMITTED;
          NMRABus.State := NMRABus.State or BS_INITIALIZED and not BS_UNITIALIZED
        end
      end;
    STATE_NMRABUS_PERMITTED :
      begin
        if TestReceivedMsgFlags(RMF_DUPLICATE_ALIAS_DETECTED) then
          NMRABus.iState := STATE_NMRABUS_DUPLICATE_ALIAS;
        if TestReceivedMsgFlags(RMF_SEND_AMD) then                              // AliasMapEnquiryDetected
          NMRABus.iState := STATE_NMRABUS_SEND_AMD;
        if TestReceivedMsgFlags(RMF_SEND_PCER) then                             // AliasMapDefinitionDuplicateNodeIDDetected
          NMRABus.iState := STATE_NMRABUS_DUPLICATE_FULL_ID;
      end;
    STATE_NMRABUS_SEND_AMD :
      begin
        NMRABusUtilities_CreateCANControlFramePacket(FT_AMD, @Buffer);
        if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
        begin
          StartCANMessageEngine();
          NMRABus.iState := STATE_NMRABUS_PERMITTED
        end
      end;
    STATE_NMRABUS_DUPLICATE_ALIAS :
      begin
        if TestReceivedMsgFlags(RMF_SEND_RID) then                              // ReceivedCheckIDMsg
          NMRABus.iState := STATE_NMRABUS_SEND_RID
        else
          NMRABus.iState := STATE_NMRABUS_INHIBITED
      end;
    STATE_NMRABUS_SEND_RID :
      begin
        NMRABusUtilities_CreateCANControlFramePacket(FT_RID, @Buffer);
        if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
        begin
          StartCANMessageEngine();
          NMRABus.iState := STATE_NMRABUS_PERMITTED
        end
      end;
    STATE_NMRABUS_INHIBITED :
      begin
        FlushLists;
        NMRABusUtilities_CreateCANControlFramePacket(FT_AMD, @Buffer);
        if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
        begin
          StartCANMessageEngine();
          NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_RANDOM_NUMBER_GENERATOR;
        end
      end;
    STATE_NMRABUS_DUPLICATE_FULL_ID :
      begin
        FlushLists;
        NMRABusUtilities_CreateCANControlFramePacket(FT_AMR, @Buffer);
        if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
        begin
          StartCANMessageEngine();
          NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_NMRABUS_TAKE_OFFLINE
        end
      end;
    STATE_NMRABUS_TAKE_OFFLINE :
      begin
  {      NMRABusUtilities_CreateNMRABusMessagePacket(FT_DUPLICATE_NODE_ID, 0, @Buffer);
        CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer);
        begin
          NMRABus.iState := STATE_NMRABUS_OFFLINE;
          NMRABus.State := NMRABus.State or BS_INITIALIZED and not BS_UNITIALIZED
        end    }
      end;
    STATE_NMRABUS_OFFLINE :
      begin
        // Done until reboot
      end;
  end
end;

// *****************************************************************************
//  procedure NMRABus_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Disconnect;
begin
  NMRABus.iState := STATE_NMRABUS_INHIBITED
end;

end.