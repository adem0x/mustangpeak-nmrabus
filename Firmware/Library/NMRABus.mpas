unit NMRABus;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRABus specifications
//
// ******************************************************************************


uses
  NMRABusDefines,
  NMRABusUtilities,
  CANStorage,
  CANDefines,
  NMRABusDatagrams,
  NMRABusDatagramDefines;

{$I Options.inc}

type
  TPacketHandlerFunc = procedure(CANBuffer: PCANBuffer; var DoDefault: Boolean);
  PPacketHandlerFunc = ^TPacketHandlerFunc;
  TDatagramPacketHandlerFunc = procedure(DatagramBuffer: PDatagramBuffer; var DoDefault: Boolean);
  PDatagramPacketHandlerFunc = ^TDatagramPacketHandlerFunc;
  TStreamPacketHandlerFunc = procedure(CANBuffer: PCANBuffer; var DoDefault: Boolean);
  PStreamPacketHandlerFunc = ^TStreamPacketHandlerFunc;


  procedure NMRABus_Process;
//  procedure NMRABus_Connect;
  function NMRABus_Permitted: Boolean;
  procedure NMRABus_Disconnect;
  procedure NMRABus_Initialize;
  procedure NMRABus_1ms_Timer;
  procedure NMRABus_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);       // WARNING:  The Hook is called from within the Interrupt Handler.....
  procedure NMRABus_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);   // WARNING:  The Hook is called from within the Interrupt Handler.....


  // callbacks from the CAN interrupts used in the xxxxx_CAN_Interrupt.mpas units
  procedure ReceivedOnFilter0(Buffer: PCANBuffer);
  procedure ReceivedOnFilter1(Buffer: PCANBuffer);
  procedure ReceivedOnFilter2(Buffer: PCANBuffer);
  procedure ReceivedOnFilter3(Buffer: PCANBuffer);
  procedure ReceivedOnFilter4(Buffer: PCANBuffer);
  procedure ReceivedOnFilter5(Buffer: PCANBuffer);
  procedure ReceivedOnFilter6(Buffer: PCANBuffer);


  // defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure EnableCANInterrupt(Enable: Boolean); external;

  // defined in the user program
  procedure GetUniqueIDFunc(var HiID, LoID: DWord); external;
  
var
  TX_CANBufferList: TCANBufferList; external;
  TX_NMRAnetBufferList: TCANBufferList; external;


implementation

var
  CANLayerReceiveHook: PPacketHandlerFunc;
  NMRAnetLayerReceiveHook: PPacketHandlerFunc;
  
  
  s1: array[32] of char;
  

procedure NMRABus_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  CANLayerReceiveHook := HookFunc
end;

procedure NMRABus_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  NMRAnetLayerReceiveHook := HookFunc
end;


// *****************************************************************************
//  procedure FlushResponseList
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure FlushResponses;
var
  i, j: Integer;
begin
  NMRABus.Responses.SimpleResponseFlags := 0;
  NMRABus.Responses.ListIndex := 0;
  NMRABus.Responses.SimpleIndexMask := 0;
  NMRABus.Responses.iState := 0;
  NMRABus.Responses.iCDI := 0;
  for i := 0 to LEN_QUEUED_RESPONSE_LIST - 1 do
  begin
    NMRABus.Responses.List[i].ResponseCode := 0;
    NMRABus.Responses.List[i].DestinationNodeAlias := 0;
    for j := 0 to CAN_DATA_LEN - 1 do
      NMRABus.Responses.List[i].DataBytes[j] := 0;
  end;
end;

// *****************************************************************************
//  procedure FlushLists
//     Parameters:
//     Returns:
//
//     Description: Clears the lists
//
// *****************************************************************************
procedure FlushLists;
begin
  CANStorage_FlushList(@TX_CANBufferList);                                      // Flush any pending packets
  CANStorage_FlushList(@TX_NMRAnetBufferList);
end;

// *****************************************************************************
//  procedure NMRABus_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the BufferArray
//              LasterBuffer   : Pointer to the last item in the BufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure NMRABus_InitializeList(ListPtr: PCANBufferList; BufferArrayPtr: PCANBufferArray; ListLength: Byte);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.Size := ListLength;
  ListPtr^.Head := @BufferArrayPtr^[0];
  ListPtr^.Tail := @BufferArrayPtr^[0];
  ListPtr^.Count := 0;
  ListPtr^.MaxCount := 0;
end;

// *****************************************************************************
//  procedure NMRABus_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Initialize;
begin
  NMRABus.State := 0;
  NMRABus.Interrupt_State := 0;
  GetUniqueIDFunc(NMRABus.Node_ID[1], NMRABus.Node_ID[0]);
  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Node_ID[0];
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Node_ID[1];
  NMRABus.iState := STATE_NMRABUS_START;
  FlushResponses;
  CANLayerReceiveHook := PPacketHandlerFunc( nil);
  NMRAnetLayerReceiveHook := PPacketHandlerFunc( nil);
  NMRABus_InitializeList(@TX_CANBufferList, @TX_CANBuffer, TX_CAN_BUFFER_LEN);
  NMRABus_InitializeList(@TX_NMRAnetBufferList, @TX_NMRAnet_Buffer, TX_NMRANET_BUFFER_LEN);
  NMRABusDatagrams_Initialize;
end;

// *****************************************************************************
//  function NMRABus_Permitted
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRABus_Permitted: Boolean;
begin
  Result := NMRABus.State and BS_PERMITED = BS_PERMITED
end;

// *****************************************************************************
//  procedure NMRABus_1ms_Timer;
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_1ms_Timer;
begin
  Inc(NMRABus.LoginTimeCount);
  NMRABusDatagrams_1ms_TimeTick;
end;


// ***********************************************************************************************************
// CAN RECEIVE METHODS
//************************************************************************************************************

// *****************************************************************************
// CAN/NMRAnet Layer Message Handlers
// *****************************************************************************
procedure ReceivedEqualAliasID(CANBuffer: PCANBuffer);
begin
  if (CANBuffer^.ID and FT_CID_MASK <= FT_CID0) and (CANBuffer^.ID and FT_CID_MASK >= FT_CID6) then // If it is a CID message then force calling node to try again for an Alias this one is ours
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRF_SEND_RID
  else
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRF_DUPLICATE_ALIAS
end;

// *****************************************************************************
// CAN Layer Message Handlers
// *****************************************************************************

procedure ReceivedAliasMappingDefinition(CANBuffer: PCANBuffer);
var
  NodeID: TNodeID;
begin
  NMRABusUtilities_PacketBytesToNodeID(@CANBuffer^, NodeID);                    // Extract the 48 Bit ID
  if NMRABusUtilities_EqualNodeID(NodeID) then                                  // If addressed to us then respond
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRF_DUPLICATE_NODE_ID;
end;

procedure ReceivedAliasMappingEnquiry(CANBuffer: PCANBuffer);
var
  NodeID: TNodeID;
begin
  if CANBuffer^.DataCount > 0 then
  begin
    NMRABusUtilities_PacketBytesToNodeID(CANBuffer, NodeID);              // Extract the 48 Bit ID
    if NMRABusUtilities_EqualNodeID(NodeID) then                          // If addressed to us then respond
      NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRF_SEND_AMD;
  end else
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRF_SEND_AMD;
end;

// *****************************************************************************
// NMRAnet Layer Message Handlers
// *****************************************************************************

procedure ReceivedUnAddressedMessage(CANBuffer: PCANBuffer);
begin
  if (CANBuffer^.ID and FT_UNADDRESSED_MASK = FT_VERIFY_NODE_ID_NUMBER_NO_DEST) then
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRF_SEND_VERIFIED_NODE;
end;

procedure ReceivedAddressedMessage(CANBuffer: PCANBuffer);
var
  MTICode: Word;
begin
  if NMRABusUtilities_IsAddressedMessageToNode(CANBuffer) then
  begin
    MTICode := NMRABusUtilities_PackBytesLo(CANBuffer);                         // Packs the 4 lower Bytes of the CAN data into a full Word
    if MTICode and $00FF = MTI_VERIFY_NODE_DEST then
      NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRF_SEND_VERIFIED_NODE
    else
    if MTICode = MTI_PROTOCOL_SUPPORT_INQUIRY then                              // 32E4 in DataBytes
      NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRF_SEND_PROTOCOL_SUPPORT
    else
    if MTICode = MTI_PROTOCOL_SUPPORT_RESPONSE then
    begin
   //   NMRABus.ProtocolSupportInfo.AliasID := NMRABusUtilities_ExtractDestinationAlias(CANBuffer);
  //    for i := 0 to 5 do
  //      NMRABus.ProtocolSupportInfo.ProtocolFlags[i] := CANBuffer^.DataBytes[i + 2];
  //    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or RMF_SEND_PROTOCOL_SUPPORT_INQURIY_VALID    // Received a Nodes Protocol Support Flags, set valid flag
    end
  end
end;

procedure ReceivedDatagramMessage(CANBuffer: PCANBuffer);
begin
  if NMRABusUtilities_IsAddressedMessageToNode(CANBuffer) then
  begin
  end

end;

procedure ReceivedStreamMessage(CANBuffer: PCANBuffer);
begin
  if NMRABusUtilities_IsAddressedMessageToNode(CANBuffer) then
  begin
  end
end;


// ****************************************************************************
// procedure HandlePacketReceivedOnCANLayer
//
//  Description:
//                 All CAN Layer messages are high priority and are dealt with immediately
//
// ****************************************************************************
procedure HandlePacketReceivedOnCANLayer(CANBuffer: PCANBuffer);
var
  DoDefault: Boolean;
begin
  DoDefault := True;
  if CANLayerReceiveHook <> nil then
    CANLayerReceiveHook(CANBuffer, DoDefault);
  if DoDefault then
  begin
    if NMRABusUtilities_EqualAliasID(CANBuffer^.ID and MASK_SOURCE_ALIAS) then  // This is ALWAYS checked regardless of permitted state
      ReceivedEqualAliasID(CANBuffer);

    if NMRABus_Permitted then
    begin
      if CANBuffer^.ID and FT_UNADDRESSED_MASK = FT_AME then
        ReceivedAliasMappingEnquiry(CANBuffer)
      else
      if CANBuffer^.ID and FT_UNADDRESSED_MASK = FT_AMD then
         ReceivedAliasMappingDefinition(CANBuffer)
    end;
  end;
end;

// ****************************************************************************
// procedure HandlePacketReceivedOnNMRABusLayer
//
//  Description:
//                 All NMRABus Layer messages are low priority and placed in the List for
//     handling in the main message loop
//
// ****************************************************************************
procedure HandlePacketReceivedOnNMRABusLayer(CANBuffer: PCANBuffer);
var
  DoDefault: Boolean;
  i: Integer;
begin
  DoDefault := True;
  if NMRAnetLayerReceiveHook <> nil then 
    NMRAnetLayerReceiveHook(CANBuffer, DoDefault);                              // Allow the program to have a crack at the message handler
    
  if DoDefault then
  begin
    if NMRABusUtilities_EqualAliasID(CANBuffer^.ID and MASK_SOURCE_ALIAS) then  // This is ALWAYS checked regardless of permitted state
      ReceivedEqualAliasID(CANBuffer);

    if NMRABus_Permitted then
    begin
      case CANBuffer^.ID and MTI_TYPE_MASK of
        MTI_UNADDRESSED              : ReceivedUnAddressedMessage(CANBuffer);
        MTI_RESERVED                 : begin end;
        MTI_DATAGRAM_ONLY_FRAME,
        MTI_DATAGRAM_FRAME_START,
        MTI_DATAGRAM_FRAME,
        MTI_DATAGRAM_FRAME_END       : ReceivedDatagramMessage(CANBuffer);
        MTI_ADDRESSED                : ReceivedAddressedMessage(CANBuffer);
        MTI_STREAM_DATA_SEND         : ReceivedStreamMessage(CANBuffer);
      end;
    end;
  end;
end;

// *****************************************************************************
//  procedure ReceivedOnFilter0
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 0 which is defined
//                  as any CAN level message (bit 26 = 0)
//
// *****************************************************************************
procedure ReceivedOnFilter0(Buffer: PCANBuffer);
begin
  HandlePacketReceivedOnCANLayer(Buffer)
end;

// *****************************************************************************
//  procedure ReceivedOnFilter1
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 1 which is defined
//                  as any NMRABus level message (bit 26 = 1)
//
// *****************************************************************************
procedure ReceivedOnFilter1(Buffer: PCANBuffer);
begin
  HandlePacketReceivedOnNMRABusLayer(Buffer);
end;

// *****************************************************************************
//  procedure ReceivedOnFilter2
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 2
//
// *****************************************************************************
procedure ReceivedOnFilter2(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter3
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 3
//
// *****************************************************************************
procedure ReceivedOnFilter3(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter4
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 4
//
// *****************************************************************************
procedure ReceivedOnFilter4(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter5
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 5
//
// *****************************************************************************
procedure ReceivedOnFilter5(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter6
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 6
//
// *****************************************************************************
procedure ReceivedOnFilter6(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// ***********************************************************************************************************
// MESSAGELOOP RESPONSE METHODS
//************************************************************************************************************

// *****************************************************************************
//  procedure TryTransmitCANLayerMsg
//     Parameters:
//     Returns:
//
//     Description: Clears the lists
//
// *****************************************************************************
function TryTransmitCANLayerMsg(VariableField: DWord; Buffer: PCANBuffer): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_CANBufferList) then
  begin
    NMRABusUtilities_CreateCANControlFramePacket(VariableField, Buffer);
    if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True
    end
  end
end;

// *****************************************************************************
//  procedure TryTransmitNMRABusLayerMsg
//     Parameters:
//     Returns:
//
//     Description: Clears the lists
//
// *****************************************************************************
function TryTransmitNMRABusLayerMsg(VariableField: DWord; DestinationAlias: Word; Buffer: PCANBuffer): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    NMRABusUtilities_CreateNMRABusMessagePacket(VariableField, DestinationAlias, Buffer);
    if CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True;
    end
  end
end;

function TestReceivedMsgFlags(Flags: Word; Clear: Boolean): Boolean;
var
  Temp: Word;
begin
 // EnableCANInterrupt(False);
  Temp := NMRABus.Responses.SimpleResponseFlags;
  if Clear then
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags and not Flags;
  Result := Temp and Flags <> 0;
 // EnableCANInterrupt(True);
end;

procedure SimpleResponse_Process;
begin

end;

procedure Response_Process;
begin
  case NMRABus.Responses.iState of
    STATE_RESPONSE_START :
      begin
        if NMRABus.Responses.SimpleResponseFlags = 0 then
          NMRABus.Responses.iState := STATE_RESPONSE_NEXT_SIMPLE_RESPONSE
        else
          NMRABus.Responses.iState := STATE_RESPONSE_SIMPLE_RESPONSE
      end;
    STATE_RESPONSE_SIMPLE_RESPONSE :
      begin
        case NMRABus.Responses.SimpleIndexMask of
          $0001 : 
            begin
               if NMRABus.Responses.SimpleIndexMask and NMRABus.Responses.SimpleResponseFlags <> 0 then
               begin
               end
            end;
          $0002 : begin end;
          $0004 : begin end;
          $0008 : begin end;
          $0010 : begin end;
          $0020 : begin end;
          $0040 : begin end;
          $0080 : begin end;
          $0100 : begin end;
          $0200 : begin end;
          $0400 : begin end;
          $0800 : begin end;
          $1000 : begin end;
          $2000 : begin end;
          $4000 : begin end;
          $4000 : begin end;
        end;
        NMRABus.Responses.iState := STATE_RESPONSE_NEXT_SIMPLE_RESPONSE
      end;
    STATE_RESPONSE_NEXT_SIMPLE_RESPONSE :
      begin
        if NMRABus.Responses.SimpleIndexMask < $8000 then
         NMRABus.Responses.SimpleIndexMask := NMRABus.Responses.SimpleIndexMask shr 1
        else
          NMRABus.Responses.SimpleIndexMask := $0001;

        NMRABus.Responses.iState := STATE_RESPONSE_COMPLEX_RESPONSE
      end;
    STATE_RESPONSE_COMPLEX_RESPONSE :
      begin
        NMRABus.Responses.iState := STATE_RESPONSE_NEXT_COMPLEX_RESPONSE
      end;
    STATE_RESPONSE_NEXT_COMPLEX_RESPONSE :
      begin
        Inc(NMRABus.Responses.ListIndex);
        NMRABus.Responses.iState := STATE_RESPONSE_START
      end
  else
    NMRABus.Responses.iState := STATE_RESPONSE_START;
  end
end;

procedure NMRABus_Process;
var
  Buffer: TCANBuffer;
  VariableField: DWord;
begin
  case NMRABus.iState of
    STATE_NMRABUS_START :
      begin
        NMRABus.State := BS_INHIBITED or BS_UNITIALIZED;
        FlushLists;
        while CANStorage_Transmitting do;                                       // Wait for the last transmited packet
        NMRABus.iState := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_GENERATE_NODE_ALIAS :
      begin
        NMRABusUtilities_CreateAliasID(False);
        NMRABus.Responses.iCDI := 0;
        NMRABus.iState := STATE_NMRABUS_TRANSMIT_CID;
      end;
    STATE_RANDOM_NUMBER_GENERATOR :
      begin
        NMRABusUtilities_PsudoRandomNumberGenerator;
        NMRABus.iState := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_TRANSMIT_CID :
      begin
        case NMRABus.Responses.iCDI of
          0 : VariableField := FT_CID0;   // Queue up
          1 : VariableField := FT_CID1;
          2 : VariableField := FT_CID2;
          3 : VariableField := FT_CID3;
        end;
        if TryTransmitCANLayerMsg(VariableField, @Buffer) then
          NMRABus.iState := STATE_NMRABUS_NEXT_CDI;
      end;
    STATE_NMRABUS_NEXT_CDI :
      begin
        if NMRABus.Responses.iCDI < 3 then
        begin
          Inc(NMRABus.Responses.iCDI);
          NMRABus.iState := STATE_NMRABUS_TRANSMIT_CID
        end else 
        begin
          if not CANStorage_Transmitting then                                   // Wait until the transmission is complete before waiting the 200ms
          begin
            NMRABus.iState := STATE_NMRABUS_WAITSTATE;
            NMRABus.LoginTimeCount := 0;
          end
        end
      end;
    STATE_NMRABUS_WAITSTATE :
      begin
        if NMRABus.LoginTimeCount > MAX_BUS_LOGIN_TIMEOUT then
          NMRABus.iState := STATE_NMRABUS_SEND_LOGIN_RID;
      end;
    STATE_NMRABUS_SEND_LOGIN_RID :
      begin
        if TestReceivedMsgFlags(SRF_DUPLICATE_ALIAS, True) then
          NMRABus.iState := STATE_RANDOM_NUMBER_GENERATOR
        else
        if TryTransmitCANLayerMsg(FT_RID, @Buffer) then
          NMRABus.iState := STATE_NMRABUS_SEND_LOGIN_AMD;
      end;
    STATE_NMRABUS_SEND_LOGIN_AMD :
      begin
        if TestReceivedMsgFlags(SRF_DUPLICATE_ALIAS, True) then
          NMRABus.iState := STATE_RANDOM_NUMBER_GENERATOR
        else
        if TryTransmitCANLayerMsg(FT_AMD, @Buffer) then
        begin
          NMRABus.State := NMRABus.State or BS_PERMITED and not BS_INHIBITED;
          NMRABus.iState := STATE_NMRABUS_INITIALIZED
        end
      end;
    STATE_NMRABUS_INITIALIZED :
      begin
        if TestReceivedMsgFlags(SRF_DUPLICATE_ALIAS, True) then
          NMRABus.iState := STATE_NMRABUS_GENERATE_NODE_ALIAS
        else
        if TryTransmitNMRABusLayerMsg(FT_INITIALIZATION_COMPLETE, 0, @Buffer) then
        begin
          NMRABus.iState := STATE_NMRABUS_PERMITTED;
          NMRABus.State := NMRABus.State or BS_INITIALIZED and not BS_UNITIALIZED
        end
      end;
    STATE_NMRABUS_PERMITTED :
      begin
        if TestReceivedMsgFlags(SRF_DUPLICATE_NODE_ID, True) then
          NMRABus.iState :=  STATE_NMRABUS_DUPLICATE_FULL_ID                    // Highest Priority
        else
        if TestReceivedMsgFlags(SRF_DUPLICATE_ALIAS, True) then
          NMRABus.iState := STATE_NMRABUS_INHIBITED
        else
          Response_Process
      end;
    STATE_NMRABUS_INHIBITED :
      begin
        if TryTransmitCANLayerMsg(FT_AMR, @Buffer) then
        begin
          FlushLists;
          FlushResponses;
          NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_RANDOM_NUMBER_GENERATOR;
        end
      end;
    STATE_NMRABUS_DUPLICATE_FULL_ID :
      begin
        if TryTransmitCANLayerMsg(FT_AMR, @Buffer) then
        begin
          FlushLists;
          FlushResponses;
          NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_NMRABUS_TAKE_OFFLINE
        end
      end;
    STATE_NMRABUS_TAKE_OFFLINE :
      begin
    //    if TryTransmitNMRABusLayerMsg(PCER_DUPLICATE_ID..., @Buffer) then
    //    begin
    //      NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_NMRABUS_OFFLINE
    //    end
      end;
    STATE_NMRABUS_OFFLINE :
      begin
        // Done until reboot
      end
  else
    NMRABus.iState := STATE_NMRABUS_START;
  end
end;

// *****************************************************************************
//  procedure NMRABus_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRABus_Disconnect;
begin
  NMRABus.iState := STATE_NMRABUS_INHIBITED
end;

end.