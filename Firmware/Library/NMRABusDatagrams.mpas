unit NMRABusDatagrams;

uses
  NMRABusUtilities,
  CANDefines,
  CANStorage,
  NMRABusDefines,
  NMRABusDatagramDefines;

procedure NMRABusDatagrams_Initialize;
procedure NMRABusDatagrams_ProcessReceive(var Buffer: TCANBuffer);
procedure NMRABusDatagrams_ProcessResponse;
procedure NMRABusDatagrams_1ms_TimeTick;
function NMRABusDatagrams_Remove(var Datagram: TDatagram): Boolean;

// defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure EnableCANInterrupt(Enable: Boolean); external;

implementation

// *****************************************************************************
//  procedure NMRABusDatagrams_Initialize;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRABusDatagrams_Initialize;
var
  i, j: Integer;
begin
  for i := 0 to LEN_DATAGRAM_ARRAY - 1 do
  begin
    DatagramList[i].iState := STATE_DATAGRAM_EMPTY;
    DatagramList[i].iState := 0;
    for j := 0 to LEN_DATAGRAM-1 do
      DatagramList[i].DataBytes[j] := 0;
  end;
  DatagramProcessor.iState := STATE_DATAGRAM_PROCESSOR_START;
  DatagramProcessor.iBuffer := 0;
  for i := 0 to LEN_DATAGRAM_BUFFER_FULL_RESPONSE_LIST-1 do
    DatagramProcessor.BufferFullResponseList[i] := 0;
end;

// *****************************************************************************
//
// procedure NMRABusDatagrams_Remove;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Pulls the first found Ready Datagram in the Datagram Array
//
// *****************************************************************************
function NMRABusDatagrams_Remove(var Datagram: TDatagram): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := 0;
  while (i < LEN_DATAGRAM_ARRAY) and not Result do
  begin
    if DatagramList[i].iState = STATE_DATAGRAM_READY then
    begin
      Datagram := DatagramList[i].DataBytes;
      DatagramList[i].iState := STATE_DATAGRAM_EMPTY;
      Result := True;
    end;
    Inc(i);
  end
end;

// *****************************************************************************
//
// procedure NMRABusDatagrams_1ms_TimeTick;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Updates internal flags to track for various timeout conditions mainly for the bus.
//
//              WARNING: Application must make sure that the Datagram Array is not
//              modified in an interrupt when calling this function...... Disable the CAN for
//              the time this takes to run.
//
// *****************************************************************************
procedure NMRABusDatagrams_1ms_TimeTick;
var
  i: Integer;
begin
  for i := 0 to LEN_DATAGRAM_ARRAY - 1 do
  begin
    if DatagramList[i].iState = STATE_DATAGRAM_RECEIVING then
    begin
      if DatagramList[i].iWatchdog < DATAGRAM_WATCHDOG_MAX then                 // Latch it at DATAGRAM_WATCHDOG_MAX
        Inc(DatagramList[i].iWatchdog)                                          // Increase the Watchdog counter
    end
  end;
end;

// *****************************************************************************
//  procedure SendAnyBufferFullResponses;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure SendAnyBufferFullResponses;
var
  i: Integer;
  Buffer: TCANBuffer;
begin
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    i := 0;
    while i < LEN_DATAGRAM_BUFFER_FULL_RESPONSE_LIST do
    begin
      if DatagramProcessor.BufferFullResponseList[i] <> 0 then
      begin
        NMRABusUtilities_CreateNMRABusMessagePacket(MTI_ADDRESSED_NOT_DATAGRAM, DatagramProcessor.BufferFullResponseList[i], @Buffer);
        NMRABusUtilities_LoadCANData(Buffer.DataBytes, SFT_DATAGRAM_REJECTED, Hi(DATAGRAM_REJECTED_BUFFER_FULL), Lo(DATAGRAM_REJECTED_BUFFER_FULL), 0, 0, 0, 0, 0);
        Buffer.DataCount := 3;
        if CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer) then
        begin
          StartCANMessageEngine();
          DatagramProcessor.BufferFullResponseList[i] := 0;
        end;
        Exit;
      end;
      Inc(i);
    end;
  end
end;

// *****************************************************************************
//  procedure NMRABusDatagrams_ProcessResponse;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRABusDatagrams_ProcessResponse;
var
  Datagram: PDatagramBuffer;   
  Buffer: TCANBuffer;
begin
  Datagram := @DatagramList[DatagramProcessor.iBuffer];
  case DatagramProcessor.iState of
    STATE_DATAGRAM_PROCESSOR_START :
      begin
        SendAnyBufferFullResponses;
        case Datagram^.iState of
          STATE_DATAGRAM_RECEIVING          : if Datagram^.iWatchdog >= DATAGRAM_WATCHDOG_MAX then DatagramProcessor.iState := STATE_DATAGRAM_PROCESSOR_ABANDONED;
          STATE_DATAGRAM_TRANSFER_FULL      : DatagramProcessor.iState := STATE_DATAGRAM_PROCESSOR_RESPOND
        else
          DatagramProcessor.iState := STATE_DATAGRAM_PROCESSOR_NEXT;
        end;
      end;
    STATE_DATAGRAM_PROCESSOR_ABANDONED : 
      begin
        if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
        begin
          NMRABusUtilities_CreateNMRABusMessagePacket(MTI_ADDRESSED_NOT_DATAGRAM, Datagram^.SourceAlias, @Buffer);
          NMRABusUtilities_LoadCANData(Buffer.DataBytes, SFT_DATAGRAM_REJECTED, Hi(DATAGRAM_REJECTED_OUT_OF_ORDER), Lo(DATAGRAM_REJECTED_OUT_OF_ORDER), 0, 0, 0, 0, 0);
          Buffer.DataCount := 3;
          if CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer) then
          begin
            StartCANMessageEngine();
            DatagramProcessor.iState := STATE_DATAGRAM_PROCESSOR_NEXT;
            Datagram^.iState := STATE_DATAGRAM_EMPTY;
          end
        end
      end;
    STATE_DATAGRAM_PROCESSOR_RESPOND  :
      begin
        if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
        begin
          NMRABusUtilities_CreateNMRABusMessagePacket(MTI_ADDRESSED_NOT_DATAGRAM, Datagram^.SourceAlias, @Buffer);
          if Datagram^.ErrorCode = DGE_NONE then
          begin
            NMRABusUtilities_LoadCANData(Buffer.DataBytes, SFT_DATAGRAM_RECIEVED_OK, 0, 0, 0, 0, 0, 0, 0);
            Buffer.DataCount := 1
          end else
          begin
            NMRABusUtilities_LoadCANData(Buffer.DataBytes, SFT_DATAGRAM_REJECTED, Hi(DATAGRAM_REJECTED_OUT_OF_ORDER), Lo(DATAGRAM_REJECTED_OUT_OF_ORDER), 0, 0, 0, 0, 0);
            Buffer.DataCount := 3;
          end;
          if CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer) then
          begin
            StartCANMessageEngine();
            DatagramProcessor.iState := STATE_DATAGRAM_PROCESSOR_NEXT;
            if Datagram^.ErrorCode = DGE_NONE then
              Datagram^.iState := STATE_DATAGRAM_READY
            else
              Datagram^.iState := STATE_DATAGRAM_EMPTY;
          end
        end
      end;
    STATE_DATAGRAM_PROCESSOR_NEXT      :
      begin
        Inc(DatagramProcessor.iBuffer);
        if DatagramProcessor.iBuffer >= LEN_DATAGRAM_ARRAY then DatagramProcessor.iBuffer := 0;
        DatagramProcessor.iState := STATE_DATAGRAM_PROCESSOR_START
      end;
   end;
end;

// *****************************************************************************
//  function TryAllocateBuffer;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function TryAllocateBuffer(var Datagram: PDatagramBuffer): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := 0;
  while (i < LEN_DATAGRAM_ARRAY) and not Result do
  begin
    if DatagramList[i].iState = STATE_DATAGRAM_EMPTY then
    begin                                                                       // Grab the first empty buffer
      Datagram := @DatagramList[i];                                             // It is NOT initialized
      Datagram^.ErrorCode := 0;
      Result := True
    end;
    Inc(i);
  end
end;

// *****************************************************************************
//  function FindInProcessDatagram;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function FindInProcessDatagram(SourceAlias: Word; var Datagram: PDatagramBuffer): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := 0;
  while (i < LEN_DATAGRAM_ARRAY) and not Result do
  begin
    if DatagramList[i].iState = STATE_DATAGRAM_RECEIVING then
      if NMRABusUtilities_CompareAliasIDs(DatagramList[i].SourceAlias, SourceAlias) then
      begin
        Datagram := @DatagramList[i];
        Result := True
      end;
    Inc(i)
  end
end;

// *****************************************************************************
//  procedure UpdateFrameCount;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function UpdateFrameCount(Datagram: PDatagramBuffer): Boolean;
begin
  if Datagram^.ErrorCode = DGE_NONE then                                        // If in Error has already failed this function
  begin
    Inc(Datagram^.iFrameCount);                                                 // Next Frame
    Datagram^.iWatchdog := 0;                                                   // Reset the Watchdog since the source connected again
    if Datagram^.iFrameCount >= DATAGRAM_MAX_FRAME_COUNT then                   // Source sent too many frames
      Datagram^.ErrorCode := DGE_FRAME_OUT_OF_ORDER                             // Ready for a "Frame out of Order" Response
  end;
  Result := Datagram^.ErrorCode = DGE_NONE
end;

// *****************************************************************************
//  procedure StoreBytes;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure StoreBytes(Datagram: PDatagramBuffer; var Buffer: TCANBuffer; IsFull: Boolean);
var
  i: Integer;
  Offset: Word;
begin
  Offset := Datagram^.iFrameCount * 8;
  for i := 0 to CAN_DATA_LEN - 1 do
    Datagram^.DataBytes[i + Offset] := Buffer.DataBytes[i];
  if IsFull then
    Datagram^.iState := STATE_DATAGRAM_TRANSFER_FULL;                             // Ready for a "Full" Response
end;

// *****************************************************************************
//  procedure AddToBufferFullList;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure AddToBufferFullList(Datagram: PDatagramBuffer);
var
  i: Integer;
begin
  i := 0;
  while i < LEN_DATAGRAM_BUFFER_FULL_RESPONSE_LIST do
  begin
    if DatagramProcessor.BufferFullResponseList[i] = 0 then
    begin
      DatagramProcessor.BufferFullResponseList[i] := Datagram^.SourceAlias;
      Exit;
    end
  end;
end;

// *****************************************************************************
//  procedure NMRABusDatagrams_ProcessReceive;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRABusDatagrams_ProcessReceive(var Buffer: TCANBuffer);
var
  Datagram: PDatagramBuffer;
begin
  Datagram := PDatagramBuffer( nil);
  case Buffer.ID and MTI_TYPE_MASK of
    MTI_DATAGRAM_ONLY_FRAME :
      begin
        if TryAllocateBuffer(Datagram) then
        begin
          Datagram^.SourceAlias := Buffer.ID and MASK_SOURCE_ALIAS;
          Datagram^.iFrameCount := 0;
          StoreBytes(Datagram, Buffer, False);
          Datagram^.iState := STATE_DATAGRAM_TRANSFER_FULL;                               // Ready for a "Full" Response
        end
      end;
    MTI_DATAGRAM_FRAME_START :
      begin
        if TryAllocateBuffer(Datagram) then
        begin
          Datagram^.SourceAlias := Buffer.ID and MASK_SOURCE_ALIAS;
          Datagram^.iFrameCount := 0;
          Datagram^.iWatchdog := 0;
          StoreBytes(Datagram, Buffer, False);
          Datagram^.iState := STATE_DATAGRAM_RECEIVING;
        end
      end;
    MTI_DATAGRAM_FRAME :
      begin
        if FindInProcessDatagram(Buffer.ID and MASK_SOURCE_ALIAS, Datagram) then
          if UpdateFrameCount(Datagram) then
            StoreBytes(Datagram, Buffer, False)
      end;
    MTI_DATAGRAM_FRAME_END :
      begin
        if FindInProcessDatagram(Buffer.ID and MASK_SOURCE_ALIAS, Datagram) then
        begin
          if UpdateFrameCount(Datagram) then
            StoreBytes(Datagram, Buffer, True)
        end else
          AddToBufferFullList(Datagram);
      end;
   end;
end;

end.