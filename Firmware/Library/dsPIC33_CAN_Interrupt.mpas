unit dsPIC33_CAN_Interrupt;

uses
  MCU_Setup_dsPIC33FJ256GP710A,
  CAN_Storage,
  dsPIC33_CAN,
  dsPIC33_DMA,
  NMRABus;
  
procedure StartCANMessageEngine;                                                // Used to start a transmission cycle after a message is placed in a TX Buffer

implementation

// ****************************************************************************
// procedure PendingTransmitList;
//
// Loads the highest priority list with a message pending or nil if all are empty
// The result is stored in the CAN_Engine.TransmittingList so withing the interrupt
// we can remove this item from the list.
// For more (or less) priority buffer transmit lists edit this function and
// add/intialize more TCANRawBufferLists
//
// ****************************************************************************
function PendingTransmitList: PCANRawBufferList;
begin
   if TX_CANLayer_List.Count > 0 then
    Result := @TX_CANLayer_List                                                 // Highest Priority List
  else
  if TX_NMRABusLayer_List.Count > 0 then                                        // Least Priority List
    Result := @TX_NMRABusLayer_List
  else
    Result := PCANRawBufferList( nil)
end;

// ****************************************************************************
// function StartTransmission: Boolean;
//
// Starts the transmission if there are no current transmits in procress
//
// ****************************************************************************
function StartTransmission: Boolean;
var
  NextBuffer: PCANRawBuffer;
  PendingList: PCANRawBufferList;
begin
  Result := False;
  PendingList := PendingTransmitList;
  if PendingList <> PCANRawBufferList( nil) then                                // Pick the highest Priority List to send next
  begin
    NextBuffer := CANStorage_Tail(PendingList);                                 // Get a pointer to the Buffer to transmit
    if NextBuffer <> nil then                                                   // If there is something to send then send it
    begin
      TX_Main_RawBufferArray[0] := NextBuffer^;                                 // Copy the buffer info into the Transmit Registers
      dsPIC33_DMA_AddressOffsetA(0, Word( @TX_Main_RawBufferArray));            // In Register Indirect Mode we have to set the offset from the start of the Buffer Manually
      dsPIC33_DMA_TransferCount(0, dsPIC33_CAN_CalculateTransmitCountForRegAddressWithAutoIncrement(@TX_Main_RawBufferArray[0])); // In Register Indirect Mode we also have to change the number of words the transmit module will send manually
      dsPIC33_CAN_RequestTransmit(0);                                           // Set the Flag to start the transmission
      CANStorage_IncTail(PendingList);                                          // Release the Buffer from the List
      CAN_Engine.State := CAN_Engine.State or CES_TRANSMITTING;
      Result := True;
    end
  end
end;

// ****************************************************************************
// procedure StartCANMessageEngine;
//
// Starts the transmitter engine if there are no current transmits in procress
//
// ****************************************************************************
procedure StartCANMessageEngine;
begin
  // Can't let the interrupt be called "right after" we make the comparison to see if the list is empty.
  // That would be a race condition that may not start the next message from being sent.  By
  // shutting off the interrupt we can be guarenteed that the interrupt can't not be called
  // during our comparison and any newly added messages will get sent
  dsPIC33_CAN_TXBufferInterrupt(False);

  // If the CAN_Engine is not transmitting we need to start the transmission of any
  // messages in the buffer list.  If it is already running then the interrupt that
  // is called after the current message is finished will auto load any new messages
  if CAN_Engine.State and CES_TRANSMITTING = 0 then
    StartTransmission;

  // Re-enable the Transmit interrupt
  dsPIC33_CAN_TXBufferInterrupt(True);
end;


procedure Interrupt_CAN_Event(); iv IVT_ADDR_C1INTERRUPT; ics ICS_AUTO;
var
  TargetList: PCANRawBufferList;
begin
  dsPIC33_CAN_GlobalInterruptFlagCAN_Event(True);                               // Reset the Global CAN Event Interrupt Flag

  while dsPIC33_CAN_InterruptCode <> ICODE_NO_INTERRUPT do                      // Use the Interrupt Code to decode the Events that are both Enabled and Flags are set
  begin
    case dsPIC33_CAN_InterruptCode of
      ICODE_TRB0 :
      begin
        dsPIC33_CAN_InterruptFlagTXBuffer(True);                                // TX Interrupt Flag Reset
        if not StartTransmission then
          CAN_Engine.State := CAN_Engine.State and not CES_TRANSMITTING;
      end;
      ICODE_TRB1 :
      begin
        // CAN Layer Reception
        dsPIC33_CAN_InterruptFlagRXBuffer(True);                                // RX Interrupt Flag Reset
        case Hi(RX_Main_RawBufferArray[0].Word7) of
          0: ReceivedOnFilter0(@RX_Main_RawBufferArray[0]);
          1: ReceivedOnFilter1(@RX_Main_RawBufferArray[0]);
          2: ReceivedOnFilter2(@RX_Main_RawBufferArray[0]);
          3: ReceivedOnFilter3(@RX_Main_RawBufferArray[0]);
          4: ReceivedOnFilter4(@RX_Main_RawBufferArray[0]);
          5: ReceivedOnFilter5(@RX_Main_RawBufferArray[0]);
          6: ReceivedOnFilter6(@RX_Main_RawBufferArray[0]);
        end;
        dsPIC33_DMA_AddressOffsetA(1, @RX_Main_RawBufferArray[0]);              // Point the Receive Buffer Offset
        dsPIC33_CAN_RX_Full(1, True);                                           // Reset the Full Flag
      end;
    end
  end;
end;

end.