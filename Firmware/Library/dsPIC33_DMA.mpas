unit dsPIC33_DMA;

const
  ADDRESS_MODE_REG_INDIRECT_POST_INCREMENT    = 0;
  ADDRESS_MODE_REG_INDIRECT_NO_POST_INCREMENT = 1;
  ADDRESS_MODE_PERIPHERAL_INDIRECT            = 2;
  
  OPERATING_MODE_CONTINIOUS                   = 0;
  OPERATING_MODE_ONESHOT                      = 1;
  OPERATING_MODE_CONTINIOUS_PINGPONG          = 2;
  OPERATING_MODE_ONESHOT_PINGPONG             = 3;
  
  DATASIZE_BYTE                               = 0;
  DATASIZE_WORD                               = 1;
  
  DIRECTION_RAM_TO_PERIPHERAL                 = 0;
  DIRECTION_PERIPHERAL_TO_RAM                 = 1;
  
  IRQ_INT0_EXTERNAL                    = 0;
  IRQ_IC1_INPUT_CAPTURE                = 1;
  IRQ_OC1_OUTPUT_COMPARE_1             = 2;
  IRQ_IC2_INPUT_CAPTURE                = 5;
  IRQ_OC2_OUTPUT_COMARE_2              = 6;
  IRQ_TMR2_TIMER_2                     = 7;
  IRQ_TMR3_TIMER_3                     = 8;
  IRQ_SPI1                             = 10;
  IRQ_UART1_RX                         = 11;
  IRQ_UART1_TX                         = 12;
  IRQ_ADC1                             = 13;
  IRQ_ADC2                             = 21;
  IRQ_UART2_RX                         = 30;
  IRQ_UART2_TX                         = 31;
  IRQ_SPI2                             = 33;
  IRQ_ECAN1_RX_DATA_READY              = 34;
  IRQ_ECAN2_RX_DATA_READY              = 55;
  IRQ_DCI_CODEC_TRANSFER_DONE          = 60;
  IRQ_ECAN1_TX_DATA_READY              = 70;
  IRQ_ECAN2_TX_DATA_READY              = 71;
  
  // Current Register for Ping Pong mode, see dsPIC33_DMA_CurrentPingPongRegister
  PING_PONG_REG_A                      = 0;
  PING_PONG_REG_B                      = 1;
  
  NO_DMA_TRANSFER                      = $000F;
  

procedure dsPIC33_DMA_Enable(ChannelNumber: Word; Enable: Boolean);
procedure dsPIC33_DMA_DataSize(ChannelNumber: Word; _Size: Word);               // See DATASIZE_xxxx constants
procedure dsPIC33_DMA_Direction(ChannelNumber: Word; Direction: Word);          // See DIRECTION_xxxx constants
procedure dsPIC33_DMA_HalfBlockTransferInterrupt(ChannelNumber: Word; HalfBlockInterrupt: Boolean);
procedure dsPIC33_DMA_NullWrite(ChannelNumber: Word; Enable: Boolean);
procedure dsPIC33_DMA_AddressMode(ChannelNumber: Word; Mode: Word);             // See ADDRESS_MODE_xxxx constants
procedure dsPIC33_DMA_OperatingMode(ChannelNumber: Word; Mode: Word);           // See OPERATING_MODE_xxxx constants
procedure dsPIC33_DMA_InterruptSelect(ChannelNumber: Word; IRQ_Select: Word);   // See IRQ_xxxx constants
procedure dsPIC33_DMA_ManualDMATransfer(ChannelNumber: Word; Manual: Boolean);
procedure dsPIC33_DMA_AddressOffsetA(ChannelNumber: Word; Offset: Word);
procedure dsPIC33_DMA_AddressOffsetB(ChannelNumber: Word; Offset: Word);
procedure dsPIC33_DMA_PeripheralAddress(ChannelNumber: Word; Address: Word);
procedure dsPIC33_DMA_TransferCount(ChannelNumber: Word; Count: Word);          // 0 Counts!  An 8 Bit transfer = 7 in this register
function dsPIC33_DMA_MostRecentRAM_Address: Word;
function dsPIC33_DMA_PeripheralWriteCollisionDetected(ChannelNumber: Word): Boolean;
function dsPIC33_DMA_DSPRAMWriteCollisionDetected(ChannelNumber: Word): Boolean;
function dsPIC33_DMA_CurrentPingPongRegister(ChannelNumber: Word): Word;        // See PING_PONG_xxxx constants
function dsPIC33_DMA_LastActiveChannel: Word;


implementation

function MapToChannelReg(ChannelNumber: Word; Channel_0_Reg: ^Word): ^Word;
begin
  Result := Channel_0_Reg;
  Result := Result + (6 * ChannelNumber);
end;

procedure dsPIC33_DMA_Enable(ChannelNumber: Word; Enable: Boolean);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  if Enable then
    RegPtr^.CHEN := 1
  else
    RegPtr^.CHEN := 0
end;

procedure dsPIC33_DMA_DataSize(ChannelNumber: Word; _Size: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  if _Size = DATASIZE_BYTE then
    RegPtr^.SIZE := 1
  else
    RegPtr^.SIZE := 0
end;

procedure dsPIC33_DMA_Direction(ChannelNumber: Word; Direction: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  if Direction = DIRECTION_RAM_TO_PERIPHERAL then
    RegPtr^.DIR_ := 1
  else
    RegPtr^.DIR_ := 0
end;

procedure dsPIC33_DMA_HalfBlockTransferInterrupt(ChannelNumber: Word; HalfBlockInterrupt: Boolean);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  if HalfBlockInterrupt then
    RegPtr^.HALF := 1
  else
    RegPtr^.HALF := 0
end;

procedure dsPIC33_DMA_NullWrite(ChannelNumber: Word; Enable: Boolean);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  if Enable then
    RegPtr^.NULLW := 1
  else
    RegPtr^.NULLW := 0
end;

procedure dsPIC33_DMA_AddressMode(ChannelNumber: Word; Mode: Word);             // See ADDRESS_MODE_xxxx constants
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  RegPtr^ := RegPtr^ and $FFCF;                                                 // Clear the Address Mode Bits
  RegPtr^ := RegPtr^ or (Mode shl 4);
end;

procedure dsPIC33_DMA_OperatingMode(ChannelNumber: Word; Mode: Word);           // See OPERATING_MODE_xxxx constants
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  RegPtr^ := RegPtr^ and $FFFC;                                                 // Clear the Address Mode Bits
  RegPtr^ := RegPtr^ or Mode;
end;

procedure dsPIC33_DMA_InterruptSelect(ChannelNumber: Word; IRQ_Select: Word);  // See IRQ_xxxx constants
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0REQ);
  RegPtr^ := RegPtr^ and $FF80;                                                 // Clear the bottom 6 bits
  RegPtr^ := RegPtr^ or IRQ_Select
end;

procedure dsPIC33_DMA_ManualDMATransfer(ChannelNumber: Word; Manual: Boolean);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0REQ);
  if Manual then
    RegPtr^.FORCE := 1
  else
    RegPtr^.FORCE := 0
end;

procedure dsPIC33_DMA_AddressOffsetA(ChannelNumber: Word; Offset: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0STA);
  RegPtr^ := Offset
end;

procedure dsPIC33_DMA_AddressOffsetB(ChannelNumber: Word; Offset: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0STB);
  RegPtr^ := Offset
end;

procedure dsPIC33_DMA_PeripheralAddress(ChannelNumber: Word; Address: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0PAD);
  RegPtr^ := Address
end;

procedure dsPIC33_DMA_TransferCount(ChannelNumber: Word; Count: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CNT);
  RegPtr^ := Count - 1                                                          // 0 Counts!  An 8 Bit transfer = 7 in this register
end;

function dsPIC33_DMA_MostRecentRAM_Address: Word;
begin
  Result := DSADR
end;

function dsPIC33_DMA_PeripheralWriteCollisionDetected(ChannelNumber: Word): Boolean;
begin
  Result := DMACS0.ChannelNumber = 1
end;

function dsPIC33_DMA_DSPRAMWriteCollisionDetected(ChannelNumber: Word): Boolean;
var
  Offset: Word;
begin
  Offset := ChannelNumber + 8;
  Result := DMACS0.Offset = 1
end;

function dsPIC33_DMA_CurrentPingPongRegister(ChannelNumber: Word): Word;        // See PING_PONG_xxxx constants
begin
  if DMACS1.ChannelNumber = 1 then
    Result := PING_PONG_REG_B
  else
    Result := PING_PONG_REG_A
end;

function dsPIC33_DMA_LastActiveChannel: Word;
begin
  Result := (DMACS1 and $0F00) shr 8;
  // If No DMA transfer has occured sent system reset then return NO_DMA_TRANSFER
end;

end.