unit dsPIC33_DMA;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-04-01:   1.0.0.0 Created
//
// * Description:
//    Implements an easy to use interface into the dsPIC33 DMA Registers
//
// ******************************************************************************

const
  ADDRESS_MODE_REG_INDIRECT_POST_INCREMENT    = 0;
  ADDRESS_MODE_REG_INDIRECT_NO_POST_INCREMENT = 1;
  ADDRESS_MODE_PERIPHERAL_INDIRECT            = 2;
  
  OPERATING_MODE_CONTINIOUS                   = 0;
  OPERATING_MODE_ONESHOT                      = 1;
  OPERATING_MODE_CONTINIOUS_PINGPONG          = 2;
  OPERATING_MODE_ONESHOT_PINGPONG             = 3;
  
  DATASIZE_BYTE                               = 0;
  DATASIZE_WORD                               = 1;
  
  DIRECTION_RAM_TO_PERIPHERAL                 = 0;
  DIRECTION_PERIPHERAL_TO_RAM                 = 1;
  
  IRQ_INT0_EXTERNAL                    = 0;
  IRQ_IC1_INPUT_CAPTURE                = 1;
  IRQ_OC1_OUTPUT_COMPARE_1             = 2;
  IRQ_IC2_INPUT_CAPTURE                = 5;
  IRQ_OC2_OUTPUT_COMARE_2              = 6;
  IRQ_TMR2_TIMER_2                     = 7;
  IRQ_TMR3_TIMER_3                     = 8;
  IRQ_SPI1                             = 10;
  IRQ_UART1_RX                         = 11;
  IRQ_UART1_TX                         = 12;
  IRQ_ADC1                             = 13;
  IRQ_ADC2                             = 21;
  IRQ_UART2_RX                         = 30;
  IRQ_UART2_TX                         = 31;
  IRQ_SPI2                             = 33;
  IRQ_ECAN1_RX_DATA_READY              = 34;
  IRQ_ECAN2_RX_DATA_READY              = 55;
  IRQ_DCI_CODEC_TRANSFER_DONE          = 60;
  IRQ_ECAN1_TX_DATA_READY              = 70;
  IRQ_ECAN2_TX_DATA_READY              = 71;
  
  // Current Register for Ping Pong mode, see dsPIC33_DMA_CurrentPingPongRegister
  PING_PONG_REG_A                      = 0;
  PING_PONG_REG_B                      = 1;
  
  NO_DMA_TRANSFER                      = $000F;
  

procedure dsPIC33_DMA_Enable(ChannelNumber: Word; Enable: Boolean);
procedure dsPIC33_DMA_DataSize(ChannelNumber: Word; _Size: Word);               // See DATASIZE_xxxx constants
procedure dsPIC33_DMA_Direction(ChannelNumber: Word; Direction: Word);          // See DIRECTION_xxxx constants
procedure dsPIC33_DMA_HalfBlockTransferInterrupt(ChannelNumber: Word; HalfBlockInterrupt: Boolean);
procedure dsPIC33_DMA_NullWrite(ChannelNumber: Word; Enable: Boolean);
procedure dsPIC33_DMA_AddressMode(ChannelNumber: Word; Mode: Word);             // See ADDRESS_MODE_xxxx constants
procedure dsPIC33_DMA_OperatingMode(ChannelNumber: Word; Mode: Word);           // See OPERATING_MODE_xxxx constants
procedure dsPIC33_DMA_InterruptSelect(ChannelNumber: Word; IRQ_Select: Word);   // See IRQ_xxxx constants
procedure dsPIC33_DMA_ManualDMATransfer(ChannelNumber: Word; Manual: Boolean);
procedure dsPIC33_DMA_AddressOffsetA(ChannelNumber: Word; Offset: Word);
procedure dsPIC33_DMA_AddressOffsetB(ChannelNumber: Word; Offset: Word);
procedure dsPIC33_DMA_PeripheralAddress(ChannelNumber: Word; Address: Word);
procedure dsPIC33_DMA_TransferCount(ChannelNumber: Word; Count: Word);          // 0 Counts!  An 8 Bit transfer = 7 in this register
function dsPIC33_DMA_MostRecentRAM_Address: Word;
function dsPIC33_DMA_PeripheralWriteCollisionDetected(ChannelNumber: Word): Boolean;
function dsPIC33_DMA_DSPRAMWriteCollisionDetected(ChannelNumber: Word): Boolean;
function dsPIC33_DMA_CurrentPingPongRegister(ChannelNumber: Word): Word;        // See PING_PONG_xxxx constants
function dsPIC33_DMA_LastActiveChannel: Word;


implementation

// *****************************************************************************
//  procedure MapToChannelReg;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Channel_0_Reg:  A pointer to the Register to access but referenced
//                              to Channel 0. For example DMAxCON, DMAxIRQ, DMAxSTA, 
//                              DMAxSTB, etc.  The Channel Number will offset it
//                              to the correct pointer for that channel
//
//  Result:                     A pointer to the same register but offset for the
//                              passed Channel
//
//  Description:
// *****************************************************************************
function MapToChannelReg(ChannelNumber: Word; Channel_0_Reg: ^Word): ^Word;
begin
  Result := Channel_0_Reg;
  Result := Result + (6 * ChannelNumber);
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_Enable;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Enable       :  Enable/Disable the Channel
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure dsPIC33_DMA_Enable(ChannelNumber: Word; Enable: Boolean);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  if Enable then
    RegPtr^.CHEN := 1
  else
    RegPtr^.CHEN := 0
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_DataSize;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              _Size        :  Byte or Word transfers, see the DATASIZE_xxxx constants
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure dsPIC33_DMA_DataSize(ChannelNumber: Word; _Size: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  if _Size = DATASIZE_BYTE then
    RegPtr^.SIZE := 1
  else
    RegPtr^.SIZE := 0
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_Direction;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              _Size        :  Transfer is from Memory to Peripheral or vise-versa
//                              see the DIRECTION_xxxx constants
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure dsPIC33_DMA_Direction(ChannelNumber: Word; Direction: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  if Direction = DIRECTION_RAM_TO_PERIPHERAL then
    RegPtr^.DIR_ := 1
  else
    RegPtr^.DIR_ := 0
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_HalfBlockTransferInterrupt;
//
//  Parameters: ChannelNumber      :  The Channel to work on (0..7)
//              HalfBlockInterrupt :  Fire the DMA Interrupt when half the data is
//                                    moved or wait until all the data is moved
//                                    See the Datasheet for tricks to fire it at
//                                    both events (set to False within the interrupt
//                                    that fired at half)
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure dsPIC33_DMA_HalfBlockTransferInterrupt(ChannelNumber: Word; HalfBlockInterrupt: Boolean);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  if HalfBlockInterrupt then
    RegPtr^.HALF := 1
  else
    RegPtr^.HALF := 0
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_NullWrite;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Enable       :  Enabled Null Write, see the datasheet for more details
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure dsPIC33_DMA_NullWrite(ChannelNumber: Word; Enable: Boolean);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  if Enable then
    RegPtr^.NULLW := 1
  else
    RegPtr^.NULLW := 0
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_AddressMode;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Mode         :  Sets the Address Mode for the Channel, See ADDRESS_MODE_xxxx constants
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure dsPIC33_DMA_AddressMode(ChannelNumber: Word; Mode: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  RegPtr^ := RegPtr^ and $FFCF;                                                 // Clear the Address Mode Bits
  RegPtr^ := RegPtr^ or (Mode shl 4);
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_OperatingMode;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Mode         :  Sets the Operating Mode for the Channel, See OPERATING_MODE_xxxx constants
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure dsPIC33_DMA_OperatingMode(ChannelNumber: Word; Mode: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CON);
  RegPtr^ := RegPtr^ and $FFFC;                                                 // Clear the Operating Mode Bits
  RegPtr^ := RegPtr^ or Mode;
end;


// *****************************************************************************
//  procedure dsPIC33_DMA_InterruptSelect;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Mode         :  Sets the Interrupt for the Channel, See IRQ_xxxx constants
//
//  Result:
//
//  Description: NOTE: This MUST be set in order to trigger the transfer from the Peripheral
// *****************************************************************************
procedure dsPIC33_DMA_InterruptSelect(ChannelNumber: Word; IRQ_Select: Word);  // See IRQ_xxxx constants
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0REQ);
  RegPtr^ := RegPtr^ and $FF80;                                                 // Clear the bottom 6 bits
  RegPtr^ := RegPtr^ or IRQ_Select
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_ManualDMATransfer;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Manual       :  Must Manually start a transfer in code, see the datasheet
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure dsPIC33_DMA_ManualDMATransfer(ChannelNumber: Word; Manual: Boolean);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0REQ);
  if Manual then
    RegPtr^.FORCE := 1
  else
    RegPtr^.FORCE := 0
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_AddressOffsetA;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Offset       :  Offset from the beginning of DSPRAM to make the transfer from
//
//  Result:
//
//  Description: NOTE: Usage depend on the Operating Mode
// *****************************************************************************
procedure dsPIC33_DMA_AddressOffsetA(ChannelNumber: Word; Offset: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0STA);
  RegPtr^ := Offset
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_AddressOffsetA;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Offset       :  Offset from the beginning of DSPRAM to make the transfer from
//
//  Result:
//
//  Description: NOTE: Usage depend on the Operating Mode, mostly used with Ping-Pong Mode
// *****************************************************************************
procedure dsPIC33_DMA_AddressOffsetB(ChannelNumber: Word; Offset: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0STB);
  RegPtr^ := Offset
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_PeripheralAddress;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Address      :  Address of the special register within the Peripheral where
//                              the source or target register is.  The DMA moves
//                              data from the DSPRAM to and from this special register in
//                              the assigned Peripheral
//
//  Result:
//
//  Description: NOTE: Usage depend on the Peripheral
// *****************************************************************************
procedure dsPIC33_DMA_PeripheralAddress(ChannelNumber: Word; Address: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0PAD);
  RegPtr^ := Address
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_TransferCount;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//              Count        :  The number of Bytes or Words (depending on dsPIC33_DMA_DataSize)
//                              that are moved in a transfer cycle. Depends on the Peripheral.
//
//  Result:
//
//  Description: NOTE:  This is zero indexed so 0 counts as one transfer. This
//                      function accounts for that so if you need 8 Words moved
//                      in Word Size then pass an 8 to this function.  It will offset
//                      it by 1 to account for the 0 counting as a data transfer
// *****************************************************************************
procedure dsPIC33_DMA_TransferCount(ChannelNumber: Word; Count: Word);
var
  RegPtr: ^Word;
begin
  RegPtr := MapToChannelReg(ChannelNumber, @DMA0CNT);
  RegPtr^ := Count - 1                                                          // 0 Counts!  An 8 Bit transfer = 7 in this register
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_MostRecentRAM_Address;
//
//  Parameters:
//
//  Result:    The address of the most recent data transfer byte or word depending on
//             dsPIC33_DMA_DataSize
//
//  Description:
// *****************************************************************************
function dsPIC33_DMA_MostRecentRAM_Address: Word;
begin
  Result := DSADR
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_PeripheralWriteCollisionDetected;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//
//  Result:    True if a Write Collision was detected.  See the datasheet for the
//             definintion of a collision
//
//  Description:
// *****************************************************************************
function dsPIC33_DMA_PeripheralWriteCollisionDetected(ChannelNumber: Word): Boolean;
begin
  Result := DMACS0.ChannelNumber = 1
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_DSPRAMWriteCollisionDetected;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//
//  Result:    True if a Write Collision was detected.  See the datasheet for the
//             definintion of a collision
//
//  Description:
// *****************************************************************************
function dsPIC33_DMA_DSPRAMWriteCollisionDetected(ChannelNumber: Word): Boolean;
var
  Offset: Word;
begin
  Offset := ChannelNumber + 8;
  Result := DMACS0.Offset = 1
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_CurrentPingPongRegister;
//
//  Parameters: ChannelNumber:  The Channel to work on (0..7)
//
//  Result:    The current Register that being used accessed, see the PING_PONG_xxxx constants
//
//  Description: Only used for Ping-Pong mode.  The software can access the buffer
//               that is not returned from the is function
// *****************************************************************************
function dsPIC33_DMA_CurrentPingPongRegister(ChannelNumber: Word): Word;
begin
  if DMACS1.ChannelNumber = 1 then
    Result := PING_PONG_REG_B
  else
    Result := PING_PONG_REG_A
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_LastActiveChannel;
//
//  Parameters:
//
//  Result:   The last Active Channel (0..7) that had a data transfer
//
//  Description: If No DMA transfer has occured sent system reset then return NO_DMA_TRANSFER
// *****************************************************************************
function dsPIC33_DMA_LastActiveChannel: Word;
begin
  Result := (DMACS1 and $0F00) shr 8;
  //
end;

end.