unit NMRABusXpressnet;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2011.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2010-11-24:   Created
//
// * Description:
//    Implements the DCC Signal that is to be placed on the track, sent to the
//  accessory DCC bus, or the programming track
//
// TODO:
//     - StopAllLocomotivesRequest need to be tested
//     - DirectModeReadRequest not complete
//
// ******************************************************************************



{$I Options.inc}

uses
 // AddressSlots,
  NMRABusXpressNetConstants; //,
 // NMRA_DCC,
  //SPI_Interface,
 // HelperFunctions,
 // ServiceMode,
 // CommandStation;

const
  VERSION_SOFTWARE_PC_INERFACE = %00000001;  // Software version 1
  VERSION_HARDWARE_PC_INERFACE = %00010000;  // Hardware version 1.0
  VERSION_SOFTWARE_XPRESSNET   = $36;        // Version 3.6 Compatible
  VERSION_COMMANDSTATION_LZ100 = $00;        // LZ 100 - command station
  VERSION_COMMANDSTATION_LH200 = $01;        // LH 200 - command station
  VERSION_COMMANDSTATION_DPC   = $02;        // DPC - command station (Compact and COMM other)
  
  BAUD_RATE_XPRESSNET_PC_INTERFACE_19200  = $01;   // This is NOT the baud rate that is set, it is the buad rate reported by the Command Station
  BAUD_RATE_XPRESSNET_PC_INTERFACE_38400  = $02;
  BAUD_RATE_XPRESSNET_PC_INTERFACE_57600  = $03;
  BAUD_RATE_XPRESSNET_PC_INTERFACE_115200 = $04;

  STATE_RS232_READ_HEADER_BYTE  = 0;  // State machine states for the RS232 receiver
  STATE_RS232_READ_MESSAGE_BYTE = 1;
  STATE_RS232_READ_XOR_BYTE     = 2;
  STATE_RS232_FULL              = 3;
  
  BRG_EXPRESSNET_62500 = 19;       // 0.00% error with 80Mhz Clock

  SERVICE_MODE_STATE_MACHINE_TIME = 1560; // prescaler = 64, 80Mhz clock = 64/(80Mhz/4) * 1560 = 5ms

// Call once on start up
procedure XpressNet_Initialize;
// Starts the inquiry of a Device on the Xpressbus, call repeatedly to keep the bus active
//   Will complete the entire CallByte/Response Window/Device Inquiry/Response cycle before returning
procedure XpressNet_SendNextNormalInquiryAndDispatch;
// If an error occurs (XOR incorrect, etc) the master will request an Acknowlegement from the device that sent it
procedure XpressNet_RequestAcknowledgment;
// Handles the PC RS232/USB interface.  UARTS have a 4 byte stack so must call this faster than a few bytes time at the data rate
procedure XpressNet_CheckForRS232DataAndDispatch;
// Call every 840ms to handle Hung Bus and Device Reply Window Timeouts
procedure XpressNet_840ms_TimeTick; forward;
// Add runs the RX state machine to receive messages without blocking program execution
procedure XpressNet_UART_RX_StateMachine(XpressNetBuffer: PXpressNetInfo; XpressNetMessage: PXpressNetMessage; ReceivedByte: Byte; IsPC: Boolean); forward;
// Sets Clear the CTS line for the PC UART
procedure XpressNet_CTS(Enabled: Boolean); forward;
// Dispatches the Service Mode Results if they are ready to the
procedure XpressNet_HandleServiceModeAndResults; forward;
// Used to call a Xpressnet message directly
procedure XpressNet_HandleDeviceInstruction(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
// Sends PC a message on the UART
//procedure Send_PCMessage(MessageID: Byte);



function MapSpeedDir(FromSpeedStep, ToSpeedStep, NMRA_SpeedDir: Byte): Byte;  // TEMPORARY

var
  UART_PC_CTS                         : sbit; sfr; external;
  UART_PC_CTS_Direction               : sbit; sfr; external;
  Xpressnet_RS485_Select              : sbit; sfr; external;
  Xpressnet_RS485_Select_Direction    : sbit; sfr; external;

implementation

procedure SendXpressNetMessage(XpressNetMessage: PXpressNetMessage; Command: Byte; iDevice: Byte); forward;
procedure Broadcast_XpressNetMessage(XpressNetMessage: PXpressNetMessage; Command: Byte); forward;
procedure Send_EnterServiceMode(iDevice: Byte; Broadcast: Boolean); forward;
procedure DispatchServiceModeResultsRequest(iDevice: Byte); forward;
//procedure Send_LocomotiveBeingOperatedByAnotherDevice(Slot: PAddressSlot); forward;
//procedure Send_PCMessage(MessageID: Byte); forward;

// *****************************************************************************
//
// procedure XpressNet_InitializeBuffers;
//
//  Parameters:
//                Buffer: PXpressNetMessage;
//  Returns:
//                None
//  Description:
//              Called from the initialization code to initialize the data structures
//    used in the unit
//
// *****************************************************************************
procedure XpressNet_InitializeBuffers(Buffer: PXpressNetMessage);
var
  i: Integer;
begin
  for i := 0 to XPRESSNET_MAX_DATA_BYTE - 1 do
    Buffer^.Bytes[i] := 0;
  Buffer^.Instruction := 0;
  Buffer^.DataCount := 0;
  Buffer^.MessageReadResult := 0;
  Buffer^.CallByte := 0;
  Buffer^.HeaderByte := 0;
  Buffer^.StateMachineIndex  := STATE_RS232_READ_HEADER_BYTE;
  Buffer^.StateMachineIndexDataByte := 0;
end;

// *****************************************************************************
//
// procedure XpressNet_Initialize;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Called from the initialization code to initialize the data structures
//    used in the unit
//
// *****************************************************************************
procedure XpressNet_Initialize;
begin
  XpressNetBuffer.iActiveDevice := ID_NO_DEVICE;                   // Start with the No DeviceID
  XpressNetBuffer.DeviceDiscoveryTimerCount := REDISCOVERY_TIME;   // Re-Discover at startup
  XpressNet_CTS(False);
//  XpressNet_InitializeBuffers(@XpressNetBuffer.RS232Data);
  XpressNet_InitializeBuffers(@XpressNetBuffer.XpressNetData);
//  XpressNet_InitializeBuffers(@XpressNetBuffer.RS232DataBuffer);
  XpressNetBuffer.Flags := 0;
  Xpressnet_RS485_Select          := 0;
  Xpressnet_RS485_Select_Direction := 0;      // Output
  XpressNetBuffer.Watchdog_Count_XpressNet_Bus := 0;
  XpressNetBuffer.Watchdog_Count_PC_Bus := 0;
end;

// *****************************************************************************
//
// procedure XpressNet_840ms_TimeTick;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Updates internal flags to track for various timeout conditions
//    mainly for the bus
//
// *****************************************************************************
procedure XpressNet_840ms_TimeTick;
begin
   // Count up to the time out then freeze.  The Timer Count will be reset after the
  // main loop is done rediscovering
  if XpressNetBuffer.DeviceDiscoveryTimerCount < REDISCOVERY_TIME then
    Inc(XpressNetBuffer.DeviceDiscoveryTimerCount);

  // Count up to the hung time then freeze.  Once Hung it is hung until the next
  // device ID is queried and it is reset
  if XpressNetBuffer.Watchdog_Count_XpressNet_Bus < XPRESSNET_BUS_HUNG_COUNT then
    Inc(XpressNetBuffer.Watchdog_Count_XpressNet_Bus);

  // Count up to the hung time then freeze.  Once Hung it is hung until the next
  // PC time slot is sampled and it is reset
  if XpressNetBuffer.Flags.MASK_XPRESSNET_PC_COMMUNICATING_BIT = 1 then
  begin
    if XpressNetBuffer.Watchdog_Count_PC_Bus < XPRESSNET_PC_HUNG_COUNT then
      Inc(XpressNetBuffer.Watchdog_Count_PC_Bus);
  end;
end;

// *****************************************************************************
//
// procedure Send_PoM_Message;
//
//  Parameters:
//                AddressLo, AddressHi:  The NMRA Encoded Address Bytes to send the message too
//                XpressNetMessage:   Raw NMRA message sent in the Xpressnet Message
//
//  Returns:
//                None
// *****************************************************************************
procedure Send_PoM_Message(AddressHi, AddressLo: Byte; XpressNetMessage: PXpressNetMessage);
{var
  NewDCCMessage: TDCCQueueMessage;
  i: Integer; ]     }
begin
 { // XpressNet Message match up with NMRA DCC Messages so just relay them
  if AddressHi = 0 then        // It is a short basic message
     NMRA_DCC_LoadMessage(@NewDCCMessage, AddressLo, XpressNetMessage^.Bytes[3] ,XpressNetMessage^.Bytes[4], XpressNetMessage^.Bytes[5], 0, 4)
  else                         // It is an advanced operations (long address) message
     NMRA_DCC_LoadMessage(@NewDCCMessage, AddressHi, AddressLo, XpressNetMessage^.Bytes[3] ,XpressNetMessage^.Bytes[4], XpressNetMessage^.Bytes[5], 5);

  for i := 0 to POM_MESSAGE_REPEAT_COUNT - 1 do
    while not NMRA_DCC_QueueMessage(@Track, @NewDCCMessage, True) do  }
end;

// *****************************************************************************
//
// procedure XpressNet_UART_RX_StateMachine;
//
//  Parameters:
//                XpressNetMessage:   The Message to work on
//                ReceivedByte:       The new Byte received by the UART
//                IsPCMessage:        The Message is from the PC so we need to handle the CTS line
//
//  Returns:
//                None
//  Description:
//              Updates internal flags to track for various timeout conditions
//    mainly for the bus
//
//  WARNING:  This is called from the XPRESSNET_UART_RX_Interrupt and the
//            XPRESSNET_UART_RX_Interrupt so make sure anything done is "ThreadSafe"
//
// *****************************************************************************
procedure XpressNet_UART_RX_StateMachine(XpressNetBuffer: PXpressNetInfo; XpressNetMessage: PXpressNetMessage; ReceivedByte: Byte; IsPC: Boolean);
var
  Error: Byte;
  i: Integer;
begin
  case XpressNetMessage^.StateMachineIndex of
    STATE_RS232_READ_HEADER_BYTE :
      begin
        if IsPC then
        begin
          XpressNetBuffer^.Watchdog_Count_PC_Bus := 0;                       // Reset the PC BUS Hung count
          XpressNetBuffer^.Flags.MASK_XPRESSNET_PC_COMMUNICATING_BIT := 1;   // We are communicating with the PC
        end;
          
        XpressNetMessage^.DataCount := ReceivedByte and $0F;         // Use only the lower nibble for the count
        XpressNetMessage^.Instruction := ReceivedByte and $F0;       // Strip off the Data Count in the lower nibble

        XpressNetMessage^.StateMachineIndexDataByte := 0;
        if XpressNetMessage^.DataCount = 0 then                      // If the count is 0 then jump to the XOR byte state
          XpressNetMessage^.StateMachineIndex := STATE_RS232_READ_XOR_BYTE
        else
          Inc(XpressNetMessage^.StateMachineIndex)
      end;
    STATE_RS232_READ_MESSAGE_BYTE :
      begin
        XpressNetMessage^.Bytes[XpressNetMessage^.StateMachineIndexDataByte] := ReceivedByte;
        Inc(XpressNetMessage^.StateMachineIndexDataByte);
        if XpressNetMessage^.StateMachineIndexDataByte >= XpressNetMessage^.DataCount then  // Test to see if we are done reading
        begin
          Inc(XpressNetMessage^.StateMachineIndex)
        end;
      end;
    STATE_RS232_READ_XOR_BYTE :
      begin
        if IsPC then
        begin
          XpressNet_CTS(False);    // Stop the next byte.
          XpressNetBuffer^.Flags.MASK_XPRESSNET_PC_COMMUNICATING_BIT := 0;   // Is a bit of a race here but if that timeout occurs the bus is likely hung anyway
        end;
        Error := XpressNetMessage^.DataCount or XpressNetMessage^.Instruction; // Reconstruct the Header Byte
        for i := 0 to XpressNetMessage^.DataCount - 1 do
          Error := Error xor XpressNetMessage^.Bytes[i];
        if Error = ReceivedByte then
          XpressNetMessage^.MessageReadResult := E_SUCCESS
        else
          XpressNetMessage^.MessageReadResult := E_TRANSFER_XOR;                       // We are full move to Full State
        Inc(XpressNetMessage^.StateMachineIndex)
      end;
    STATE_RS232_FULL :
      begin                                                                            // Spin here until the system resets the statemachine

      end;
  end
end;

// *****************************************************************************
//
// function XpressNet_CTS;
//
//  Parameters:
//                Enable:     Enables/Disables the Clear To Send line to the PC
//
//  Returns:
//                None
//
//  Description:
//
// *****************************************************************************
procedure XpressNet_CTS(Enabled: Boolean);
begin
  if Enabled then
    UART_PC_CTS := 0
  else
    UART_PC_CTS := 1
end;


// *****************************************************************************
//
// procedure XpressNet_CheckForRS232Data;
//
//  Parameters:
//                None
//
//  Returns:
//                E_xxxx Error Code
//
//  Description:
//                Reads the RS232 bus for the PC.  Replaces the LI100, LI100F, LI101 and
//    adds PC inteface directly in to the Instruction station without using a device address
//
// *****************************************************************************
procedure XpressNet_CheckForRS232DataAndDispatch;
begin
{  if XpressNetBuffer.Watchdog_Count_PC_Bus >= XPRESSNET_PC_HUNG_COUNT then
  begin
    XpressNetBuffer.Flags.MASK_XPRESSNET_PC_COMMUNICATING_BIT := 0;                     // Force the communiation to stop
    XpressNetBuffer.Watchdog_Count_PC_Bus := 0;                                         // Reset the PC BUS Hung count
    XpressNetBuffer.RS232Data.StateMachineIndex := STATE_RS232_READ_HEADER_BYTE;        // Reset the StateMachine to state 0
    XpressNetBuffer.RS232DataBuffer.StateMachineIndex := STATE_RS232_READ_HEADER_BYTE;  // Reset the StateMachine to state 0
    XpressNet_CTS(True);                                                                // Allow the PC to send the next byte
  end
  else begin
    if XpressNetBuffer.RS232Data.StateMachineIndex >= STATE_RS232_FULL then
    begin
      case XpressNetBuffer.RS232Data.MessageReadResult of
        E_SUCCESS : XpressNet_HandleDeviceInstruction(@XpressNetBuffer.RS232Data, ID_PC_DEVICE);
        E_TRANSFER_XOR : Send_PCMessage(E_PC_COMMUNICATION);
      end;
      XpressNetBuffer.RS232Data.StateMachineIndex := STATE_RS232_READ_HEADER_BYTE;                      // Reset the StateMachine to state 0
      XpressNet_CTS(True);                                                                              // Ready for the next Message
    end
  end    }
end;

// *****************************************************************************
//
// function InsertHiBitParity(DataByte: Byte): Byte;
//
//  Parameters:
//                DataByte:  Byte to count '1's in
//
//  Returns:
//                DataByte with the parity bit (inclusive) in the MSB
//
//  Description:
//              Adds the parity bit to B7.  It is an inclusive parity only on
//  address bytes
//
// *****************************************************************************
function InsertHiBitParity(DataByte: Byte): Byte;
begin
  Result := 0;
  if DataByte.B0 then Inc(Result);
  if DataByte.B1 then Inc(Result);
  if DataByte.B2 then Inc(Result);
  if DataByte.B3 then Inc(Result);
  if DataByte.B4 then Inc(Result);
  if DataByte.B5 then Inc(Result);
  if DataByte.B6 then Inc(Result);
  // This is inclusive parity so if there are an even number of 1's (mod 2 = 0) then
  // adding the parity bit will make the number of 1's odd
  if Result mod 2 <> 0 then
    Result := DataByte or %10000000
  else
    Result := DataByte
end;

// *****************************************************************************
//
// procedure ExtractAddressFromXpressNetMessage
//
//   Parameters:
//              XpressNetMessage:  Message to extract the address from
//              iByteAH   :  Index into the array where the AH byte is
//              iByte2AL  :  Index into the array where the AL byte is
//
//   Returns:
//      The Address that was in the message
//
//  Description:
//                Extracts the address from the first two (or one if ShortAddress)
//    bytes of the XpressNet Message
//
// *****************************************************************************
function ExtractAddressFromXpressNetMessage(XpressNetMessage: PXpressNetMessage; iByteAH, iByte2AL: Byte): Word;
begin
  // Per 2.1.15 definition there is a break between 0-99 and 100-9999
  if (XpressNetMessage^.Bytes[iByteAH] = 0) and (XpressNetMessage^.Bytes[iByte2AL] <= MAX_XPRESSNET_SHORT_ADDRESS) then
    Result := XpressNetMessage^.Bytes[iByte2AL]
  else  begin
    Result := XpressNetMessage^.Bytes[iByteAH] and %00111111;
    Result := Result shl 8;
    Result := Result or XpressNetMessage^.Bytes[iByte2AL];
    Result := ((XpressNetMessage^.Bytes[iByteAH] and %00111111) shl 8) or XpressNetMessage^.Bytes[iByte2AL];
  end;
end;

{
// *****************************************************************************
//
// procedure IsMobileSlotStopped;
//
//   Parameters:
//                Slot:    Address Slot to test if the speed is zero (mobile decoder)
//
//   Returns:
//                True if the decoder is stopped
//
//  Description:
//                Checks the slots speed to see it the decoder is stopped.  It
//    includes emergency stop
//
// *****************************************************************************
function IsMobileSlotStopped(Slot: PAddressSlot): Boolean;
var
  BaseSpeed: Byte;
begin
  if Slot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_128_BIT = 1 then
    Result := ((Slot^.SpeedDir and $01111111) < 2)              // 0 = Stopped, 1 = Emergency Stop
  else begin
    BaseSpeed := Slot^.SpeedDir and %00011111;
    Result := (BaseSpeed < 2) or (BaseSpeed = %00010000) or (BaseSpeed = %00010001)    // 0 = Stopped, 1 = Emergency Stop for 14 step, 28 step could have bit 4 set as well
  end
end;
 }
 
// *****************************************************************************
//
// procedure WriteXpressNetByte(DataByte: Word; SetAddressBit: Boolean);
//
//   Parameters:
//              DataByte:      The Byte to send
//              SetAddressBit: True if the 9th bit should be set to signify it as an address
//
//   Returns:
//      None
//
//  Description:
//                The workhorse function that places the data onto the
//    UART Xpressnet bus RS485 but in RS232 format
//
// *****************************************************************************
procedure WriteXpressNetByte(DataByte: Word; SetAddressBit: Boolean; TxReg: ^Word; StatusReg: ^Word);
begin
  {$IFNDEF DISABLE_XPRESSNET_UART_WRITE}
  if SetAddressBit then
   DataByte := DataByte or $0100
  else
    DataByte := DataByte and $00FF;

  TxReg^ := DataByte;
  StatusReg^.UTXEN := 1;          // Force the Register in to the TSR so the Idle check is not "too fast" to start
  while StatusReg^.TRMT = 1 do;   // Wait for the UART to start transmitting
  while StatusReg^.TRMT = 0 do;   // Wait for the UART to finsh transmitting to make sure the ExpressNet timing is met
  {$ENDIF}
end;

// *****************************************************************************
//
// procedure WriteXpressNetMessage(MessageInfo: PXpressNetMessage; TxReg: PWord; StatusReg: PWord);
//
//  Parameters:
//             MessageInfo:       Tranmitter Data to send over the XPressNet bus
//             TxReg:             Pointer to the SFR of the Transmitter register for the desired UART
//             TxStaReg:          Pointer to the SFR of the Transmitter status register for the desired UART
//   Returns:
//             None
//
// Description:
//             Correctly formats the passed parameters and sends the entire
//  Reqeust packet to the device
//
//
// *****************************************************************************
procedure WriteXpressNetMessage(MessageInfo: PXpressNetMessage; TxReg: ^Word; StatusReg: ^Word);
var
  i: Integer;
  XorError: Byte;
begin
  if MessageInfo^.CallByte <> 0 then
    WriteXpressNetByte(MessageInfo^.CallByte, True, TxReg, StatusReg);     // Send the Call Byte if <> 0
  WriteXpressNetByte(MessageInfo^.HeaderByte, False, TxReg, StatusReg);    // Send the Header Byte
  XorError := MessageInfo^.HeaderByte;                                     // Start Calculating the Error Byte
  for i := 0 to MessageInfo^.DataCount - 1 do
  begin
    WriteXpressNetByte(MessageInfo^.Bytes[i], False, TxReg, StatusReg);
    XorError := XorError xor MessageInfo^.Bytes[i]
  end;
  WriteXpressNetByte(XorError, False, TxReg, StatusReg)
end;

// *****************************************************************************
//
// procedure ReadXpressNetBuss(XpressNetMessage: PXpressNetMessage; RXReg, StatusReg: PWord);
//
//   Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              RXStaReg:   Pointer to the UART RX Status register such as @U1STA or @U2STA

//   Returns:
//              One of the E_xxxx error codes
//
//  Description:
//              Reads the XpressNet bus from a device.  It has its own error checking
//  and will return an error code that corresponds to what error occured.  This function
//  is simply waiting for the UART RX interrupt to read the message.
//
// *****************************************************************************
procedure ReadXpressNetBuss(XpressNetMessage: PXpressNetMessage; StatusReg: ^Word);
begin
  XpressnetBuffer.Watchdog_Count_XpressNet_Bus := 0;                            // Clear Hung Counter
  XpressNetMessage^.StateMachineIndex := STATE_RS232_READ_HEADER_BYTE;          // Reset the RS232 RX statemachine

  XpressNetMessage^.MessageReadResult := E_WINDOW_TIMEOUT;                      // Assume a timeout
  Delay_us(120);
  if (StatusReg^.RIDLE = 0) or (StatusReg^.URXDA = 1) then                      // Detect a response on the buss
  begin
    while XpressnetBuffer.Watchdog_Count_XpressNet_Bus < XPRESSNET_BUS_HUNG_COUNT do    // Loop waiting for the full message to be recieved or the Hung Bus counter times out
    begin
      if XpressNetMessage^.StateMachineIndex = STATE_RS232_FULL then
      begin
        Delay_us(200);                                                          // Wait for the device to get the RS485 buffer turned around and ready for a receive
        Exit;
      end
    end;
    XpressNetMessage^.MessageReadResult := E_BUS_HUNG;                          // Detected at least one byte response but did not finish before the hung bus timed out
  end;
end;

// *****************************************************************************
//
// procedure SendXpressNetMessage(XpressNetMessage: PXpressNetMessage; Command: Byte; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              Command:    Upper new bits of the command (the lower bits are the number of bytes in the message)
//              iDevice:    The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//
// *****************************************************************************
procedure SendXpressNetMessage(XpressNetMessage: PXpressNetMessage; Command: Byte; iDevice: Byte);
var
  OldMode: bit;
begin
  if iDevice <> ID_PC_DEVICE then
  begin
    OldMode := Xpressnet_RS485_Select;
    Xpressnet_RS485_Select := 1;      // Select the 485 chip to transmit mode
    XpressNetMessage^.CallByte := InsertHiBitParity(Command or Byte( iDevice));   // Send Message to the Xpressnet UART
    WriteXpressNetMessage(XpressNetMessage, @U2TXREG, @U2STA);
    Delay_us(200);
    Xpressnet_RS485_Select := OldMode
  end else
  begin
    XpressNetMessage^.CallByte := 0;                                              // Very Important to strip the CallByte from the PC Packet, Send to the PC UART
    WriteXpressNetMessage(XpressNetMessage, @U1TXREG, @U1STA);
  end;
end;

// *****************************************************************************
//
// procedure Send_PCMessage;
//
//  Parameters:
//              MessageID: One of the E_PC_ERROR messages
//
//  Description:
//              Implements "1.5.2 Messages from the LI100" in the XpressNet spec
//
// *****************************************************************************
{procedure Send_PCMessage(MessageID: Byte);
var
  XpressNetMessage: TXpressNetMessage;
begin
  XpressNetMessage.CallByte := 0;                      // Very Important to strip the CallByte from the PC Packet
  XpressNetMessage.HeaderByte := %00000001;            // Send Ack to the PC if the Request does not need a response
  XpressNetMessage.Bytes[0] := MessageID;
  XpressNetMessage.DataCount := 1;
  WriteXpressNetMessage(@XpressNetMessage, @U1TXREG, @U1STA);
end;  }

// *****************************************************************************
//
// procedure Send_CommandStationBusy(iDevice: Byte);
//
//  Parameters:
//              iDevice:    ID of the XpressNet Device to send the message to
//
//  Description:
//              Implements "2.1.9 Command station busy response" in the XpressNet spec
//
// *****************************************************************************
procedure Send_CommandStationBusy(iDevice: Byte);
var
  XpressNetMessage: TXpressNetMessage;
begin
  XpressNetMessage.HeaderByte := %01100001;
  XpressNetMessage.Bytes[0] := %10000001;
  XpressNetMessage.DataCount := 1;
  SendXpressNetMessage(@XpressNetMessage, CALLBYTE_RESPONSE, iDevice);
end;

// *****************************************************************************
//
// procedure Send_EnterServiceMode(iDevice: Byte);
//
//  Parameters:
//              iDevice:    ID of the XpressNet Device to send the message to
//
//  Description:
//              Implements "2.1.9 Command station busy response" in the XpressNet spec
//
// *****************************************************************************
procedure Send_EnterServiceMode(iDevice: Byte; Broadcast: Boolean);
var
  XpressNetMessage: TXpressNetMessage;
begin
  XpressNetMessage.HeaderByte := %01100001;     // $61
  XpressNetMessage.Bytes[0] := %00000010;       // $02
  XpressNetMessage.DataCount := 1;
  if Broadcast then
    Broadcast_XpressNetMessage(@XpressNetMessage, CALLBYTE_BROADCAST)
  else
    SendXpressNetMessage(@XpressNetMessage, CALLBYTE_RESPONSE, iDevice);
end;

// *****************************************************************************
//
// procedure Send_InstructionNotSupported(iDevice: Byte);
//
//  Parameters:
//              iDevice:    ID of the XpressNet Device to send the message to
//
//  Description:
//              Implements "2.1.10 Instruction not supported by command station" in the XpressNet spec
//
// *****************************************************************************
procedure Send_InstructionNotSupported(iDevice: Byte);
var
  XpressNetMessage: TXpressNetMessage;
begin
  XpressNetMessage.HeaderByte := %01100001;            // $61
  XpressNetMessage.Bytes[0] := %10000010;              // $82
  XpressNetMessage.DataCount := 1;
  SendXpressNetMessage(@XpressNetMessage, CALLBYTE_RESPONSE, iDevice);
end;

{
// *****************************************************************************
//
// procedure Send_LocomotiveBeingOperatedByAnotherDevice;
//
//  Parameters:
//
//  Description:
//              Implements "2.1.15 Locomotive is being operated by another device response (XpressNet only)" in the XpressNet spec
//
// *****************************************************************************
procedure Send_LocomotiveBeingOperatedByAnotherDevice(Slot: PAddressSlot);
var
  XpressNetMessage: TXpressNetMessage;
  HiAddress, LoAddress: Byte;
begin
  if Slot^.OwnerDevice <> ID_NO_DEVICE then
  begin
    XpressNetMessage.HeaderByte := %11100011;            // $E3
    XpressNetMessage.Bytes[0]   := %01000000;            // $40
    HiAddress := 0;
    LoAddress := 0;
    AddressSlot_EncodeAddressToNMRA_Format(Slot, HiAddress, LoAddress, True);
//    AddressSlot_EncodeAddressToNMRA_Format(Slot, XpressNetMessage.Bytes[1], XpressNetMessage.Bytes[2]);    BUG in mPASCAL
    XpressNetMessage.Bytes[1] := HiAddress;
    XpressNetMessage.Bytes[2] := LoAddress;
    XpressNetMessage.DataCount := 3;
    SendXpressNetMessage(@XpressNetMessage, CALLBYTE_RESPONSE, Slot^.OwnerDevice);
  end
end;
}

// *****************************************************************************
//
// procedure Send_DoubleHeader_MU_Error;
//
//  Parameters:
//              iDevice:  The Device to send the message too
//              ErrorCode: Error code to send, see the E_DH_MU_ERROR_XXXX codes
//
//  Description:
//              Implements "2.1.15 Locomotive is being operated by another device response (XpressNet only)" in the XpressNet spec
//
// *****************************************************************************
procedure Send_DoubleHeader_MU_Error(iDevice: Byte; ErrorCode: Byte);
var
  XpressNetMessage: TXpressNetMessage;
begin
  XpressNetMessage.HeaderByte := %11100001;            // $E1
  XpressNetMessage.Bytes[0] := %10000000 or ErrorCode;
  XpressNetMessage.DataCount := 1;
  SendXpressNetMessage(@XpressNetMessage, CALLBYTE_RESPONSE, iDevice);
end;

{
// *****************************************************************************
//
// procedure Send_AddressRetrievalInfo;
//
//  Parameters:
//              iDevice:  The Device to send the message too
//              RequestInfo: Error code to send, see the ADDRESS_RETRIEVAL_XXXXX codes
//
//  Description:
//              Implements "2.1.15 Locomotive is being operated by another device response (XpressNet only)" in the XpressNet spec
//
// *****************************************************************************
procedure Send_AddressRetrievalInfo(iDevice: Byte; ASlot: PAddressSlot);
var
  XpressNetMessage: TXpressNetMessage;
  AddressHi, AddressLo, RequestInfo: Byte;
begin
  AddressHi := 0;
  AddressLo := 0;
  if ASlot = nil then
    RequestInfo := ADDRESS_RETRIEVAL_NOT_FOUND
  else begin
    if ASlot^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 1 then
      RequestInfo := ADDRESS_RETRIEVAL_MU_BASE
    else
    if ASlot^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT = 1 then
      RequestInfo := ADDRESS_RETRIEVAL_DOUBLE_HEADER
    else
    if ASlot^.Flags.ADDRESS_SLOT_FLAGS_MU_BIT = 1 then
      RequestInfo := ADDRESS_RETRIEVAL_MU
    else
      RequestInfo := ADDRESS_RETRIEVAL_NORMAL_LOCO;
    AddressSlot_EncodeAddressToNMRA_Format(ASlot, AddressHi, AddressLo, True);
  end;

  XpressNetMessage.HeaderByte := %11100011;            // $E1
  XpressNetMessage.Bytes[0] := %00110000 or RequestInfo;
  XpressNetMessage.Bytes[1] := AddressHi;
  XpressNetMessage.Bytes[2] := AddressLo;
  XpressNetMessage.DataCount := 3;
  SendXpressNetMessage(@XpressNetMessage, CALLBYTE_RESPONSE, iDevice);
end;
}

// *****************************************************************************
//
// procedure Broadcast_XpressNetMessage;
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              Command:    Upper new bits of the command (the lower bits are the number of bytes in the message)
//
//
// *****************************************************************************
procedure Broadcast_XpressNetMessage(XpressNetMessage: PXpressNetMessage; Command: Byte);
var
  i: Byte;
begin
  SendXpressNetMessage(XpressNetMessage, Command, ID_PC_DEVICE);
  SendXpressNetMessage(XpressNetMessage, Command, 0);
 // for i := ID_MIN_DEVICE to ID_MAX_DEVICE do
 // begin
 //   if XpressNetBuffer.DeviceList[i].Flags and MASK_XPRESSNET_DEVICE_ACTIVE_AND_ACKNOWLEDGING = MASK_XPRESSNET_DEVICE_ACTIVE_AND_ACKNOWLEDGING then
 //      SendXpressNetMessage(XpressNetMessage, Command, i);
 // end
end;


{
// *****************************************************************************
//
// function AssignDeviceToSlot
//
//  Parameters:
//              Slot:    Address slot to deterime speed step type and map to the XPRESSNET_SPEED_STEP_XX constants
//              iDevice: Device to take control of the Slot
//  Result:
//
//  Description:
//
// *****************************************************************************
procedure AssignDeviceToSlot(Slot: PAddressSlot; iDevice: Byte);
begin
  if Slot^.OwnerDevice <> iDevice then
    Send_LocomotiveBeingOperatedByAnotherDevice(Slot);
  Slot^.OwnerDevice := iDevice;
end;
}

{
// *****************************************************************************
//
// function MapSlotToXpressNetSpeedStepID
//
//  Parameters:
//              Slot:  Address slot to deterime speed step type and map to the XPRESSNET_SPEED_STEP_XX constants
//  Result:
//              The XPRESSNET_SPEED_STEP_XX contants
//
//  Description:
//
// *****************************************************************************
function MapSlotToXpressNetSpeedStepID(Slot: PAddressSlot): Byte;
begin
  if Slot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_14_BIT = 1 then
    Result := XPRESSNET_SPEED_STEP_14
  else
  if Slot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_28_BIT = 1 then
    Result := XPRESSNET_SPEED_STEP_28
  else
  if Slot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_128_BIT = 1 then
    Result := XPRESSNET_SPEED_STEP_128
end;
 }
 
// *****************************************************************************
//
// function ExtractSpeedStep
//
//  Parameters:
//              XpressNetSpeed   :  The speed step format of the byte,   XPRESSNET_SPEED_STEP_XX constant
//              NMRA_SpeedDirByte:  The NMRA coded speed type
//  Result:
//              The raw speed step 0-14, 0-28, 0-128
//
//  Description:
//
// *****************************************************************************
function ExtractSpeedStep(XpressNetSpeed: Byte; NMRA_SpeedDirByte: Byte): Byte;
begin
  Result := NMRA_SpeedDirByte;
  case XpressNetSpeed of
    XPRESSNET_SPEED_STEP_14 :
      begin
        Result := Result and %00001111;
        if Result < 2 then
          Result := 0
        else
          Dec(Result)
      end;
    XPRESSNET_SPEED_STEP_28 :
      begin
        Result := (Result and %00011111) shl 1;
        Result.0 := Result.5;
        Result.5 := 0;
        if Result < 4 then
          Result := 0
        else
          Result := Result - 3
      end;
    XPRESSNET_SPEED_STEP_128 :
      begin
        Result := Result and %01111111;
        if Result < 2 then
          Result := 0
        else
          Dec(Result)
      end;
  end;
end;

// *****************************************************************************
//
// function ExtractIsDirForward
//
//  Parameters:
//              XpressNetSpeed   :  The speed step format of the byte,   XPRESSNET_SPEED_STEP_XX constant
//              NMRA_SpeedDirByte:  The NMRA coded speed type
//  Result:
//              True if the direction is forward
//
//  Description:
//
// *****************************************************************************
function ExtractIsDirForward(XpressNetSpeed: Byte; NMRA_SpeedDirByte: Byte): Boolean;
begin
  case XpressNetSpeed of
    XPRESSNET_SPEED_STEP_14,
    XPRESSNET_SPEED_STEP_28  : Result := NMRA_SpeedDirByte.5 = 1;
    XPRESSNET_SPEED_STEP_128 : Result := NMRA_SpeedDirByte.7 = 1 ;
  end;
end;

// *****************************************************************************
//
// function EncodeSpeedStep
//
//  Parameters:
//              XpressNetSpeed   : The speed step format of the byte,   XPRESSNET_SPEED_STEP_XX constant
//              SpeedByte:       : The the raw speed step
//              IsForward:       : True if the direction is forward
//  Result:
//              The raw speed step 0-14, 0-28, 0-128
//
//  Description:
//            Takes the speed step and direction passed and encodes it into the
//     correct NMRA standard byte.  The passed speed step type must be correct
//     for the speed step or the result will be undefined
//
// *****************************************************************************
function EncodeSpeedStep(XpressNetSpeed: Byte; SpeedByte: Byte; IsForward: Boolean): Byte;
begin
  case XpressNetSpeed of
    XPRESSNET_SPEED_STEP_14 :
      begin
        if SpeedByte = 0 then
          Result := 0
        else
          Result := SpeedByte + 1;
        if IsForward then
          Result.5 := 1;
        Result := Result or %01000000;
      end;
    XPRESSNET_SPEED_STEP_28 :
      begin
        if SpeedByte = 0 then
          Result := 0
        else
          Result := SpeedByte + 3;
        Result.5 := Result.0;
        Result := Result shr 1;
        if IsForward then
          Result.5 := 1;
        Result := Result or %01000000;
      end;
    XPRESSNET_SPEED_STEP_128 :
      begin
        if SpeedByte = 0 then
          Result := 0
        else
          Result := SpeedByte + 1;
        if IsForward then
          Result.7 := 1;
      end;
  end;
end;

// *****************************************************************************
//
// function MapSpeed
//
//  Parameters:
//              FromSpeedStep:  The speed step type the passed speed is in, XPRESSNET_SPEED_STEP_XX constant
//              ToSpeedStep:    The speed step type to map the speed to, XPRESSNET_SPEED_STEP_XX constant
//              NMRA_SpeedDir:  The speed in the form of the FromSpeedStep type in the NMRA coded state
//  Result:
//              The speed coded in the ToSpeedStep spec per the NMRA specs
//
//  Description:
//              Maps the NMRA Speed and Direction byte based on one speed step type
//      to another.  It also includes the direction in the result
//
// *****************************************************************************
function MapSpeedDir(FromSpeedStep, ToSpeedStep, NMRA_SpeedDir: Byte): Byte;
var
  R: Byte;
begin
  Result := NMRA_SpeedDir;
  if FromSpeedStep <> ToSpeedStep then
  begin
    case FromSpeedStep of
      XPRESSNET_SPEED_STEP_14 :
        begin
          case ToSpeedStep of
            XPRESSNET_SPEED_STEP_28 :   
              begin
                R := (ExtractSpeedStep(FromSpeedStep, NMRA_SpeedDir) shl 1);
                Result := EncodeSpeedStep(ToSpeedStep, R, ExtractIsDirForward(FromSpeedStep, NMRA_SpeedDir));
              end;
            XPRESSNET_SPEED_STEP_128 :  
              begin
                R :=  Byte( real( (126.0 * real( ExtractSpeedStep(FromSpeedStep, NMRA_SpeedDir)) / 14.0)));
                Result := EncodeSpeedStep(ToSpeedStep, R, ExtractIsDirForward(FromSpeedStep, NMRA_SpeedDir));
              end;
          end
        end;
      XPRESSNET_SPEED_STEP_28 :
        begin
          case ToSpeedStep of
            XPRESSNET_SPEED_STEP_14 : 
              begin
                 R := (ExtractSpeedStep(FromSpeedStep, NMRA_SpeedDir) shr 1);
                 Result := EncodeSpeedStep(ToSpeedStep, R, ExtractIsDirForward(FromSpeedStep, NMRA_SpeedDir));
              end;
            XPRESSNET_SPEED_STEP_128 : 
              begin
                R := Byte( real( 126.0 * real( ExtractSpeedStep(FromSpeedStep, NMRA_SpeedDir)) / 28.0));
                Result := EncodeSpeedStep(ToSpeedStep, R, ExtractIsDirForward(FromSpeedStep, NMRA_SpeedDir));
              end;
          end
        end;
      XPRESSNET_SPEED_STEP_128 :
        begin
          case ToSpeedStep of
            XPRESSNET_SPEED_STEP_14 : 
              begin
                R := Byte( real( 14.0 * real( ExtractSpeedStep(FromSpeedStep, NMRA_SpeedDir)) / 126.0));
                Result := EncodeSpeedStep(ToSpeedStep, R, ExtractIsDirForward(FromSpeedStep, NMRA_SpeedDir));
              end;
            XPRESSNET_SPEED_STEP_28 :
              begin
                R := Byte( real( 28.0 * real( ExtractSpeedStep(FromSpeedStep, NMRA_SpeedDir)) / 126.0));
                Result := EncodeSpeedStep(ToSpeedStep, R, ExtractIsDirForward(FromSpeedStep, NMRA_SpeedDir));
              end;
          end;
        end;
    end
  end
end;

// *****************************************************************************
//
// procedure MapDirectModeCVToAddress(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Description:
//              Decodes the XpressNet message and maps the 8 bit value to the 10 bit
//              register address.  Added in v3.6 of Xpressnet spec
//
// *****************************************************************************
function MapDirectModeCVToAddress(MessageBytes: PXpressNetDataArray): Word;
begin
  case MessageBytes^[0] of
    %00010101,  (*$15*)  // Read; 3-Byte-Format (CV 1-255 und CV256) (pre-v3.6)
    %00010110 : (*$16*)  // Write
      begin
        if MessageBytes^[1] = 0 then
          Result := 255
        else
          Result := MessageBytes^[1] - 1;
      end;
    %00011000,   (*$18*)  // Read 4-Byte-Format (CV 1-255 und CV1024) (v3.6)   Read
    %00011100 : (*$1C*)  // Write
      begin
        if MessageBytes^[1] = 0 then
          Result := 1024
        else
          Result := MessageBytes^[1] - 1;
      end;
    %00011001,  (*$19*)  // Read 4-Byte-Format (CV 256-511)) (v3.6)   Read
    %00011101 : (*$1D*)  // Write
      begin
        if MessageBytes^[1] = 0 then
          Result := 256
        else
          Result := MessageBytes^[1] + 256 - 1;
      end;
    %00011010,  (*$1A*) // Read 4-Byte-Format (CV 512-767) (v3.6)
    %00011110 : (*$1E*) // Write
      begin
        if MessageBytes^[1] = 0 then
          Result := 512
        else
          Result := MessageBytes^[1] + 512 - 1;
      end;
    %00011011,  (*$1B*) // Read 4-Byte-Format (CV 768-1023) (v3.6)  Read
    %00011111 : (*$1F*) // Write
      begin
        if MessageBytes^[1] = 0 then
          Result := 768
        else
          Result := MessageBytes^[1] + 768 - 1;
      end;
  end;
end;

// *****************************************************************************
//
// procedure ResumeOperationsRequest;
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//
//  Device Request           : Paragraph 2.2.2
//  Command Station Response : Paragraph 2.1.4.1
//  Status:
//     Complete 1/29/2011
// *****************************************************************************
procedure ResumeOperationsRequest(XpressNetMessage: PXpressNetMessage);
begin
{  ServiceMode_End;             // Any kind of Service Mode in process is finshed
  SPI_UpdateDCC_Outputs;
  
  NMRA_DCC_ResetTransmitter(@Track);                                      // Reset the transmitters so we are not in the middle of an unknown message
  NMRA_DCC_ResetTransmitter(@Accessory);
  NMRA_DCC_ResetTransmitter(@Programming);  
  
  CommandStation.Flags.COMMANDSTATION_FLAGS_EMERGENCY_SHUTDOWN_BIT := 0;  // Flag the Command Station is not in E-Shutdown or E-Stop
  CommandStation.Flags.COMMANDSTATION_FLAGS_EMERGENCY_STOP_BIT := 0;

  XpressNetMessage^.HeaderByte := %01100001;  // $61;  Reuse the passed XpressNet Message, enviromentally friendly save the bytes!
  XpressNetMessage^.Bytes[0]   := %00000001;  // $01
  XpressNetMessage^.DataCount  := 1;  
  Broadcast_XpressNetMessage(XpressNetMessage, CALLBYTE_BROADCAST);
  Broadcast_XpressNetMessage(XpressNetMessage, CALLBYTE_BROADCAST);  }
end;

// *****************************************************************************
//
// procedure StopOperationsRequest(XpressNetMessage: PXpressNetMessage);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//
//  Device Request           : Paragraph 2.2.3
//  Command Station Response : Paragraph 2.1.4.2
//  Status:
//     Complete 1/29/2011
// *****************************************************************************
procedure StopOperationsRequest(XpressNetMessage: PXpressNetMessage);
begin
{  CommandStation.Flags.COMMANDSTATION_FLAGS_EMERGENCY_SHUTDOWN_BIT := 1;  // Flag the Command Station is in E-Shutdown
  ServiceMode_End;             // Any kind of Service Mode in process is finshed
  SPI_UpdateDCC_Outputs;
  XpressNetMessage^.HeaderByte  := %01100001;  // $61
  XpressNetMessage^.Bytes[0]    := %00000000;  // $00
  XpressNetMessage^.DataCount   := 1;  
  Broadcast_XpressNetMessage(XpressNetMessage, CALLBYTE_BROADCAST);
  Broadcast_XpressNetMessage(XpressNetMessage, CALLBYTE_BROADCAST);  }
end;

// *****************************************************************************
//
// procedure StopAllLocomotivesRequest(XpressNetMessage: PXpressNetMessage);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.4
//  Command Station Response : Paragraph 2.1.4.3
//  Status:
//     Complete 1/29/2011
// *****************************************************************************
procedure StopAllLocomotivesRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//var
//  NewMessage: TDCCQueueMessage;
begin
{  CommandStation.Flags.COMMANDSTATION_FLAGS_EMERGENCY_STOP_BIT := 1;
  NMRA_DCC_LoadMessage(@NewMessage, %00000000, %01000001, 0, 0, 0, 2);   // NMRA Basic Emergency Stop All instruction
  NMRA_DCC_QueueMessage(@Track, @NewMessage, True);
  XpressNetMessage^.HeaderByte := %10000000;  // $80
  XpressNetMessage^.DataCount  := 0;
  Broadcast_XpressNetMessage(XpressNetMessage, CALLBYTE_BROADCAST);
  Broadcast_XpressNetMessage(XpressNetMessage, CALLBYTE_BROADCAST);
  SendXpressNetMessage(XpressNetMessage, CALLBYTE_RESPONSE, iDevice);
  SendXpressNetMessage(XpressNetMessage, CALLBYTE_RESPONSE, iDevice); }
end;

{
// *****************************************************************************
//
// procedure EmergencyStopSlot(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              Slot: Slot to Emergency Stop
//
//  Returns:
//              True if the packet was queued
//
// *****************************************************************************
function EmergencyStopSlot(Slot: PAddressSlot): Boolean;
begin
  if Slot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_128_BIT = 1 then
    Slot^.SpeedDir := Slot^.SpeedDir and $80                 // Clear the lower 7 bits, and set the speed to E-Stop
  else
  if Slot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_28_BIT = 1 then
    Slot^.SpeedDir := Slot^.SpeedDir and $E0                 // Clear the lower 5 bits, and set the speed to E-Stop
  else
    Slot^.SpeedDir := Slot^.SpeedDir and $F0;                // Clear the lower 4 bits, and set the speed to E-Stop

  Slot^.SpeedDir := Slot^.SpeedDir or SPEEDSTEP_E_STOP;

  Result :=  AddressSlot_QueueSpeedDCCMessage(Slot, True)
end;
      }
// *****************************************************************************
//
// procedure EmergencyStopLocomotiveRequestV3(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Returns:
//       No Response to Device Defined, only notify PC
//
//  Device Request           : Paragraph 2.2.5.2
//  Command Station Response : Paragraph None
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure EmergencyStopLocomotiveRequestV3(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  Slot, Slot2: PAddressSlot;
  Error: Byte;  }
begin
 { Error := E_PC_SUCCESS;
  Slot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 0, 1), False); // If not found no harm done as there is nothing to stop!
  if Slot <> nil then
  begin
    if Slot^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT = 1 then
    begin
      // Slot is in a double header
      Slot2 := AddressSlot_ExtractDoubleHeaderSecondSlot(Slot);
      if (Slot2 <> nil) and (Track.Priority^.Count < MAX_TRACK_PRIORITY_BUFFER_DEPTH - 2) then
      begin
        Error := E_PC_COMMANDSTATION_COMMUNICATION;             // Tell the device to try it again
        if EmergencyStopSlot(Slot) then
          if EmergencyStopSlot(Slot2) then
          Error := E_PC_SUCCESS
      end else
        Error := E_PC_UNKNOWN;
    end else
    begin
      if not EmergencyStopSlot(Slot) then
        Error := E_PC_COMMANDSTATION_COMMUNICATION;              // Tell the device to try it again
    end
  end;
  // The PC needs a response
  if iDevice = ID_PC_DEVICE then
    Send_PCMessage(Error);    }
end;

// *****************************************************************************
//
// procedure EmergencyStopLocomotiveRequestV2_Down(iDevice: Byte);
//
//  Parameters:
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.5.1
//  Command Station Response : Paragraph None
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure EmergencyStopLocomotiveRequestV2_Down(iDevice: Byte);
begin
  Send_InstructionNotSupported(iDevice)
end;


// *****************************************************************************
//
// procedure RegisterModeReadRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              MessageData: Global structure to hold the message information//
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.7
//  Command Station Response : Paragraph 2.1.4.4
//  Status:
//     Complete: 2/19/2011
//
// *****************************************************************************
procedure RegisterModeReadRequest(MessageData: PXpressNetDataArray; iDevice: Byte);
begin
  // Register Mode only support 8 Registers so what is sent = the "register" only 8 are supported (0000 RRRR)
 { if not ServiceMode_QueueRequest(MessageData^[1]-1, 0, iDevice, SERVICE_MODE_REGISTER or SERVICE_MODE_COMMMAND_VERIFY_BYTE, STATE_SERVICEMODE_RESET_CYCLE) then
    if iDevice = ID_PC_DEVICE then
    Send_PCMessage(E_PC_LOSS_OF_TIMESLOT)   }
end;

// *****************************************************************************
//
// procedure DirectModeReadRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              MessageData: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Description:  Also known as CV Mode
//
//  Device Request           : Paragraph 2.2.8     (2.2.6 - 2.2.10 German Document v3.6)
//  Command Station Response : Paragraph 2.1.4.4
//  Status:
//     Complete: 2/19/2011
//
// *****************************************************************************
procedure DirectModeReadRequest(MessageData: PXpressNetDataArray; iDevice: Byte);
begin
{  if not ServiceMode_QueueRequest(MapDirectModeCVToAddress(MessageData), 0, iDevice, SERVICE_MODE_DIRECT or SERVICE_MODE_COMMMAND_VERIFY_BYTE, STATE_SERVICEMODE_DIRECT_RESET_CYCLE) then
    if iDevice = ID_PC_DEVICE then
      Send_PCMessage(E_PC_LOSS_OF_TIMESLOT)   }
end;

// *****************************************************************************
//
// procedure PagedModeReadRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              MessageData: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.9
//  Command Station Response : Paragraph 2.1.4.4
//  Status:
//     Complete: 2/19/2011
//
// *****************************************************************************
procedure PagedModeReadRequest(MessageData: PXpressNetDataArray; iDevice: Byte);
begin
 { if not ServiceMode_QueueRequest(MessageData^[1]-1, 0, iDevice, SERVICE_MODE_PAGE or SERVICE_MODE_COMMMAND_VERIFY_BYTE, STATE_SERVICEMODE_RESET_CYCLE) then
    if iDevice = ID_PC_DEVICE then
      Send_PCMessage(E_PC_LOSS_OF_TIMESLOT)  }
end;


// *****************************************************************************
//
// procedure CheckAndRunNextServiceModeRequest;
//
//  Parameters:  None
//
//  Returns:     None
//
//  Description:
//
// *****************************************************************************
procedure CheckAndRunNextServiceModeRequest;
begin
 { if ServiceModeInfo.Queue.Count > 0 then                                       // There is another request waiting and the Service Mode engine is not busy with another request
  begin
    if ServiceModeInfo.Buffer.Mode and $F0 = ServiceModeInfo.Queue.Messages[ServiceModeInfo.Queue.iTail].Mode and $F0 then
    begin
      ServiceMode_LoadBufferFromNextInQueue(False);                             // If not changing ServiceMode types we can skip the PowerOn Cycle
      if ServiceModeInfo.Buffer.iDevice = ID_PC_DEVICE then                     // This will force JMRI to send the Result Request for the Service Mode Request
        Send_PCMessage(E_PC_SUCCESS)
    end else
    begin
      ServiceMode_End;                                                          // Kick it out of Service Mode, the next loop through the main loop will restart with the new Service Mode type
      SPI_UpdateDCC_Outputs;
    end
  end   }
end;

   
// *****************************************************************************
//
// function XpressNet_HandleServiceModeAndResults;
//
//  Parameters:  None
//
//  Returns:     None
//
//  Description:  Called from the main loop to look for the service mode engine
//                to be complete and reloads it when necessary
//
// *****************************************************************************
procedure XpressNet_HandleServiceModeAndResults;
begin
 { if ServiceModeInfo.Flags.PROGRAMMING_ACK_STATE_IN_SERVICEMODE_BIT = 1 then    // Already in Service Mode, handle it
  begin
    if ServiceModeInfo.Flags.PROGRAMMING_ACK_STATE_RESPONSE_READY_BIT = 1 then  // Is the result ready?
    begin
      if ServiceModeInfo.Queue.ResultRequestCount > 0 then                      // Make sure someone is waiting for a result, note is can be a race condition between reading the decoder and the requesting sending a Result Request so don't
      begin                                                                     // and the requesting sending a Result Request so don't do anything if ResultRequestCount = 0.  Just wait for it
        DispatchServiceModeResultsRequest(ServiceModeInfo.Buffer.iDevice);
        ServiceModeInfo.Buffer.iDevice := ID_NO_DEVICE;                         // Unlink the Device with the Service Mode
        ServiceModeInfo.Flags.PROGRAMMING_ACK_STATE_IDLE_BIT := 1;              // Ready for the next SM request
        ServiceMode_ResetForNewAck;
        Dec(ServiceModeInfo.Queue.ResultRequestCount)
      end
    end;
    if ServiceModeInfo.Flags.PROGRAMMING_ACK_STATE_IDLE_BIT = 1 then            // Alway check if waiting for next message
      CheckAndRunNextServiceModeRequest
  end else
  begin     
    if ServiceModeInfo.Queue.Count > 0 then
    begin
      ServiceModeInfo.Flags.PROGRAMMING_ACK_STATE_MACHINE_ENABLED := 0;         // Disable the State Machine (the Power On Cycle will just send "1"s)
      NMRA_DCC_ResetTransmitter(@Programming);                                  // Clean sheet of paper in the Transmitter
      NMRA_DCC_LoadIdlePacketIntoTransmitter(@Programming, PREAMBLE_BIT_COUNT_SERVICEMODE);  // Load up an Idle Packet
      ServiceMode_LoadBufferFromNextInQueue(True);                              // Loads the Local Buffer with the request
      ServiceModeInfo.Flags.PROGRAMMING_ACK_STATE_IN_SERVICEMODE_BIT := 1;      // After this is set a 56us interrupt will call the Service Mode statemachine.
      SPI_UpdateDCC_Outputs;                                                    // Enable the DCC outputs, the statemachine will be sending "1"'s during this time (Not Enabled)
      ServiceModeInfo.Flags.PROGRAMMING_ACK_STATE_MACHINE_ENABLED := 1;         // Enable the State Machine
      Send_EnterServiceMode(ServiceModeInfo.Buffer.iDevice, True);             // This will force JMRI to send the Result Request for the Service Mode Request, can be sent and in the Queue before this returns!
    end
  end      }
end;

// *****************************************************************************
//
// procedure ServiceModeResultsRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.10
//  Command Station Response : Paragraph 2.1.5
//  Status:
//     Complete:
//
// *****************************************************************************
procedure ServiceModeResultsRequest(iDevice: Byte);
begin
{  if ServiceModeInfo.Flags.PROGRAMMING_ACK_STATE_IN_SERVICEMODE_BIT = 0 then
  begin
    Send_InstructionNotSupported(iDevice);                                      // Per 2.1.5 Service Mode information response
    ServiceMode_End;                                                            // Something is wrong so just clear everything and start over
    SPI_UpdateDCC_Outputs
  end else
  begin
    Inc(ServiceModeInfo.Queue.ResultRequestCount);                              // Here we just collect how many times the Results are Requested which should ideally match the number of requests for service mode
    if ServiceModeInfo.Buffer.iDevice = ID_PC_DEVICE then                       // JMRI always needs some sort of reply to move it to the next state
      Send_EnterServiceMode(ServiceModeInfo.Buffer.iDevice, True)
  end  }
end;

// *****************************************************************************
//
// procedure DispatchServiceModeResultsRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
// *****************************************************************************
procedure DispatchServiceModeResultsRequest(iDevice: Byte);
{var
  Mask: Byte;
  RegisterIndex: Word;
  XpressNetMessage: TXpressNetMessage;   }
begin
 { case ServiceModeInfo.ServiceModeResult of
    SERVICE_MODE_RESULT_SHORTCIRCUIT :            // System had too much current draw
      begin
        XpressNetMessage.HeaderByte := %01100001;   // $61
        XpressNetMessage.Bytes[0] := %00010010;     // $12
        XpressNetMessage.DataCount := 1;
      end;
    SERVICE_MODE_RESULT_DATA_NOT_FOUND :          // No Acknowledgement was detected
      begin
        XpressNetMessage.HeaderByte := %01100001;   // $61
        XpressNetMessage.Bytes[0] := %00010011;     // $13
        XpressNetMessage.DataCount := 1;
      end;
    SERVICE_MODE_RESULT_STATION_BUSY :            // Not supported in XpressNet yet
      begin
        XpressNetMessage.HeaderByte := %01100001;   // $61
        XpressNetMessage.Bytes[0] := %00011111;     // $1F
        XpressNetMessage.DataCount := 1;
      end;
    SERVICE_MODE_RESULT_STATION_READY :           // Not supported in XpressNet yet
      begin
        XpressNetMessage.HeaderByte := %01100001;   // $61
        XpressNetMessage.Bytes[0] := %00010001;     // $11
        XpressNetMessage.DataCount := 1;
      end;
    SERVICE_MODE_RESULT_RESPONSE_PAGE_MODE :        // Response was achieved in Register or Page mode
      begin
        // Page Mode supports 1024 but the Xpressnet implementation only support 256
        // Register Mode only support 8 Registers and Address = what is sent
        XpressNetMessage.HeaderByte := %01100011;   // $63
        XpressNetMessage.Bytes[0] := %00010000;     // $10
        XpressNetMessage.Bytes[1] := ServiceModeInfo.Buffer.DeviceCache.Address + 1;
        XpressNetMessage.Bytes[2] := ServiceModeInfo.Buffer.DeviceCache.Value;
        XpressNetMessage.DataCount := 3;
      end;
      SERVICE_MODE_RESULT_RESPONSE_DIRECT_MODE :    // Response was achieved in Direct CV mode
      begin
        // We support only v3.6 here as Register Index = 0 mapped to 256 does not exist in the v3.6 spec
        if ServiceModeInfo.Buffer.DeviceCache.Address < 256 (*$00FF*) then
        begin
          if ServiceModeInfo.Buffer.DeviceCache.Address = 255 then
            RegisterIndex := 0
          else
            RegisterIndex := (ServiceModeInfo.Buffer.DeviceCache.Address and $00FF) + 1;
          Mask := %00010100      // $14   Pre v3.6 8 bit address only or v3.6 CV 1-255 and CV 1024
        end else
        if ServiceModeInfo.Buffer.DeviceCache.Address < 512 (*$01FF*) then
        begin
          if ServiceModeInfo.Buffer.DeviceCache.Address = 511 then
            RegisterIndex := 0
          else
            RegisterIndex := (ServiceModeInfo.Buffer.DeviceCache.Address and $00FF) + 1;
          Mask := %00010101      // $15   v3.6 CV 256-511
        end else
        if ServiceModeInfo.Buffer.DeviceCache.Address < 768 (*$02FF*) then
        begin
          if ServiceModeInfo.Buffer.DeviceCache.Address = 767 then
            RegisterIndex := 0
          else
            RegisterIndex := (ServiceModeInfo.Buffer.DeviceCache.Address and $00FF) + 1;
          Mask := %00010110      // $16   v3.6 CV 512-767
        end else
        begin
          if ServiceModeInfo.Buffer.DeviceCache.Address = 1023 then  (*$03FF*)
            RegisterIndex := 0
          else
            RegisterIndex := (ServiceModeInfo.Buffer.DeviceCache.Address and $00FF) + 1;
          Mask := %00010111;     // $17   v3.6 CV 768-1023
        end;

        XpressNetMessage.HeaderByte := %01100011;   // $63
        XpressNetMessage.Bytes[0] := Mask;
        XpressNetMessage.Bytes[1] := RegisterIndex;
        XpressNetMessage.Bytes[2] := ServiceModeInfo.Buffer.DeviceCache.Value;
        XpressNetMessage.DataCount := 3;
      end;
  end;
  SendXpressNetMessage(@XpressNetMessage, CALLBYTE_RESPONSE, iDevice);}
end;

// *****************************************************************************
//
// procedure RegisterModeWriteRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              MessageData: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.11
//  Command Station Response : Paragraph 2.1.4.4
//  Status:
//     Complete: 2/19/2011
//
// *****************************************************************************
procedure RegisterModeWriteRequest(MessageData: PXpressNetDataArray; iDevice: Byte);
begin
 { // Register Mode only support 8 Registers
  if not ServiceMode_QueueRequest(MessageData^[1]-1, MessageData^[2], iDevice, SERVICE_MODE_REGISTER or SERVICE_MODE_COMMMAND_WRITE_BYTE, STATE_SERVICEMODE_RESET_CYCLE) then
    if iDevice = ID_PC_DEVICE then
      Send_PCMessage(E_PC_LOSS_OF_TIMESLOT)  }
end;

// *****************************************************************************
//
// procedure DirectModeWriteRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              MessageData: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.12
//  Command Station Response : Paragraph 2.1.4.4
//  Status:
//     Complete: 2/19/2011
//
// *****************************************************************************
procedure DirectModeWriteRequest(MessageData: PXpressNetDataArray; iDevice: Byte);
begin
{  if not ServiceMode_QueueRequest(MapDirectModeCVToAddress( MessageData), MessageData^[2], iDevice, SERVICE_MODE_DIRECT or SERVICE_MODE_COMMMAND_WRITE_BYTE, STATE_SERVICEMODE_DIRECT_RESET_CYCLE) then
    if iDevice = ID_PC_DEVICE then
      Send_PCMessage(E_PC_LOSS_OF_TIMESLOT);      }
end;

// *****************************************************************************
//
// procedure PagedModeWriteRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              MessageData: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.13
//  Command Station Response : Paragraph 2.1.4.4
//  Status:
//     Complete: 2/19/2011
//
// *****************************************************************************
procedure PagedModeWriteRequest(MessageData: PXpressNetDataArray; iDevice: Byte);
begin
 { if not ServiceMode_QueueRequest(MessageData^[1]-1, MessageData^[2], iDevice, SERVICE_MODE_PAGE or SERVICE_MODE_COMMMAND_WRITE_BYTE, STATE_SERVICEMODE_RESET_CYCLE) then
    if iDevice = ID_PC_DEVICE then
      Send_PCMessage(E_PC_LOSS_OF_TIMESLOT)   }
end;

// *****************************************************************************
//
// procedure CommandStationSoftwareVersionRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//
//  Device Request           : Paragraph 2.2.14
//  Command Station Response : Paragraph 2.1.6
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure CommandStationSoftwareVersionRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
begin
  // Fake V3 Software
  XpressNetMessage^.HeaderByte := %01100011;  // $63  Reuse the passed XpressNet Message, enviromentally friendly save the bytes!
  XpressNetMessage^.Bytes[0]   := %00100001;  // $21
  XpressNetMessage^.Bytes[1]   := VERSION_SOFTWARE_XPRESSNET;
  XpressNetMessage^.Bytes[2]   := VERSION_COMMANDSTATION_LZ100;
  XpressNetMessage^.DataCount  := 3;
  SendXpressNetMessage(XpressNetMessage, CALLBYTE_RESPONSE, iDevice);
end;

// *****************************************************************************
//
// procedure CommandStationStatusRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.15
//  Command Station Response : Paragraph 2.1.7
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure CommandStationStatusRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
begin
 { XpressNetMessage^.HeaderByte := %01100010;  // Reuse the passed XpressNet Message, enviromentally friendly save the bytes!
  XpressNetMessage^.Bytes[0]   := %00100010;
  XpressNetMessage^.Bytes[1]   := CommandStation.Flags and $00FF;  // CommandStation State bottom 8 bits are mapped as the Xpressnet Spec
  XpressNetMessage^.DataCount  := 2;
  SendXpressNetMessage(XpressNetMessage, CALLBYTE_RESPONSE, iDevice); }
end;

// *****************************************************************************
//
// procedure SetCommandStationPowerUpMode(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.16
//  Command Station Response : Paragraph None
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure SetCommandStationPowerUpMode(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
begin
{  CommandStation.Flags.COMMANDSTATION_FLAGS_STARTUP_MODE_BIT := XpressNetMessage^.Bytes[1].2; // CommandStation.State bit 2 is mapped to this bit in the Xpressnet message
  // The PC needs a response
  if iDevice = ID_PC_DEVICE then
    Send_PCMessage(E_PC_SUCCESS);   }
end;

// *****************************************************************************
//
// procedure AccessoryInformationRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.17
//  Command Station Response : Paragraph 2.1.11
//  Status:
//     Complete TBD
//
// *****************************************************************************
procedure AccessoryInformationRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
var
  Address: Word;
begin
  Address := XpressNetMessage^.Bytes[0] shl 2;  // Address is sent as the Group Address need to mulitpy by 4
//  AddressSlotInfo.AccessorySlot[Address div 8];
  Send_InstructionNotSupported(iDevice)
end;

// *****************************************************************************
//
// procedure AccessoryOperationRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.18
//  Command Station Response : Paragraph None
//  Status:
//     Complete TBD
//
// *****************************************************************************
procedure AccessoryOperationRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
begin
  Send_InstructionNotSupported(iDevice)
end;

// *****************************************************************************
//
// procedure LocomotiveInformationRequestV1(iDevice: Byte);
//
//  Parameters:
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.19.1
//  Command Station Response : Paragraph 2.1.12
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure LocomotiveInformationRequestV1(iDevice: Byte);
begin
  Send_InstructionNotSupported(iDevice)
end;

// *****************************************************************************
//
// procedure LocomotiveInformationRequestV2(iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//
//  Device Request           : Paragraph 2.2.19.2
//  Command Station Response : Paragraph 2.1.13
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure LocomotiveInformationRequestV2(iDevice: Byte);
begin
  Send_InstructionNotSupported(iDevice)
end;

// *****************************************************************************
//
// procedure LocomotiveInformationRequestV3(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.19.3
//  Command Station Response : Paragraph 2.1.14
//  Status:
//     Single Locomotive Complete 1/29/2011
//     ToDo: MU/Consist/Double Header
//
// *****************************************************************************
procedure LocomotiveInformationRequestV3(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//var
//  Slot, Slot2: PAddressSlot;
begin
{  Slot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2), False);  // Don't allocate if it does not exist
  if Slot <> nil then
  begin    
    if Slot^.Flags.ADDRESS_SLOT_FLAGS_MU_BIT = 1 then
    begin
      // The Address Slot is one in group of Multiple Units
      XpressNetMessage^.Bytes[0] := %00010000;  // Identification
      XpressNetMessage^.HeaderByte := %11100101;
      XpressNetMessage^.DataCount := 5;
      Slot2 := AddressSlot_WalkMU_ChainRoot(Slot);
      if Slot2 <> nil then
        XpressNetMessage^.Bytes[4] := Slot2^.Address;
    end else
    if Slot^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 1 then
    begin
      // The Address Slot is the Consist Address of a MU Consist
      XpressNetMessage^.Bytes[0] := %00100000;  // Identification
      XpressNetMessage^.HeaderByte := %11100010;
      XpressNetMessage^.DataCount := 2;
    end else
    if Slot^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT = 1 then
    begin
      // The Address Slot is in a double header
      XpressNetMessage^.Bytes[0] := %01100000;  // Identification
      XpressNetMessage^.HeaderByte := %11100110;
      XpressNetMessage^.DataCount := 6;
      Slot2 := AddressSlot_ExtractDoubleHeaderSecondSlot(Slot);
      if Slot2 <> nil then
        AddressSlot_EncodeAddressToNMRA_Format(Slot2, XpressNetMessage^.Bytes[4], XpressNetMessage^.Bytes[5], True);
    end else
    begin
      // The Address Slot is a normal loco
      XpressNetMessage^.Bytes[0] := %00000000;  // Identification
      XpressNetMessage^.HeaderByte := %11100100;
      XpressNetMessage^.DataCount := 4;
    end;
  
    XpressNetMessage^.Bytes[0] := XpressNetMessage^.Bytes[0] or MapSlotToXpressNetSpeedStepID(Slot);  // Indentification Byte
    if not ((Slot^.OwnerDevice = ID_NO_DEVICE) or (Slot^.OwnerDevice = iDevice)) then
      XpressNetMessage^.Bytes[0].XPRESSNET_LOCO_CONTROLLED_BY_DEVICE_BIT := 1;
    XpressNetMessage^.Bytes[1]  := Slot^.SpeedDir;
    XpressNetMessage^.Bytes[2]  := Slot^.Functions and $001F;          // Functions F0..F4;   Bottom 5 Bits F0-F4
    XpressNetMessage^.Bytes[3]  := (Slot^.Functions shr 5) and $00FF;  // Functions F5..F12;  Shift out the bottom 5 bits to get F5-F12
  
    SendXpressNetMessage(XpressNetMessage, CALLBYTE_RESPONSE, iDevice);

  end else
  begin
    // If we can't find a slot then send back default values for the address, this is so we don't allocate a slot when a user is just typing in
    // addresses without sending them a command
    XpressNetMessage^.HeaderByte := %11100100;
    XpressNetMessage^.Bytes[0] := %00000010;  // Identification, Loco Free, 28 Speed Step Default
    XpressNetMessage^.Bytes[1]  := 0;
    XpressNetMessage^.Bytes[2]  := 0;         // Functions F0..F4;   Bottom 5 Bits F0-F4
    XpressNetMessage^.Bytes[3]  := 0;         // Functions F5..F12;  Shift out the bottom 5 bits to get F5-F12
    XpressNetMessage^.DataCount := 4;
    SendXpressNetMessage(XpressNetMessage, CALLBYTE_RESPONSE, iDevice);
  end  }
end;

// *****************************************************************************
//
// procedure FunctionStatusRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Description:  Called by [$E3 $07 ....]   Momentary/Continious Status
//
//  Device Request           : Paragraph 2.2.19.4
//  Command Station Response : Paragraph 2.1.16
//  Status:
//     Single Locomotive Complete 1/29/2011
//     ToDo: MU/Consist/Double Header  Not clear the meaning of this for these cases.......
//
// *****************************************************************************
procedure FunctionStatusRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  Slot: PAddressSlot;  }
begin
  // Extract the Address BEFORE changing the Message Data!!!!!
 { Slot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2), False); // Don't allocate if it does not exist
  
  XpressNetMessage^.HeaderByte := %11100011;  // Reuse the passed XpressNet Message, enviromentally friendly save the bytes!
  XpressNetMessage^.Bytes[0]   := %01010000;  // Identification
  XpressNetMessage^.Bytes[1]   := $00;        // Functions F0..F4 Status;   Bottom 5 Bits F0-F4
  XpressNetMessage^.Bytes[2]   := $00;        // Functions F5..F12 Status;  Shift out the bottom 5 bits to get F5-F12
  XpressNetMessage^.DataCount  := 3;

  if Slot <> nil then
  begin
    // Valid for:
    //     - Consist address can have momentary/continious states of functions (review this)
    //     - MU can operate the functions of individual decoders
    //     - Double Header can operate the functions of individual decoders
    //     - Single decoder can operate its functions
    XpressNetMessage^.Bytes[1]   := Slot^.FunctionType and $001F;            // Functions F0..F4 Status;   Bottom 5 Bits F0-F4
    XpressNetMessage^.Bytes[2]   := (Slot^.FunctionType shr 5) and $00FF;    // Functions F5..F12 Status;  Shift out the bottom 5 bits to get F5-F12
  end;
  SendXpressNetMessage(XpressNetMessage, CALLBYTE_RESPONSE, iDevice);   }
end;

// *****************************************************************************
//
// procedure FunctionStateRequestEx(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Description:  (version 3.6) Called by [$E3 $08 ....]  Momentary/Continious Status
//
//  Device Request           : Paragraph 2.2.19.5??    (2.2.25.2 in the German document)
//  Command Station Response : Paragraph 2.1.16??      (2.1.12 in the German document)
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure FunctionStateRequestEx(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  Slot: PAddressSlot; }
begin
  // Extract the Address BEFORE changing the Message Data!!!!!
{  Slot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2), False); // Don't allocate if it does not exist
  
  XpressNetMessage^.HeaderByte := %11100100;  // Reuse the passed XpressNet Message, enviromentally friendly save the bytes!
  XpressNetMessage^.Bytes[0]   := %01010001;  // Identification
  XpressNetMessage^.Bytes[1]   := $00;        // Functions F13..F20 Momentary/Continious Status;  Bottom 8 Bits F20-F13
  XpressNetMessage^.Bytes[2]   := $00;        // Functions F21..F28 Momentary/Continious Status;  Shift out the bottom 5 bits to get F21..F28
  XpressNetMessage^.Bytes[3]   := $00;        // Mystery Byte that is not documented but needed
  XpressNetMessage^.DataCount  := 4;

  if Slot <> nil then
  begin
    // Valid for:
    //     - Consist address can have momentary/continious states of functions (review this)
    //     - MU can operate the functions of individual decoders
    //     - Double Header can operate the functions of individual decoders
    //     - Single decoder can operate its functions
    XpressNetMessage^.Bytes[1]   :=  Lo(Slot^.FunctionTypeEx);                  // Functions F13..F20 Momentary/Continious Status;  Bottom 8 Bits F20-F13
    XpressNetMessage^.Bytes[2]   :=  Hi(Slot^.FunctionTypeEx);                  // Functions F21..F28 Momentary/Continious Status;  Shift out the bottom 5 bits to get F21..F28
  end;
  SendXpressNetMessage(XpressNetMessage, CALLBYTE_RESPONSE, iDevice);   }
end;

// *****************************************************************************
//
// procedure FunctionOperationRequestEx(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Description:  (version 3.6) Called by [$E3 $09 ....]  On/Off Status
//
//  Device Request           : Paragraph 2.2.19.6??    (2.2.25.3 in the German document)
//  Command Station Response : Paragraph 2.1.16??      (2.1.9.2 in the German document)
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure FunctionOperationRequestEx(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  Slot: PAddressSlot;  }
begin  
 { // Extract the Address BEFORE changing the Message Data!!!!!
  Slot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2), False); // Don't allocate if it does not exist
  
  XpressNetMessage^.HeaderByte := %11100011;  // Reuse the passed XpressNet Message, enviromentally friendly save the bytes!
  XpressNetMessage^.Bytes[0]   := %01010010;  // Identification
  XpressNetMessage^.Bytes[1]   := $00;        // Functions F13..F20 On/Off Status;  Bottom 8 Bits F20-F13
  XpressNetMessage^.Bytes[2]   := $00;        // Functions F21..F28 On/Off Status;  Shift out the bottom 5 bits to get F21..F28
  XpressNetMessage^.DataCount  := 3;

  if Slot <> nil then
  begin
    // Valid for:
    //     - MU can operation the functions of individual decoders
    //     - Double Header can operate the functions of individual decoders
    //     - Single decoder can operate its functions
    XpressNetMessage^.Bytes[1]   := Lo(Slot^.FunctionsEx);                      // Functions F13..F20 On/Off Status;  Bottom 8 Bits F20-F13
    XpressNetMessage^.Bytes[2]   := Hi(Slot^.FunctionsEx)                       // Functions F21..F28 On/Off Status;  Shift out the bottom 5 bits to get F21..F28
  end;
  SendXpressNetMessage(XpressNetMessage, CALLBYTE_RESPONSE, iDevice); }
end;

// *****************************************************************************
//
// procedure LocomotiveOperationRequestV1(iDevice: Byte);
//
//  Parameters:
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.20.1
//  Command Station Response : None
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure LocomotiveOperationRequestV1(iDevice: Byte);
begin
  // Paragraph 2.2.20.1
  Send_InstructionNotSupported(iDevice)
end;

// *****************************************************************************
//
// procedure LocomotiveOperationRequestV2(iDevice: Byte);
//
//  Parameters:
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.20.2
//  Command Station Response : None
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
procedure LocomotiveOperationRequestV2(iDevice: Byte);
begin
  // Paragraph 2.2.20.2
  Send_InstructionNotSupported(iDevice)
end;


// *****************************************************************************
//
// procedure UpdateSlotSpeedAndDirectionAndQueue;
//
//  Parameters:
//              Slot            : The Mobile Decoder Slot structure (address) to get the new Speed and Direction
//              Identification  : The Xpressnet Identifcation byte for the SetLocomotiveSpeedAndDirectionRequest message
//              SpeedDir        : New SpeedDir byte, in NMRA format
//              iDevice         : The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.20.2
//  Command Station Response : None
//  Status:
//     Complete 1/29/2011
//
// *****************************************************************************
{function UpdateSlotSpeedAndDirectionAndQueue(Slot: PAddressSlot; Identification, SpeedDir, iDevice: Byte): Boolean;
begin
  AssignDeviceToSlot(Slot, iDevice);
  Slot^.Flags := Slot^.Flags and not MASK_ADDRESS_SLOT_FLAGS_SPEED;   // Clear the Speed Flags
  case Identification of   // Identification
     %00010000: (*$16*) Slot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_14_BIT := 1;   // 14 Speed Step
     %00010010: (*$18*) Slot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_28_BIT := 1;   // 28 Speed Step
     %00010011: (*$19*) Slot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_128_BIT := 1;  // 128 Speed Step
  end;
  Slot^.SpeedDir := SpeedDir;   // Save the Speed, direction
  Result := AddressSlot_QueueSpeedDCCMessage(Slot, True)
end;   }

// *****************************************************************************
//
// procedure SetLocomotiveSpeedAndDirectionRequest
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.20.3
//  Command Station Response : None
//  Status:
//     Complete 1/30/2011
//
// *****************************************************************************
procedure SetLocomotiveSpeedAndDirectionRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  Slot, Slot2: PAddressSlot;
  ErrorCode, MappedSpeedDir: Byte;  }
begin
 { if XpressNetMessage^.Bytes[0] = %00010001 then (*$11*)   // 27 Speed Step not supported
    Send_InstructionNotSupported(iDevice)
  else begin
    ErrorCode := E_PC_UNKNOWN;
    CommandStation.Flags.COMMANDSTATION_FLAGS_EMERGENCY_STOP_BIT := 0;
    Slot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2),  True); // AutoAllocate
    if Slot <> nil then
    begin
      if Slot^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT = 1 then
      begin
        // Slot is in a double header
        Slot2 := AddressSlot_ExtractDoubleHeaderSecondSlot(Slot);
        if (Slot2 <> nil) and (Track.Priority^.Count < MAX_TRACK_PRIORITY_BUFFER_DEPTH - 2) then
        begin
          UpdateSlotSpeedAndDirectionAndQueue(Slot, XpressNetMessage^.Bytes[0], XpressNetMessage^.Bytes[3], iDevice);
          MappedSpeedDir := MapSpeedDir(MapSlotToXpressNetSpeedStepID(Slot), MapSlotToXpressNetSpeedStepID(Slot2), Slot^.SpeedDir);
          UpdateSlotSpeedAndDirectionAndQueue(Slot2, XpressNetMessage^.Bytes[0], MappedSpeedDir, iDevice);
          ErrorCode := E_PC_SUCCESS
        end
      end else
      if Slot^.Flags.ADDRESS_SLOT_FLAGS_MU_BIT = 1 then
      begin
        // Slot is in a MU
        Slot2 := AddressSlot_WalkMU_ChainRoot(Slot);  // Find the Consist Slot
        if UpdateSlotSpeedAndDirectionAndQueue(Slot2, XpressNetMessage^.Bytes[0], XpressNetMessage^.Bytes[3], iDevice) then   // Update the Consist and not the Loco
          ErrorCode := E_PC_SUCCESS
      end else
      if Slot^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 1 then
      begin
        // Slot is a MU Consist Main Address
        if UpdateSlotSpeedAndDirectionAndQueue(Slot, XpressNetMessage^.Bytes[0], XpressNetMessage^.Bytes[3], iDevice) then   // Update the Consist
          ErrorCode := E_PC_SUCCESS
      end else
      begin
        // Slot is a normal loco
        if UpdateSlotSpeedAndDirectionAndQueue(Slot, XpressNetMessage^.Bytes[0], XpressNetMessage^.Bytes[3], iDevice) then   // Update the Locomotive
          ErrorCode := E_PC_SUCCESS
      end
    end;
    if iDevice = ID_PC_DEVICE then  // The PC needs a response
      Send_PCMessage(ErrorCode);
  end             }
end;


// *****************************************************************************
//
// procedure SetFunctionOperationRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              Identification: Identifies the sub-instruction for the request
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Description:  Called by [$E4 $20 ....]   On/Off State of the Function for Group 1
//                          [$E4 $21 ....]   On/Off State of the Function for Group 2
//                          [$E4 $22 ....]   On/Off State of the Function for Group 3
//                          [$E4 $23 ....]   On/Off State of the Function for Group 4
//                          [$E4 $28 ....]   On/Off State of the Function for Group 5
//
//  Device Request           : Paragraph 2.2.20.4
//  Command Station Response : None
//  Status:
//     Complete 1/28/2011
//
// *****************************************************************************
procedure SetFunctionOperationRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  Slot: PAddressSlot;
  ErrorCode: Byte;   }
begin
{  ErrorCode := E_PC_UNKNOWN;
  Slot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2), True); // AutoAllocate
  if Slot <> nil then
  begin
    // Valid for:
    //     - MU can operation the functions of individual decoders
    //     - Double Header can operate the functions of individual decoders
    //     - Single decoder can operate its functions
    //     - Consist Address
    AssignDeviceToSlot(Slot, iDevice);
    case XpressNetMessage^.Bytes[0] of   // Identification
      %00100000 : (*$20*)   // Set Function Operation on Group 1 ( on/off ) Functions F0..F4 Status   (Note the order is F0-F4-F3-F2-F1)
        begin
          Slot^.Functions := Slot^.Functions and $FFE0;                             // Clear bits 0, 1, 2, 3, 4
          Slot^.Functions := Slot^.Functions or XpressNetMessage^.Bytes[3];         // Set the new bits 5, 6 ,7 8
          if AddressSlot_QueueFunctionDCCMessage(Slot, 1, False) then
            ErrorCode := E_PC_SUCCESS
        end;
      %00100001 : (*$21*)   // Set Function Operation on Group 2 ( on/off )  Functions F8..F5 Status
        begin
          Slot^.Functions := Slot^.Functions and $FE1F;                             // Clear bits 5, 6 ,7 8
          Slot^.Functions := Slot^.Functions or (XpressNetMessage^.Bytes[3] shl 5); // Set the new bits 5, 6 ,7 8
          if AddressSlot_QueueFunctionDCCMessage(Slot, 2, False) then
            ErrorCode := E_PC_SUCCESS
        end;
      %00100010 : (*$22*)   // Set Function Operation on Group 3 ( on/off )  Functions F12..F9 Status
        begin
          Slot^.Functions := Slot^.Functions and $E1FF;                             // Clear bits 9, 10, 11, 12
          Slot^.Functions := Slot^.Functions or (XpressNetMessage^.Bytes[3] shl 9); // Set the new bits 5, 6 ,7 8
          if AddressSlot_QueueFunctionDCCMessage(Slot, 3, False) then
            ErrorCode := E_PC_SUCCESS
        end;
      %00100011 : (*$23*)   // Set Function Operation on Group 4 ( on/off ) Functions F20..F13 Status
        begin
          Slot^.FunctionsEx := Slot^.FunctionsEx and $FF00;                         // Clear bits 0..7
          Slot^.FunctionsEx := Slot^.FunctionsEx or XpressNetMessage^.Bytes[3];     // Set the new bits 0, 1, 2, 3
          if AddressSlot_QueueFunctionDCCMessage(Slot, 4, False) then
            ErrorCode := E_PC_SUCCESS
        end;
      %00101000 : (*$28*)   // Set Function Operation on Group 5 ( on/off )  Functions F12..F9 Status
        begin
          Slot^.FunctionsEx := Slot^.FunctionsEx and $00FF;                               // Clear bits 8..15
          Slot^.FunctionsEx := Slot^.FunctionsEx or (XpressNetMessage^.Bytes[3] shl 8);   // Set the new bits 4, 5, 6, 7
          if AddressSlot_QueueFunctionDCCMessage(Slot, 5, False) then
            ErrorCode := E_PC_SUCCESS
        end;
    end
  end;
  if iDevice = ID_PC_DEVICE then // The PC needs a response
    Send_PCMessage(ErrorCode);    }
end;


// *****************************************************************************
//
// procedure SetFunctionStateRequest
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Description:  Called by [$E4 $24 ....]   Momentary/Continious State of the Function for Group 1
//                          [$E4 $25 ....]   Momentary/Continious State of the Function for Group 2
//                          [$E4 $26 ....]   Momentary/Continious State of the Function for Group 3
//                          [$E4 $27 ....]   Momentary/Continious State of the Function for Group 4
//                          [$E4 $2C ....]   Momentary/Continious State of the Function for Group 5
//
//  Device Request           : Paragraph 2.2.20.5
//  Command Station Response : None
//  Status:
//     Complete 1/30/2011
//
// *****************************************************************************
procedure SetFunctionStateRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  Slot: PAddressSlot;
  ErrorCode: Byte;  }
begin
{  ErrorCode := E_PC_UNKNOWN;
  Slot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2), True); // AutoAllocate
  if Slot <> nil then
  begin
    // Valid for:
    //     - Consist address can have momentary/continious states of functions (review this)
    //     - MU can operate the functions of individual decoders
    //     - Double Header can operate the functions of individual decoders
    //     - Single decoder can operate its functions
    AssignDeviceToSlot(Slot, iDevice);

    case XpressNetMessage^.Bytes[0] of   // Identification
      %00100100 : (*$24*)   // Set Function Operation on Group 1 ( on/off )   Functions F0..F4 Status
        begin
          Slot^.FunctionType := Slot^.FunctionType and $FFE0;                             // Clear bits 0, 1, 2, 3, 4   (Note the order is F0-F4-F3-F2-F1)
          Slot^.FunctionType := Slot^.FunctionType or XpressNetMessage^.Bytes[3];          // Set the new bits 5, 6 ,7 8
          ErrorCode := E_PC_SUCCESS
        end;
      %00100101 : (*$25*)   // Set Function Operation on Group 2 ( on/off ) Functions F8..F5 Status
        begin
          Slot^.FunctionType := Slot^.FunctionType and $FE1F;                             // Clear bits 5, 6 ,7 8
          Slot^.FunctionType := Slot^.FunctionType or (XpressNetMessage^.Bytes[3] shl 5); // Set the new bits 5, 6 ,7 8
          ErrorCode := E_PC_SUCCESS
        end;
      %00100110 : (*$26*)   // Set Function Operation on Group 3 ( on/off ) Functions F12..F9 Status
        begin
          Slot^.FunctionType := Slot^.FunctionType and $E1FF;                             // Clear bits 9, 10, 11, 12
          Slot^.FunctionType := Slot^.FunctionType or (XpressNetMessage^.Bytes[3] shl 9); // Set the new bits 5, 6 ,7 8
          ErrorCode := E_PC_SUCCESS
        end;
      %00100111 : (*$27*)   // Set Function Operation on Group 4 ( on/off )  Functions F20..F13 Status
        begin
          Slot^.FunctionTypeEx := Slot^.FunctionTypeEx and $FF00;                         // Clear bits 1..7
          Slot^.FunctionTypeEx := Slot^.FunctionTypeEx or XpressNetMessage^.Bytes[3];     // Set the new bits 1-7
          ErrorCode := E_PC_SUCCESS
        end;
      %00101100 : (*$2C*)   // Set Function Operation on Group 5 ( on/off )               Functions F28..F21 Status
        begin
          Slot^.FunctionTypeEx := Slot^.FunctionTypeEx and $00FF;                               // Clear bits 8..15
          Slot^.FunctionTypeEx := Slot^.FunctionTypeEx or (XpressNetMessage^.Bytes[3] shl 8);   // Set the new bits 8-15
          ErrorCode := E_PC_SUCCESS
        end;
      end
   end;
  if iDevice = ID_PC_DEVICE then  // The PC needs a response
    Send_PCMessage(ErrorCode);  }
end;

// *****************************************************************************
//
// procedure EstablishDoubleHeader_V2(iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.21.1
//  Command Station Response : 2.1.20
//  Status:
//     Complete 1/28/2011
//
// *****************************************************************************
procedure EstablishDoubleHeaderV2(iDevice: Byte);
begin
  Send_InstructionNotSupported(iDevice)
end;

// *****************************************************************************
//
// procedure DisolveDoubleHeader_V2(iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.21.2
//  Command Station Response : 2.1.20
//  Status:
//     Complete 1/28/2011
//
// *****************************************************************************
procedure DisolveDoubleHeaderV2(iDevice: Byte);
begin
  Send_InstructionNotSupported(iDevice)
end;

// *****************************************************************************
//
// procedure FunctionRefreshMode(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph ???????  (2.2.26.5 in the German document)  XpressNet v3.6
//  Command Station Response : 2.1.20
//  Status:
//     Complete TBD
//
// *****************************************************************************
procedure FunctionRefreshMode(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
begin
  Send_InstructionNotSupported(iDevice)
end;


// *****************************************************************************
//
// procedure EstablishDoubleHeaderV3(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.22.1
//  Command Station Response : 2.1.21
//  Status:
//     Complete TBD
//
// *****************************************************************************
procedure EstablishDoubleHeaderV3(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  Slot1, Slot2: PAddressSlot;
  Address1, Address2: Word;   }
begin
 { Address1 := ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2);
  Address2 := ExtractAddressFromXpressNetMessage(XpressNetMessage, 3, 4);
  
  Slot1 := AddressSlot_FindSlot(Address1, True);
  Slot2 := AddressSlot_FindSlot(Address2, True);

  if (Slot1 <> nil) and (Slot2 <> nil) then
  begin
    if Slot1 <> Slot2 then
    begin
      if (Slot1^.OwnerDevice <> iDevice) or (Slot2^.OwnerDevice <> iDevice) or (Address1 = 0) or (Address2 = 0) then
        Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_LOCO_NOT_OWNED_BY_DEVICE)
      else
      if (Slot1^.OwnerDevice <> iDevice) or (Slot2^.OwnerDevice <> iDevice) then
        Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_LOCO_OPERATED_BY_ANOTHER_DEVICE)
      else
      if (Slot1^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT = 1) or (Slot2^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT = 1) or
         (Slot1^.Flags.ADDRESS_SLOT_FLAGS_MU_BIT = 1) or (Slot2^.Flags.ADDRESS_SLOT_FLAGS_MU_BIT = 1) then
        Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_ALREADY_IN_DH_MU)
      else
      if not IsMobileSlotStopped(Slot1) or not IsMobileSlotStopped(Slot2) then
        Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_SPEED_NOT_ZERO)
      else begin
        Slot1^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT := 1;
        Slot2^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT := 1;
        Slot1^.NextSlot := Word( Slot2);         // Link them together
        Slot2^.PrevSlot := Word( Slot1);
        // The PC needs a response
        if iDevice = ID_PC_DEVICE then
          Send_PCMessage(E_PC_SUCCESS);
      end
    end else
      Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_ALREADY_IN_DH_MU);  // Duplicate Address
  end else
    Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_STACK_IS_FULL);    }
end;

// *****************************************************************************
//
// procedure DissolveDoubleHeaderV3(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.22.2
//  Command Station Response : 2.1.21
//  Status:
//     Complete TBD
//
// *****************************************************************************
procedure DissolveDoubleHeaderV3(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  Slot1, Slot2: PAddressSlot;    }
begin
{  Slot1 := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2),  False); // Should already exist
  if (Slot1 <> nil) then
  begin
    // Assumed to be linked but not sure which direction
    Slot2 := AddressSlot_ExtractDoubleHeaderSecondSlot(Slot1);
    if Slot2 <> nil then    // If not linked then there is a problem
    begin
      Slot1^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT := 0;
      Slot2^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT := 0;
      Slot1^.NextSlot := 0;
      Slot1^.PrevSlot := 0;
      Slot2^.PrevSlot := 0;
      Slot2^.NextSlot := 0;
      if iDevice = ID_PC_DEVICE then   // The PC needs a response
        Send_PCMessage(E_PC_SUCCESS);
    end else
      Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_CAN_NOT_DELETE)
  end else
    Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_CAN_NOT_DELETE); }
end;

// *****************************************************************************
//
// procedure OperationsModeRequest
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Description:  Called by [$E6 $30 ....]   Operations Mode Programming
//
//  Device Request           : Paragraph 2.2.23.1
//  Command Station Response : None
//  Status:
//     Complete TBD
//
// *****************************************************************************
procedure OperationsModeRequest(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  Slot: PAddressSlot;
  AddressHi, AddressLo: Byte;
  CV: Word;       }
begin
{  Slot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2), True); // AutoAllocate
  if Slot <> nil then
  begin
    AddressHi := 0;
    AddressLo := 0;
    AddressSlot_EncodeAddressToNMRA_Format(Slot, AddressHi, AddressLo, False);
    CV := (XpressNetMessage^.Bytes[3] and %00000011) shr 8;
    CV := XpressNetMessage^.Bytes[4] or CV;

    case (XpressNetMessage^.Bytes[3] and %11111100) of
      %11101100:  (*$EC*)   // 2.2.23.1  Operations Mode Programming byte mode write request
        begin
          if CommandStation.FlagsEx.COMMANDSTATION_FLAGSEX_POM_COMMAND_MODE = 1 then
          begin
            if CV = 7 then
            begin
              case XpressNetMessage^.Bytes[5] of
                93: begin end;  // Turn RailCom ON
                92: begin end;  // Turn RailCom OFF
                94: begin end;  // 3 Byte Blanking Window
                95: begin end;  // 4 Byte Blanking Window
                88: begin end;  // "normal Small Window"
                89: begin end;  // NCE compatibility Small Window
                70: begin end;  // Decrease Window by 6us
                71: begin end;  // Increase Window by 6us
              end; // case
            end;
            CommandStation.FlagsEx.COMMANDSTATION_FLAGSEX_POM_COMMAND_MODE := 0;  // Drop out of the mode
          end else
          begin
            if (CV = 7) and (XpressNetMessage^.Bytes[5] = 50) then                  // Command Station Setup Special Instruction coming next
            begin
              CommandStation.FlagsEx.COMMANDSTATION_FLAGSEX_POM_COMMAND_MODE := 1;  // Set the flag to enter this special mode
              CommandStation.PoMCommandTimeoutCount := 0;                           // Start the timer
            end else
              Send_PoM_Message(AddressHi, AddressLo, XpressNetMessage);
          end
        end;
      %11100100, (*$E4*)   // 2.2.23.x  Operations Mode Programming byte mode read request (XpressNet only v3.6; 2.2.28.2 in the German document)
      %11111000  (*$E8*):  // 2.2.23.2  Operations Mode Programming bit mode write request  (Mistake in the XpressNet Document, Binary = 1111 10CC Hex = 0xE8 which is correct at 1110 10CC)
        Send_PoM_Message(AddressHi, AddressLo, XpressNetMessage);
    end;
  end;
  if iDevice = ID_PC_DEVICE then  // The PC needs a response
    Send_PCMessage(E_PC_SUCCESS);      }
end;

// *****************************************************************************
//
// procedure AddLocomotiveToMU_Request(XpressNetMessage: PXpressNetMessage; iDevice: Byte; Backward: Boolean);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//              Backward: Search Backwards
//
//  Device Request           : Paragraph 2.2.24.1
//  Command Station Response : 2.1.21
//  Status:
//     Complete TBD
//
// *****************************************************************************
procedure AddLocomotiveToMU_Request(XpressNetMessage: PXpressNetMessage; iDevice: Byte; Backward: Boolean);
{var
  LocoSlot, ConsistSlot: PAddressSlot;
  Address: Word;         // Loco Address
  ConsistAddress: Byte;     // Consist Addresss
  NewDCCMessage: TDCCQueueMessage;
  i: Byte;       }
begin
 { Address := ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2);
  ConsistAddress := XpressNetMessage^.Bytes[3];
  
  if Address <> ConsistAddress then        // Loco Address can't be the same as the Consist Address
  begin
    LocoSlot := AddressSlot_FindSlot(Address, True);               // Find the Slots based on the Addresses
    
    if LocoSlot <> nil then
    begin
      if AddressSlot_InMUorDoubleHeader(LocoSlot) then
        Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_ALREADY_IN_DH_MU)
      else begin
        ConsistSlot := AddressSlot_FindSlot(ConsistAddress, False);    // Need to know if the ConsistAddress already exists

        if ConsistSlot = nil then
        begin                                                          // Constist Address does not exist, create it
          ConsistSlot := AddressSlot_Allocate(ConsistAddress);
          if ConsistSlot <> PAddressSlot( nil) then
            ConsistSlot^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT := 1;   // If we get here then this must be true
        end else
        begin
          if ConsistSlot^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 0 then  // A Loco already has this address assigned
          begin
            Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_LOCO_NOT_MU_BASE_ADDRESS);
            Exit;
          end;
        end;
        
        if ConsistSlot <> nil then
        begin
          AddressSlot_InsertSlotIntoMU_Chain( LocoSlot, AddressSlot_WalkMU_ChainLast(ConsistSlot), SLOT_INSERT_NEXT);

          NewDCCMessage.MessageBytes[0] := Hi( Address) or %11000000;
          NewDCCMessage.MessageBytes[1] := Lo( Address);
          if Backward then
            NewDCCMessage.MessageBytes[2] := %00010011    // Reverse Direction
          else
            NewDCCMessage.MessageBytes[2] := %00010010;   // Forward Direction
          NewDCCMessage.MessageBytes[3] := ConsistAddress; // MTR address
          NewDCCMessage.Flags := 4;

          i := 0;
          while i < 3 do     // Make sure we send it 3 times
          begin
            if NMRA_DCC_QueueMessage(@Track, @NewDCCMessage, False) then
              Inc(i)
          end;

          if iDevice = ID_PC_DEVICE then // PC needs a response
            Send_PCMessage(E_PC_SUCCESS)
        end else
          Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_STACK_IS_FULL);
      end
    end
  end else
    Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_LOCO_NOT_MU_BASE_ADDRESS);  // Send error, can't have a loco and consist address the same....  }
end;

// *****************************************************************************
//
// procedure RemoveLocomotiveFromMU_Request(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 2.2.24.2
//  Command Station Response : 2.1.21
//  Status:
//     Complete TBD
//
// *****************************************************************************

procedure RemoveLocomotiveFromMU_Request(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  LocoSlot, ConsistSlot: PAddressSlot;
  NewDCCMessage: TDCCQueueMessage;
  i: Byte;                }
begin
{  LocoSlot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2), False); // Should already exist
  ConsistSlot := AddressSlot_FindSlot(XpressNetMessage^.Bytes[3], False);                              // Should already exist

  if (LocoSlot <> nil) and (ConsistSlot <> nil) then
  begin
    if ConsistSlot^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 1 then
    begin
      if AddressSlot_ExtractSlotFromMU_Chain(LocoSlot) then    // If the passed address is in the list then remove the loco
      begin
        NewDCCMessage.MessageBytes[0] := Hi( LocoSlot^.Address) or %11000000;
        NewDCCMessage.MessageBytes[1] := Lo( LocoSlot^.Address);
        NewDCCMessage.MessageBytes[2] := %00010010;
        NewDCCMessage.MessageBytes[3] := %00000000;       //  Exit Consist Mode
        NewDCCMessage.Flags := 4;
        
        i := 0;
        while i < 3 do     // Make sure we send it 3 times
        begin
          if NMRA_DCC_QueueMessage(@Track, @NewDCCMessage, False) then
            Inc(i)
        end;

        if ConsistSlot^.NextSlot = 0 then
          AddressSlot_Free(ConsistSlot);   // Release the Consist Address

        if iDevice = ID_PC_DEVICE then // PC needs a response
          Send_PCMessage(E_PC_SUCCESS)
      end else
        Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_CAN_NOT_DELETE);
    end else
      Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_CAN_NOT_DELETE);
  end else
    Send_DoubleHeader_MU_Error(iDevice, E_DH_MU_ERROR_CAN_NOT_DELETE);       }
end;

// *****************************************************************************
//
// procedure AddressInquiryOfMember_MU_Request(XpressNetMessage: PXpressNetMessage; iDevice: Byte; Backward: Boolean);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//              Backward: Search Backwards
//
//  Device Request           : Paragraph 2.2.25.1
//  Command Station Response : 2.1.17
//
// *****************************************************************************
procedure AddressInquiryOfMember_MU_Request(XpressNetMessage: PXpressNetMessage; iDevice: Byte; Backward: Boolean);
{var
  LocoSlot, ConsistSlot: PAddressSlot;
  Address: Word;    }
begin
{  ConsistSlot := AddressSlot_FindSlot(XpressNetMessage^.Bytes[1], False);     // Should already exist
  Address := ExtractAddressFromXpressNetMessage(XpressNetMessage, 2, 3);
  if Address <> 0 then
  begin
    LocoSlot := AddressSlot_FindSlot(Address, False);                         // Should already exist
    if LocoSlot <> nil then
    begin
      if ConsistSlot = AddressSlot_WalkMU_ChainRoot(LocoSlot) then               // Make sure the passed address is in the passed consist list
      begin
        if Backward then
          Send_AddressRetrievalInfo(iDevice, AddressSlot_WalkMU_ChainPrev(LocoSlot))
        else
          Send_AddressRetrievalInfo(iDevice, AddressSlot_WalkMU_ChainNext(LocoSlot))
      end else
        Send_AddressRetrievalInfo(iDevice, PAddressSlot( nil))
    end else
      Send_AddressRetrievalInfo(iDevice, PAddressSlot( nil));
  end else
  begin
    // The caller does not know any members of the MU
    if Backward then
      Send_AddressRetrievalInfo( iDevice, AddressSlot_WalkMU_ChainLast(ConsistSlot))
    else
      Send_AddressRetrievalInfo(iDevice, AddressSlot_WalkMU_ChainFirst(ConsistSlot));
  end;  }
end;

// *****************************************************************************
//
// procedure AddressInquiryOf_MU_Request(XpressNetMessage: PXpressNetMessage; iDevice: Byte; Backward: Boolean);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//              Backward: Search Backwards
//
//  Device Request           : Paragraph 2.2.25.2
//  Command Station Response : 2.1.17
//  Status:
//     Complete TBD
//
// *****************************************************************************
procedure AddressInquiryOf_MU_Request(XpressNetMessage: PXpressNetMessage; iDevice: Byte; Backward: Boolean);
{var
  ConsistSlot: PAddressSlot;
  ConsistAddress: Byte;  }
begin
 { ConsistAddress := XpressNetMessage^.Bytes[1];
  if ConsistAddress <> 0 then
  begin
    ConsistSlot := AddressSlot_FindSlot(ConsistAddress, False);     // Should already exist
    if ConsistSlot <> nil then
    begin
      if Backward then
        Send_AddressRetrievalInfo(iDevice, AddressSlot_WalkMU_ChainPrevConsist(ConsistSlot))
      else
        Send_AddressRetrievalInfo(iDevice, AddressSlot_WalkMU_ChainNextConsist(ConsistSlot))
    end else
      Send_AddressRetrievalInfo(iDevice, PAddressSlot( nil))
  end else
  begin
    // The caller does not know any Consist Address
    if Backward then
      Send_AddressRetrievalInfo( iDevice, AddressSlot_WalkMU_ChainLastConsist)
    else
      Send_AddressRetrievalInfo(iDevice, AddressSlot_WalkMU_ChainFirstConsist);
  end;   }
end;

// *****************************************************************************
//
// procedure AddressInquiryLocoStack(XpressNetMessage: PXpressNetMessage; iDevice: Byte; Backward: Boolean);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//              Backward: Search Backwards
//
//  Device Request           : Paragraph 2.2.25.3
//  Command Station Response : 2.1.17
//  Status:
//     Complete TBD
//
// *****************************************************************************
procedure AddressInquiryLocoStack(XpressNetMessage: PXpressNetMessage; iDevice: Byte; Backward: Boolean);
{var
  LocoSlot: PAddressSlot;
  Address: Word;  }
begin
{  Address := ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2);
  if Address = 0 then
  begin
    // Caller wants first address in the stack
    if Backward then
      Send_AddressRetrievalInfo(iDevice, AddressSlot_WalkStackLast)
    else
      Send_AddressRetrievalInfo(iDevice, AddressSlot_WalkStackFirst)
  end else
  begin
    LocoSlot := AddressSlot_FindSlot(Address, False);
    if LocoSlot <> nil then
    begin
      if Backward then
        Send_AddressRetrievalInfo(iDevice, AddressSlot_WalkStackPrev(LocoSlot))
      else
        Send_AddressRetrievalInfo(iDevice, AddressSlot_WalkStackNext(LocoSlot))
    end else
      Send_AddressRetrievalInfo(iDevice, PAddressSlot( nil));
  end   }
end;

// *****************************************************************************
//
// procedure AddressInquiryLocoDeleteFromStack(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//              Backward: Search Backwards
//
//  Device Request           : Paragraph 2.2.26
//  Command Station Response : None
//  Status:
//     Complete TBD
//
// *****************************************************************************
procedure AddressInquiryLocoDeleteFromStack(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
 {var
  LocoSlot: PAddressSlot;    }
begin
{ LocoSlot := AddressSlot_FindSlot(ExtractAddressFromXpressNetMessage(XpressNetMessage, 1, 2), False);
  if LocoSlot <> nil then
    AddressSlot_Free(LocoSlot);

  if iDevice = ID_PC_DEVICE then  // The PC needs a response
    Send_PCMessage(E_PC_SUCCESS); }
end;

// *****************************************************************************
//
// procedure PC_Interface_VersionNumber(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//              Backward: Search Backwards
//
//  Device Request           : Paragraph 1.5.4
//  Command Station Response : 1.5.4
//  Status:
//     Complete 1/30/2011
//
// *****************************************************************************
procedure PC_Interface_VersionNumber(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
begin
  // TODO
  // 1.5.4
  XpressNetMessage^.HeaderByte := %00000010;
  XpressNetMessage^.Bytes[0] := VERSION_HARDWARE_PC_INERFACE; // Hardware version
  XpressNetMessage^.Bytes[1] := VERSION_SOFTWARE_PC_INERFACE; // Software
  XpressNetMessage^.DataCount := 2;
  SendXpressNetMessage(XpressNetMessage, %00000000, iDevice);
end;

// *****************************************************************************
//
// procedure PC_Interface_SetAddress(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//              Backward: Search Backwards
//
//  Device Request           : Paragraph 1.5.5
//  Command Station Response : 1.5.5
//  Status:
//     Complete 1/30/2011
//
// *****************************************************************************
procedure PC_Interface_SetAddress(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
begin
  XpressNetMessage^.HeaderByte := %11110010;
  XpressNetMessage^.Bytes[0] := %00000001;
  XpressNetMessage^.Bytes[1] := $20;           // Set it for Address 32 because it takes no address
  XpressNetMessage^.DataCount := 2;
  SendXpressNetMessage(XpressNetMessage, %00000000, iDevice);
end;

// *****************************************************************************
//
// procedure PC_Interface_SetBaudRate(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Device Request           : Paragraph 1.5.6
//  Command Station Response : 1.5.6
//  Status:
//     Complete 1/30/2011
//
// *****************************************************************************
procedure PC_Interface_SetBaudRate(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
{var
  OldBaud: Word;    }
begin
  // 1.5.6
 { OldBaud := ((CommandStation.Flags and MASK_COMMANDSTATION_FLAGS_BAUD_RATE) shr COMMANDSTATION_FLAGS_BAUD_RATE_OFFSET) + 1;
  if (XpressNetMessage^.Bytes[1] >= 0) and (XpressNetMessage^.Bytes[1] <= 4) then
  begin
     // Clear the current Baud Rate
    CommandStation.Flags := CommandStation.Flags and not MASK_COMMANDSTATION_FLAGS_BAUD_RATE;
    case XpressNetMessage^.Bytes[1] of
      BAUD_RATE_XPRESSNET_PC_INTERFACE_19200 : CommandStation.Flags := CommandStation.Flags or COMMANDSTATION_FLAGS_BAUD_RATE_19200;
      BAUD_RATE_XPRESSNET_PC_INTERFACE_38400 : CommandStation.Flags := CommandStation.Flags or COMMANDSTATION_FLAGS_BAUD_RATE_38400;
      BAUD_RATE_XPRESSNET_PC_INTERFACE_57600 : CommandStation.Flags := CommandStation.Flags or COMMANDSTATION_FLAGS_BAUD_RATE_57600;
      BAUD_RATE_XPRESSNET_PC_INTERFACE_115200 : CommandStation.Flags := CommandStation.Flags or COMMANDSTATION_FLAGS_BAUD_RATE_115200;
    end;
    XpressNetMessage^.HeaderByte := %11110010;
    XpressNetMessage^.Bytes[0] := %00000010;
    XpressNetMessage^.Bytes[1] := OldBaud;
    XpressNetMessage^.DataCount := 2;
    SendXpressNetMessage(XpressNetMessage, %00000000, iDevice);  // Reply at the old baud rate
    CommandStation_SetupBaud_Rate;
  end else
  begin
    XpressNetMessage^.HeaderByte := %11110010;
    XpressNetMessage^.Bytes[0] := %00000010;
    XpressNetMessage^.Bytes[1] := OldBaud;
    XpressNetMessage^.DataCount := 2;
    SendXpressNetMessage(XpressNetMessage, %00000000, iDevice);
  end    }
end;

// *****************************************************************************
// procedure HandleDeviceInstruction(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
//
//  Parameters:
//              XpressNetMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS232 PC link
//
//  Description:
//              Dispatches the instruction sent by the Device
//
// *****************************************************************************
procedure XpressNet_HandleDeviceInstruction(XpressNetMessage: PXpressNetMessage; iDevice: Byte);
begin
  // Divide and Conquer
  case XpressNetMessage^.Instruction of
    %00100000:  // 0010 xxxx {$2x}
      begin
        case XpressNetMessage^.DataCount of
          1: begin
               case XpressNetMessage^.Bytes[0] of
                 %10000001 (*$81*): ResumeOperationsRequest(XpressNetMessage);                       // 2.2.2  Resume operations request
                 %10000000 (*$80*): StopOperationsRequest(XpressNetMessage);                         // 2.2.3  Stop operations request (emergency off)
                 %00010000 (*$10*): ServiceModeResultsRequest(iDevice);                              // 2.2.10 Request for Service Mode results;
                 %00100001 (*$21*): CommandStationSoftwareVersionRequest(XpressNetMessage, iDevice); // 2.2.14 Command station software-version request
                 %00100100 (*$24*): CommandStationStatusRequest(XpressNetMessage, iDevice)           // 2.2.15 Command station status request
               else
                 Send_InstructionNotSupported(iDevice);
               end;
             end;
          2: begin
               case XpressNetMessage^.Bytes[0] of
                 %00010001 (*$11*): RegisterModeReadRequest(@XpressNetMessage^.Bytes, iDevice);      // 2.2.7  Register Mode read request (Register Mode)
                 %00010101,(*$15*)                                                                   // 2.2.8  Direct Mode CV read request (CV mode)
                 %00011000,(*$18*)                                                                   // 4-Byte-Format (CV 1-255 und CV1024) (v3.6)
                 %00011001,(*$19*)                                                                   // 4-Byte-Format (CV 256-511)) (v3.6)
                 %00011010,(*$1A*)                                                                   // 4-Byte-Format (CV 512-767) (v3.6)
                 %00011011 (*$1B*): DirectModeReadRequest(@XpressNetMessage^.Bytes, iDevice);        // 4-Byte-Format (CV 768-1023) (v3.6)
                 %00010100 (*$14*): PagedModeReadRequest(@XpressNetMessage^.Bytes, iDevice);         // 2.2.9  Paged Mode read request (Paged Mode)
                 %00100010 (*$22*): SetCommandStationPowerUpMode(XpressNetMessage, iDevice)          // 2.2.16 Set command station power-up mode
               else
                 Send_InstructionNotSupported(iDevice);
               end;
             end;
          3: begin
               case XpressNetMessage^.Bytes[0] of
                 %00010010 (*$12*): RegisterModeWriteRequest(@XpressNetMessage^.Bytes, iDevice);     // 2.2.11 Register Mode write request (Register Mode)
                 %00011100,(*$16*)                                                                   // 2.2.12 Direct Mode write request (CV Mode) (CV 1-255) and 256)
                 %00011111,(*$1C*)                                                                   // 4-Byte-Format (CV 1-255 and CV1024) (v3.6)
                 %00011110,(*$1D*)                                                                   // 4-Byte-Format (CV 256-511)) (v3.6)
                 %00011101,(*$1E*)                                                                   // 4-Byte-Format (CV 512-767) (v3.6)
                 %00010110 (*$1F*): DirectModeWriteRequest(@XpressNetMessage^.Bytes, iDevice);       // 4-Byte-Format (CV 768-1023) (v3.6)
                 %00010111 (*$17*): PagedModeWriteRequest(@XpressNetMessage^.Bytes, iDevice)         // 2.2.13 Register Mode write request (Paged Mode)
               else
                 Send_InstructionNotSupported(iDevice);
               end;
             end
          else
            Send_InstructionNotSupported(iDevice);
        end;
      end;
    %10000000:  // 1000 xxxx {$8x}
      begin
        case XpressNetMessage^.DataCount of
          0: StopAllLocomotivesRequest(XpressNetMessage, iDevice)                                   // 2.2.4  Stop all locomotives request (emergency stop)
        else
          Send_InstructionNotSupported(iDevice);
        end
      end;
    %10010000:  // 1001 xxxx {$9x}
      begin
        case XpressNetMessage^.DataCount of
          1: EmergencyStopLocomotiveRequestV2_Down(iDevice);                                         // 2.2.5.1 Emergency stop a locomotive (X-Bus V1 and V2)
          2: EmergencyStopLocomotiveRequestV3(XpressNetMessage, iDevice)                             // 2.2.5.2 Emergency stop a locomotive (XpressNet)
        else
          Send_InstructionNotSupported(iDevice);
        end;        
      end;
    %10100000:  // 1010 xxxx {$Ax}
      begin
        case XpressNetMessage^.DataCount of
          1: LocomotiveInformationRequestV1(iDevice);                                                // 2.2.19.1 Locomotive information requests (X-Bus V1)
          2: LocomotiveInformationRequestV2(iDevice)                                                 // 2.2.19.2 Locomotive information requests (X-Bus V1 and V2)
        else
          Send_InstructionNotSupported(iDevice);
        end;
      end;
    %11100000:  // 1110 xxxx {$Ex}
      begin
        case XpressNetMessage^.DataCount of
          3: begin
               case XpressNetMessage^.Bytes[0] of
                 %00000000 (*$00*): LocomotiveInformationRequestV3(XpressNetMessage, iDevice);       // 2.2.19.3 Locomotive information requests (XpressNet only) [QUERIES the Function on/off State state (F0-F12)]
                 %00000111 (*$07*): FunctionStatusRequest(XpressNetMessage, iDevice);                // 2.2.19.4 Function momentary/continious status request (XpressNet only)  [QUERIES the momentary or on/off state] [QUERIES the momentary or on/off state (F0-F12)]
                 %00001000 (*$08*): FunctionStateRequestEx(XpressNetMessage, iDevice);               // 2.2.19.5 Function momentary/continious status request (XpressNet only v3.6; 2.2.25.2 in the German document)    [QUERIES the momentary or on/off state (F13-F28)]
                 %00001001 (*$09*): FunctionOperationRequestEx(XpressNetMessage, iDevice);           // 2.2.19.6 Function on/off status request (XpressNet only v3.6; 2.2.25.3 in the German document)    [QUERIES the Function State state (F13-F28)]
                 %00000101, %00000110 (*$05, $06*): AddressInquiryLocoStack(XpressNetMessage, iDevice, XpressNetMessage^.Bytes[0] = %00000110);  // 2.2.25.3 Address inquiry locomotive at command station stack request
                 %01000100 (*$68*): AddressInquiryLocoDeleteFromStack(XpressNetMessage, iDevice)     // 2.2.26 Delete locomotive from command station stack request
               else
                 Send_InstructionNotSupported(iDevice);
               end;
             end;
          4: begin
               case XpressNetMessage^.Bytes[0] of
                 %00010000, (*$10*) // 14 Step
                 %00010001, (*$11*) // 27 Step
                 %00010010, (*$12*) // 28 Step
                 %00010011: (*$13*) // 128 Step
                   SetLocomotiveSpeedAndDirectionRequest(XpressNetMessage, iDevice);                 // 2.2.20.3  Format - Speed and direction instruction
                 %00100000, (*$20*)   // Set Function Operation on Group 1 ( on/off )
                 %00100001, (*$21*)   // Set Function Operation on Group 1 ( on/off )
                 %00100010, (*$22*)   // Set Function Operation on Group 1 ( on/off )
                 %00100011, (*$23*)   // Set Function Operation on Group 1 ( on/off )
                 %00101000: (*$28*)   // Set Function Operation on Group 1 ( on/off )
                    SetFunctionOperationRequest(XpressNetMessage, iDevice);                          // 2.2.20.4 Format - Function instruction group 1-5:  [SETS the momentary or on/off state]
                 %00100100, (*$24*)  // Set Function State on Group 1 ( momentary/continious )
                 %00100101, (*$25*)  // Set Function State on Group 2 ( momentary/continious )
                 %00100110, (*$26*)  // Set Function State on Group 3 ( momentary/continious )
                 %00100111, (*$27*)  // Set Function State on Group 4 ( momentary/continious )
                 %00101100: (*$2C*)  // Set Function State on Group 5 ( momentary/continious )
                   SetFunctionStateRequest(XpressNetMessage, iDevice);                               // 2.2.20.5 Format - Set Function state group 5: (XpressNet only v3.6; 2.2.26.4 in the German document) [SETS the Function State]
                 %01000000, %01000001 (*$40, $41*): AddLocomotiveToMU_Request(XpressNetMessage, iDevice, XpressNetMessage^.Bytes[0] = %01000001);  // 2.2.24.1 Add a locomotive to a multi-unit request [SETS the Function State]
                 %01000010 (*$42*): RemoveLocomotiveFromMU_Request(XpressNetMessage, iDevice);                    // 2.2.24.2 Remove a locomotive from a Multi-unit request
                 %00000001, %00000010: AddressInquiryOfMember_MU_Request(XpressNetMessage, iDevice, XpressNetMessage^.Bytes[0] = %00000010);       // 2.2.25.1 Address inquiry member of a Multi-unit request
                 %00000011, %00000100: AddressInquiryOf_MU_Request(XpressNetMessage, iDevice, XpressNetMessage^.Bytes[0] = %00000100)              // 2.2.25.2 Address inquiry Multi-unit request
               else
                 Send_InstructionNotSupported(iDevice);
               end;
             end;
          5: begin
               case XpressNetMessage^.Bytes[0] of
                 %01000011 (*$43*):
                   begin
                     if (XpressNetMessage^.Bytes[3] = 0) and (XpressNetMessage^.Bytes[4] = 0) then
                       DissolveDoubleHeaderV3(XpressNetMessage, iDevice)            // 2.2.22.2 Dissolve Double Header
                     else
                       EstablishDoubleHeaderV3(XpressNetMessage, iDevice)           // 2.2.22.1 Establish Double Header
                   end;
                 %00101111 (*$2F*): FunctionRefreshMode(XpressNetMessage, iDevice) // ?????? ?????  (XpressNet only v3.6; 2.2.26.5 in the German document)
               else
                 Send_InstructionNotSupported(iDevice);
               end;
             end;
          6: begin
               case XpressNetMessage^.Bytes[0] of
                 %00110000 (*$30*): OperationsModeRequest(XpressNetMessage,  iDevice) // 2.2.23.1  Operations Mode Programming
                 else
                   Send_InstructionNotSupported(iDevice);
               end;
             end
          else
            Send_InstructionNotSupported(iDevice);
        end;
      end;
    %10110000:  // 1011 xxxx {$Bx}
      begin
        case XpressNetMessage^.DataCount of
          3: LocomotiveOperationRequestV1(iDevice);            // 2.2.20.1 Locomotive operations (X-Bus V1)
          4: LocomotiveOperationRequestV2(iDevice)             // 2.2.20.2 Locomotive operations (X-Bus V2)
        else
          Send_InstructionNotSupported(iDevice);
        end;
      end;
    %01000000:  // 0100 xxxx {$4x}
      begin
        case XpressNetMessage^.DataCount of
          2: begin
               AccessoryInformationRequest(XpressNetMessage, iDevice);           // 2.2.17 Accessory Decoder information request
               AccessoryOperationRequest(XpressNetMessage, iDevice)              // 2.2.18 Accessory Decoder operation request
             end
        else
          Send_InstructionNotSupported(iDevice);
        end;
      end;
    %11000000:  // 1100 xxxx {$Cx}
      begin
        case XpressNetMessage^.DataCount of
          3: begin
               case XpressNetMessage^.Bytes[0] of
                 %00000101: EstablishDoubleHeaderV2(iDevice);  // 2.2.21.1 Establish Double Header
                 %00000100: DisolveDoubleHeaderV2(iDevice)     // 2.2.21.2 Dissolve Double Header
               else
                 Send_InstructionNotSupported(iDevice);
               end;
             end
          else
            Send_InstructionNotSupported(iDevice);
        end;
      end;
    %11110000:  // 1111 xxxx {$Fx}   // Sent by the PC interface for information about the PC to XpressBus interface (LI101F)
      begin
        case XpressNetMessage^.DataCount of
          0: PC_Interface_VersionNumber(XpressNetMessage, iDevice);              // 1.5.4 Determining the Version number of the LI100F and LI101
          2: begin
               case XpressNetMessage^.Bytes[0] of
                 1: PC_Interface_SetAddress(XpressNetMessage, iDevice);                 // 1.5.5 Determing and changing the XpressNet address for the LI101
                 2: PC_Interface_SetBaudRate(XpressNetMessage, iDevice)                 // 1.5.6 Determing and changing the Baud Rate for the LI101
               else
                 Send_InstructionNotSupported(iDevice);
               end;
            end
         else
           Send_InstructionNotSupported(iDevice);
         end;
      end
    else
      Send_InstructionNotSupported(iDevice);
  end
end;

// *****************************************************************************
//
//  procedure XpressNet_RequestAcknowledgment;
//
//  Parameters:
//              iDevice: The device ID that has the open window to send an Inquiry
//  Result:
//              None
//
//  Description:
//              Requests the device send an Acknowledge, called when the normal
//  Inquiry experienced an error on the Instruction Station receive side.
//  The XpressNetBuffer.XpressNetData.MessageReadResult  field contains the result 
//  of the Inquiry
//
// *****************************************************************************
procedure XpressNet_RequestAcknowledgment;
var
  Device: PDevice;
begin
  Device := @XpressNetBuffer.DeviceList[XpressNetBuffer.iActiveDevice];                                                               // 2.1.2 Request Acknowledgement from Device
  Xpressnet_RS485_Select := 1;                                                                                                        // Select the 485 chip to transmit mode
  WriteXpressNetByte( InsertHiBitParity(CALLBYTE_REQUEST_ACK_FROM_DEVICE or XpressNetBuffer.iActiveDevice), True, @U2TXREG, @U2STA);  // 000AAAAA
  Xpressnet_RS485_Select := 0;                                                                                                        // Select the 485 chip to receive mode ASAP
  ReadXpressNetBuss(@XpressNetBuffer.XpressNetData, @U2STA);                                                                          // Now wait for the response
  
  case XpressNetBuffer.XpressNetData.MessageReadResult of
    E_SUCCESS : Device^.Flags := Device^.Flags or MASK_XPRESSNET_DEVICE_ACTIVE_AND_ACKNOWLEDGING;                                      // Set the normal flags
    E_WINDOW_TIMEOUT,
    E_TRANSFER_XOR :                                                                                                                    // The time for the Communication Window with a device expired (Device does not exist?) Or The XOR Error Byte did not match
      begin                                                                                                                             // If the Device times out when an Ack is sent then, by the spec, it will only
        if Device^.Flags and MASK_XPRESSNET_DEVICE_ACTIVE <> 0 then                                                                     // receive Ack requests until it finally returns successfully.  Flag it as such
          Device^.Flags := Device^.Flags and not MASK_XPRESSNET_DEVICE_ACKNOWLEDGING;                                                   // but only if it was a previously active Device
      end;
  end;
end;

// *****************************************************************************
//
// procedure XpressNet_SendNormalInquiry;
//
//  Parameters:
//                None
//  Result:
//                True if successive, False if communication failed.  Will set the
//                DEVICE_FLAG_NOT_ACKNOWLEDGING flag if there was an error in acknowledging
//
//  Description:
//              Opens the Inquiry Window for the device ID passed in the
//   parameter.  Then handles the Inquiry.  The XpressNetBuffer.XpressNetData.MessageReadResult
//   field contains the result of the Inquiry
//
// *****************************************************************************
procedure XpressNet_SendNextNormalInquiryAndDispatch;
var
  Device: PDevice;
begin
  Device := @XpressNetBuffer.DeviceList[XpressNetBuffer.iActiveDevice];                                              // 2.1.1 Normal inquiry
  
  Xpressnet_RS485_Select := 1;                                                                                       // Select the 485 chip to transmit mode
  WriteXpressNetByte( InsertHiBitParity(CALLBYTE_INQUIRY or XpressNetBuffer.iActiveDevice), True, @U2TXREG, @U2STA); // Write to the Bus for a query
  Xpressnet_RS485_Select := 0;                                                                                       // Select the 485 chip to receive mode ASAP
  ReadXpressNetBuss(@XpressNetBuffer.XpressNetData, @U2STA);                                                         // Now wait for the Response
  
  case XpressNetBuffer.XpressNetData.MessageReadResult of
    E_SUCCESS :                                                                                                      // No problems, responded to the request
      begin
        Device^.Flags := Device^.Flags or MASK_XPRESSNET_DEVICE_ACTIVE_AND_ACKNOWLEDGING;                            // Set the normal flags
        XpressNet_HandleDeviceInstruction(@XpressNetBuffer.XpressNetData, XpressNetBuffer.iActiveDevice)
      end;
    E_TRANSFER_XOR :                                                                                                 // The XOR Error Byte did not match
      begin                                                                                                          // 2.1.8 Transfer Errors - Tell the device we had an error
        Xpressnet_RS485_Select := 1;                                                                                 // Select the 485 chip to transmit mode
        WriteXpressNetByte(CALLBYTE_TRANSFER_ERRORS or XpressNetBuffer.iActiveDevice, True, @U2TXREG, @U2STA);       // 011AAAAA
        WriteXpressNetByte($80, False, @U2TXREG, @U2STA);                                                            // 10000000
        WriteXpressNetByte($E1, False, @U2TXREG, @U2STA);                                                            // 11100001
        XpressNet_RequestAcknowledgment;
      end;
    E_BUS_HUNG :
      begin
      end;
  end
end;

end.