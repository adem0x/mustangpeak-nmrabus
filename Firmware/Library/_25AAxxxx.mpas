unit _25AAxxxx;

{$DEFINE EEPROM_ONE_BANK}
{$DEFINE EEPROM_TWO_BANK}
{.$DEFINE EEPROM_THREE_BANK}
{.$DEFINE EEPROM_FOUR_BANK}

const
  {$IFDEF EEPROM_ONE_BANK}EEPROM_BANK_0 = 0;  {$ENDIF}
  {$IFDEF EEPROM_TWO_BANK} EEPROM_BANK_1 = 1; {$ENDIF}
  {$IFDEF EEPROM_THREE_BANK}EEPROM_BANK_2 = 3;{$ENDIF}
  {$IFDEF EEPROM_FOUR_BANK}EEPROM_BANK_3 = 4; {$ENDIF}
  
type
  PByte = ^Byte;
  
var
  {$IFDEF EEPROM_ONE_BANK}CS_Bank_0: sbit; sfr; external; {$ENDIF}
  {$IFDEF EEPROM_TWO_BANK}CS_Bank_1: sbit; sfr; external; {$ENDIF}
  {$IFDEF EEPROM_THREE_BANK}CS_Bank_2: sbit; sfr; external; {$ENDIF}
  {$IFDEF EEPROM_FOUR_BANK}CS_Bank_3: sbit; sfr; external; {$ENDIF}
  
  {$IFDEF EEPROM_ONE_BANK}CS_Bank_0_Direction: sbit; sfr; external; {$ENDIF}
  {$IFDEF EEPROM_TWO_BANK}CS_Bank_1_Direction: sbit; sfr; external; {$ENDIF}
  {$IFDEF EEPROM_THREE_BANK}CS_Bank_2_Direction: sbit; sfr; external; {$ENDIF}
  {$IFDEF EEPROM_FOUR_BANK}CS_Bank_3_Direction: sbit; sfr; external; {$ENDIF}

procedure _25AAxxxx_Initialize;
procedure _25AAxxxx_Read(Bank: Word; Address: DWORD; Count: Word; Buffer: PByte);
procedure _25AAxxxx_Write(Bank: Word; Address: DWORD; Count: Word; Buffer: PByte);
function _25AAxxxx_Busy(Bank: Word): Boolean;
function _25AAxxxx_WriteEnabled(Bank: Word): Boolean;
procedure _25AAxxxx_Erase(Bank: Word);

implementation

function LocalSPI_Read: Byte;
var
  Dummy: Byte;
begin
  Dummy := $FF;
  Result := SPI_Read(Dummy);
end;

procedure LocalSPI_Write(DataByte: Byte);
begin
  SPI_Write(DataByte);
end;

procedure SetBank_CS(Bank: Word; CS_State: Word);
begin
  {$IFDEF EEPROM_ONE_BANK}
  if Bank = EEPROM_BANK_0 then CS_Bank_0 := CS_State {$ENDIF}
  {$IFDEF EEPROM_TWO_BANK}
  else
  if Bank = EEPROM_BANK_1 then CS_Bank_1 := CS_State {$ENDIF}
  {$IFDEF EEPROM_THREE_BANK}
  else
  if Bank = EEPROM_BANK_2 then CS_Bank_2 := CS_State {$ENDIF}
  {$IFDEF EEPROM_FOUR_BANK}
  else
  if Bank = EEPROM_BANK_3 then CS_Bank_3 := CS_State;
  {$ENDIF}
end;

procedure WriteAddress(Address: DWORD);
begin
  LocalSPI_Write(Address shr 16);
  LocalSPI_Write(Address shr 8);
  LocalSPI_Write(Address);
end;

//******************************************************************************
//  procedure _25AAxxxx_Read;
//
//  Parameters:  Bank:      What EEPROM IC to address, see the EEPROM_BANK_x constants
//               Address:   The 24Bit address offset of the EEPROM
//               Count:     The number of Bytes to read
//               Buffer:    Pointer to where to place the data read in
//
//  Result:      None
//
//  Description:
//
//******************************************************************************
procedure _25AAxxxx_Read(Bank: Word; Address: DWORD; Count: Word; Buffer: PByte);
var
  i: Integer;
begin
  SetBank_CS(Bank, 0);
  LocalSPI_Write($03);           // Read Instruction
  WriteAddress(Address);
  for i := 0 to Count - 1 do
  begin
    Buffer^ := LocalSPI_Read;
    Inc(Buffer)
  end;
  SetBank_CS(Bank, 1);
end;

//******************************************************************************
//  procedure _25AAxxxx_Write;
//
//  Parameters:  Bank:      What EEPROM IC to address, see the EEPROM_BANK_x constants
//               Address:   The 24Bit address offset of the EEPROM
//               Count:     The number of Bytes to write, MAX 256 Bytes and in the SAME PAGE!!!!!!
//               Buffer:    Pointer to where to retrieve the data from to write
//
//  Result:      None
//
//  Description:
//
//******************************************************************************
procedure _25AAxxxx_Write(Bank: Word; Address: DWORD; Count: Word; Buffer: PByte);
var
  i: Integer;
begin
  SetBank_CS(Bank, 0);
  LocalSPI_Write($06);           //  WREN (Write Enable) Instruction
  SetBank_CS(Bank, 1);
  SetBank_CS(Bank, 0);
  LocalSPI_Write($02);           // Write Instruction
  WriteAddress(Address);         // Can not check for Write Enabled in the Status here!
  for i := 0 to Count - 1 do
  begin
    LocalSPI_Write(Buffer^);
    Inc(Buffer)
  end;
  SetBank_CS(Bank, 1);
end;

//******************************************************************************
//  procedure _25AAxxxx_Busy;
//
//  Parameters:  Bank:      What EEPROM IC to address, see the EEPROM_BANK_x constants
//
//  Result:      True if the device can be accessed
//
//  Description:
//
//******************************************************************************
function _25AAxxxx_Busy(Bank: Word): Boolean;
begin
  SetBank_CS(Bank, 0);
  LocalSPI_Write($05);
  Result := LocalSPI_Read and $01 <> 0;
  SetBank_CS(Bank, 1);
end;


//******************************************************************************
//  procedure _25AAxxxx_WriteEnabled;
//
//  Parameters:  Bank:      What EEPROM IC to address, see the EEPROM_BANK_x constants
//
//  Result:      True if the device can be accessed
//
//  Description:
//
//******************************************************************************
function _25AAxxxx_WriteEnabled(Bank: Word): Boolean;
begin
  SetBank_CS(Bank, 0);
  LocalSPI_Write($05);
  Result := LocalSPI_Read and $02 <> 0
end;

procedure _25AAxxxx_Erase(Bank: Word);
begin
  SetBank_CS(Bank, 0);
  LocalSPI_Write($06);           //  WREN (Write Enable) Instruction
  SetBank_CS(Bank, 1);
  SetBank_CS(Bank, 0);
  LocalSPI_Write($C7);           // Chip Erase
  SetBank_CS(Bank, 1);
end;

procedure _25AAxxxx_Initialize;
begin
  {$IFDEF EEPROM_ONE_BANK}CS_Bank_0 := 1; {$ENDIF}   // Output
  {$IFDEF EEPROM_TWO_BANK}CS_Bank_1 := 1; {$ENDIF}  // Output
  {$IFDEF EEPROM_THREE_BANK}CS_Bank_2 := 1; {$ENDIF} // Output
  {$IFDEF EEPROM_FOUR_BANK}CS_Bank_3 := 1; {$ENDIF}  // Output
  {$IFDEF EEPROM_ONE_BANK}CS_Bank_0_Direction := 0; {$ENDIF}   // Output
  {$IFDEF EEPROM_TWO_BANK}CS_Bank_1_Direction := 0; {$ENDIF}  // Output
  {$IFDEF EEPROM_THREE_BANK}CS_Bank_2_Direction := 0; {$ENDIF} // Output
  {$IFDEF EEPROM_FOUR_BANK}CS_Bank_3_Direction := 0; {$ENDIF}  // Output
end;

end.