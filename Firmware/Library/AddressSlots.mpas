// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2011.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2011-01-28:   Created
//
// * Description:
//    Implements Locomotive database for the command station
//
// ******************************************************************************

unit AddressSlots;

{$I Options.inc}

uses
//  CommandStation,
//  XpressNet_Constants,
//  SPI_Interface,
  NMRA_DCC;

const
  MAX_ADDRESS_SLOTS = 48;
  MAX_ACCESSORY_SLOTS = 128;   // 1024 Bits / 8 Bits/Byte = 128 Bytes

const
  SPEEDSTEP_E_STOP            = $01;

  OPS_SPEED_DIR_COMMAND                 = %01000000;    // Speed and Direction Packet ID for S-9.2  01DCSSSS
  OPS_SPEED_DIR_BIT                     = %00100000;    // Mask for the Direction Bit for S-9.2       ^
  ADVANCED_OPS_128_STEP_SPEED_CONTROL   = %00111111;
  ADVANCED_OPS_RESTRICTED_SPEED_CONTROL = %00111110;
  ADVANCED_OPS_SPEED_DIR_BIT            = %10000000;    // Speed and Direction Packet ID for S-9.2.1  DSSSSSSS

const
  ADDRESS_SLOT_FLAGS_SPEED_14_BIT         = 0;  // Bit 0 = The Mobile Decoder speed has 14 steps
  ADDRESS_SLOT_FLAGS_SPEED_28_BIT         = 1;  // Bit 1 = The Mobile Decoder speed has 28 steps
  ADDRESS_SLOT_FLAGS_SPEED_128_BIT        = 2;  // Bit 2 = The Mobile Decoder speed has 128 steps
                                                // Bit 3 = Unassigned
  ADDRESS_SLOT_FLAGS_CONSIST_BIT          = 4;  // Bit 4 = The Slot is a consist Address
  ADDRESS_SLOT_FLAGS_ALLOCATED            = 5;  // Bit 5 = The Slot is Allocated and contains a valid decoder address
  ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT     = 6;  // Bit 6 = The Slot decoder is in a double header
  ADDRESS_SLOT_FLAGS_MU_BIT               = 7;  // Bit 7 = The Slot decoder is in a MU
  MASK_ADDRESS_SLOT_FLAGS_SPEED           = %00000111; // Bottom 3 bit are the Speed Flags
  
  ADDRESS_SLOT_DIRECTION_BIT              = 7;  // Bit 7 of the SpeedDir field is the direction

  DEFAULT_LOCO_FUNCTIONS_F0_F12   = Word($0000); // Default Functions are all off
  
  SLOT_INSERT_PREV                = 1;  // Insert the new Slot before the Target Slot (AddressSlot_InsertSlotIntoMU_Chain)
  SLOT_INSERT_NEXT                = 2;  // Insert the new Slot before the Target Slot  (AddressSlot_InsertSlotIntoMU_Chain)
  
type

  TAddressSlot = record
    Address       : Word; // Address assigned to slot, may be a Consist Address if flag set. This is saved as a raw decimal number without any of the Xpressnet or NMRA encoding (short/long/etc)
    SpeedDir      : Byte; // Bit 0..6 = Speed/Direction information stored in XpressNet format (D000SSSS = 14 Step; D00SSSSS = 28 Step; DSSSSSSS = 14 Step) depending on flag
    Functions     : Word; // Current State of Function Bit 0 = F1; Bit 1 = F2; Bit 2 = F3; Bit 3 = F4; Bit 4 = F0; Bit 5 = F5; Bit 6 = F6; Bit 7 = F7; Bit 8 = F8; Bit 9 = F9; Bit 10 = F10; Bit 11 = F11; Bit 12 = F12;
    FunctionType  : Word; // Momentary or On/Off; Bit 0 = F1; Bit 1 = F2; Bit 2 = F3; Bit 3 = F4; Bit 4 = F0; Bit 5 = F5; Bit 6 = F6; Bit 7 = F7; Bit 8 = F8; Bit 9 = F9; Bit 10 = F10; Bit 11 = F11; Bit 12 = F12;
    FunctionsEx   : Word; // Current State of Function Bit 0 = F13; Bit 1 = F14; Bit 2 = F15; Bit 3 = F16; Bit 4 = F17; Bit 5 = F18; Bit 6 = F19; Bit 7 = F20; Bit 8 = F21; Bit 9 = F22; Bit 10 = F23; Bit 11 = F24; Bit 12 = F25; Bit 12 = F26; Bit 13 = F27; Bit 14 = F28;
    FunctionTypeEx: Word; // Momentary or On/Off Bit 0 = F13; Bit 1 = F14; Bit 2 = F15; Bit 3 = F16; Bit 4 = F17; Bit 5 = F18; Bit 6 = F19; Bit 7 = F20; Bit 8 = F21; Bit 9 = F22; Bit 10 = F23; Bit 11 = F24; Bit 12 = F25; Bit 12 = F26; Bit 13 = F27; Bit 14 = F28
    Flags         : Byte; // Bit 0 = The Locomotive speed has 14 steps
                          // Bit 1 = The Locomotive speed has 28 steps
                          // Bit 2 = The Locomotive speed has 128 steps
                          // Bit 3 = The Slot Address is Assigned to a Device
                          // Bit 4 = The Slot is a consist address
                          // Bit 5 = The Slot is Allocated
                          // Bit 6 = The Slot decoder is in a double header
                          // Bit 7 = The Slot decoder is in a MU
    OwnerDevice   : Byte; // Device ID, if not assigned then set Slot Assigned bit in Flags to 0
    NextSlot,             // Next Slot Address whom this slot is a parent of
    PrevSlot      : Word; // Previous Slot Address whom this slot is a child of
  end;
  PAddressSlot = ^TAddressSlot;

  
  TAddressSlotArray = array[0..MAX_ADDRESS_SLOTS-1] of TAddressSlot;
  PAddressSlotArray = ^TAddressSlotArray;
  
  TSortedAddressSlotArray = array[0..MAX_ADDRESS_SLOTS-1] of PAddressSlot;
  TAccessorySlotArray = array[0..MAX_ACCESSORY_SLOTS-1] of Byte;

type
  TAddressSlotInfo = record
    AddressSlot: TAddressSlotArray;         // List of AddressSlot records
    SortedSlots: TSortedAddressSlotArray;
    AccessorySlot: TAccessorySlotArray;
    ZeroSlot: TAddressSlot;                // Where special case Address Zero is stored
    Count: Byte;                           // Number of allocated slots
  end;
  
var
  AddressSlotInfo: TAddressSlotInfo;


// Call once on startup to initialize the unit
procedure AddressSlots_Initialize; forward;
// Returns and empty AddressSlot
function AddressSlot_Allocate(Address: Word): PAddressSlot; forward;
// Frees the AddressSlot allocation from the list to make it avialble again
procedure AddressSlot_Free(AddressSlot: PAddressSlot); forward;
// Finds the Loco Slot that is assigned to the address
function AddressSlot_FindSlot(Address: Word; AutoAllocate: Boolean): PAddressSlot; forward;
// Queues a Speed/Dir Update Message for the passed Slot
function AddressSlot_QueueSpeedDCCMessage(ASlot: PAddressSlot; HighPriority: Boolean): Boolean; forward;
// Queues a Function (F0-F28) Update Message for the passed Slot
function AddressSlot_QueueFunctionDCCMessage(ASlot: PAddressSlot; FunctionGroup: Byte; HighPriority: Boolean): Boolean; forward;
// Calculates the NMRA DCC Hi and Low Address Bytes to place in the DCC Stream
procedure AddressSlot_EncodeAddressToNMRA_Format(ASlot: PAddressSlot; var AddressHi, AddressLo: Byte; ForceShortInXpressnetRange: Boolean); forward;
// Extracts the Double Header paired with the passed Slot
function AddressSlot_ExtractDoubleHeaderSecondSlot(ASlot: PAddressSlot): PAddressSlot;
// Walks the Slot MU_Chain to the last Slot (could be the Consist Slot)
function AddressSlot_WalkMU_ChainLast(ASlot: PAddressSlot): PAddressSlot; forward;
// Walks the Slot MU_Chain to the Root (Consist Slot)
function AddressSlot_WalkMU_ChainRoot(ASlot: PAddressSlot): PAddressSlot; forward;
// Walks the Slot MU_Chain to the first Slot after the Root (Consist Slot), if there is none it returns nil
function AddressSlot_WalkMU_ChainFirst(ASlot: PAddressSlot): PAddressSlot; forward;
// Walks the Slot MU_Chain to the next Slot after the passed slot, if there is none it returns nil
function AddressSlot_WalkMU_ChainNext(ASlot: PAddressSlot): PAddressSlot; forward;
// Walks the Slot MU_Chain to the prev Slot after the passed slot, if there is none it returns nil (including if the previouis is the root, will not return the root)
function AddressSlot_WalkMU_ChainPrev(ASlot: PAddressSlot): PAddressSlot; forward;
// Walks the Slot MU_Chain to the last Consist Slot (could be the Consist Slot)
function AddressSlot_WalkMU_ChainLastConsist: PAddressSlot; forward;
// Walks the Slot MU_Chain to the first Consist Slot after the Root (Consist Slot), if there is none it returns nil
function AddressSlot_WalkMU_ChainFirstConsist: PAddressSlot; forward;
// Walks the Slot MU_Chain to the next Consist Slot after the passed slot, if there is none it returns nil
function AddressSlot_WalkMU_ChainNextConsist(ASlot: PAddressSlot): PAddressSlot; forward;
// Walks the Slot MU_Chain to the prev Consist Slot after the passed slot, if there is none it returns nil (including if the previouis is the root, will not return the root)
function AddressSlot_WalkMU_ChainPrevConsist(ASlot: PAddressSlot): PAddressSlot; forward;
// Walks the Stack to the next
function AddressSlot_WalkStackNext(ASlot: PAddressSlot): PAddressSlot; forward;
// Walks the Stack to the prev
function AddressSlot_WalkStackPrev(ASlot: PAddressSlot): PAddressSlot; forward;
// First Loco in the Stack
function AddressSlot_WalkStackFirst: PAddressSlot; forward;
// Last Loco in the Stack
function AddressSlot_WalkStackLast: PAddressSlot; forward;
// Removed the Slot from the linked list
function AddressSlot_ExtractSlotFromMU_Chain(ASlot: PAddressSlot): Boolean; forward;
// Insert the Slot in the linked list,  See the SLOT_INSERT_XXX constants
procedure AddressSlot_InsertSlotIntoMU_Chain(ASlot: PAddressSlot; TargetSlot: PAddressSlot; SlotInsertPos: Integer); forward;
// Tests to see if the slot is in a mu or double header
function AddressSlot_InMUorDoubleHeader(ASlot: PAddressSlot): Boolean; forward;


implementation

procedure AddressSlotSort; forward;
function BinarySearchAddressSlot(Address: Word): Integer; forward;



// ***************************************************************************
//  procedure AddressSlot_LoadRefreshPacket;
//
//  Parameters:
//           None
//
//  Result:
//          None
//
//  Description:
//     Called From the NMRA_DCC.mpas Unit when there is nothing to send to the rails
//  other than an IDLE message.  Allows the DCC Transmitter to be loaded with refresh
//  packets based on currently allocated AddressSlots
//
// ***************************************************************************
function AddressSlot_LoadRefreshPacket(AMessage: PDCCQueueMessage): Boolean;
begin
  // TODO, implement refreshing the Slots
  Result := False
end;

// ***************************************************************************
//  procedure InitializeSlot;
//
//  Parameters:
//           ASlot:  AddressSlot to initialize
//
//  Result:
//          None
//
//  Description:
//
// ***************************************************************************
procedure InitializeSlot(ASlot: PAddressSlot);
begin
  ASlot^.Address        := $0000;
  ASlot^.SpeedDir       := $00;
  ASlot^.SpeedDir.ADDRESS_SLOT_DIRECTION_BIT := 1;  // Forward, zero speed
  ASlot^.Flags          := $0000;
  ASlot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_28_BIT := 1;
  ASlot^.Functions      := $0000;
  ASlot^.FunctionType   := $0000;
  ASlot^.FunctionsEx    := $0000;
  ASlot^.FunctionTypeEx := $0000;
  ASlot^.NextSlot := 0;
  ASlot^.PrevSlot := 0;
  ASlot^.OwnerDevice := ID_NO_DEVICE;
end;

// ***************************************************************************
//  procedure AddressSlots_Initialize;
//
//  Parameters:
//           None
//
//  Result:
//          None
//
//  Description:
//     Called once on startup to initialize the unit and data structures
//
// ***************************************************************************
procedure AddressSlots_Initialize;
var
  i: Integer;
begin
  i := 0;
  AddressSlot_LoadRefreshPacketFunc := @AddressSlot_LoadRefreshPacket;
  while i < MAX_ADDRESS_SLOTS do
  begin
    InitializeSlot(@AddressSlotInfo.AddressSlot[i]);
    AddressSlotInfo.SortedSlots[i] := PAddressSlot( nil);
    Inc(i)
  end;
  AddressSlotInfo.Count := 0;
  InitializeSlot(@AddressSlotInfo.ZeroSlot);
  
  i := 0;
  while i < MAX_ACCESSORY_SLOTS do
  begin
    AddressSlotInfo.AccessorySlot[i] := 0;
    Inc(i)
  end
end;

// ***************************************************************************
//  procedure AddressSlot_Allocate;
//
//  Parameters:
//           Address:    Address of the slot
//
//  Result:
//         Pointer to a AddressSlot record
//
//  Description:
//     Returns an empty allocated AddressSlot
//
// ***************************************************************************
function AddressSlot_Allocate(Address: Word): PAddressSlot;
var
  i: Byte;
begin
  Result := PAddressSlot(nil);
  if Address = 0 then
    Result := @AddressSlotInfo.ZeroSlot
  else begin
    if AddressSlotInfo.Count < MAX_ADDRESS_SLOTS then
    begin
      i := 0;
      while (i < MAX_ADDRESS_SLOTS) do
      begin
        if AddressSlotInfo.AddressSlot[i].Flags.ADDRESS_SLOT_FLAGS_ALLOCATED = 0 then
        begin
          Result := @AddressSlotInfo.AddressSlot[i];
          InitializeSlot(Result);
          AddressSlotInfo.AddressSlot[i].Flags.ADDRESS_SLOT_FLAGS_ALLOCATED := 1;
          Result^.Address := Address;
          AddressSlotInfo.SortedSlots[AddressSlotInfo.Count] := Result;
          Inc(AddressSlotInfo.Count);
          AddressSlotSort;
          Exit
        end;
        Inc(i);
      end
    end
  end
end;

// ***************************************************************************
//  procedure AddressSlot_Free;
//
//  Parameters:
//           AddressSlot:    Locoslot to operate on
//
//  Result:
//         None
//
//  Description:
//     Frees the AddressSlot memory locatation so other address can be allocated to it
//
// ***************************************************************************
procedure AddressSlot_Free(ASlot: PAddressSlot);
var
  i, Index: Integer;
begin
  if (ASlot <> nil) and (ASlot <> @AddressSlotInfo.ZeroSlot) then
  begin
    AddressSlot_ExtractSlotFromMU_Chain(ASlot);
    ASlot^.Flags.ADDRESS_SLOT_FLAGS_ALLOCATED := 0;

    // Need to remove the Slot from the Sorted array
    i := 0;
    while i < MAX_ADDRESS_SLOTS do
    begin
      if AddressSlotInfo.SortedSlots[i] = ASlot then
      begin
        Index := i;
        i := MAX_ADDRESS_SLOTS;
        while Index < AddressSlotInfo.Count - 1 do
        begin
          AddressSlotInfo.SortedSlots[Index] := AddressSlotInfo.SortedSlots[Index + 1];
          AddressSlotInfo.SortedSlots[Index + 1] := PAddressSlot( nil);
          Inc(Index);
        end;
      end;
      Inc(i);
    end;
    Dec(AddressSlotInfo.Count);
  end
end;

// ***************************************************************************
//  procedure AddressSlotSort;
//  Parameters:
//
//  Performance:
//
//    procedure InsertionSort(a:array of char, arrlength:integer);
//    var
//      i,j,v : integer;
//    begin
//      for i := 2 to arrlength do
//      begin
//        v := a[i];
//        j := i;
//        while (j > 0) and (a[j-1] > v) do
//        begin
//          a[j] := a[j-1];
//          j := j - 1;
//        end; //while
//        a[j] := v;
//      end; //for
//    end
//
// ***************************************************************************
procedure AddressSlotSort;
var
  i, j: Integer;
  LocalData: PAddressSlot;
begin
  for i := 1 to AddressSlotInfo.Count - 1 do
  begin
    LocalData := AddressSlotInfo.SortedSlots[i];
    j := i;
    while (j > 0) and (AddressSlotInfo.SortedSlots[j-1]^.Address > LocalData^.Address) do
    begin
      AddressSlotInfo.SortedSlots[j] := AddressSlotInfo.SortedSlots[j-1];
      j := j - 1;
    end;
    AddressSlotInfo.SortedSlots[j] := LocalData;
  end;
end;

// ***************************************************************************
// function BinarySearchAddressSlot(Address: Word): Integer;
//
// Parameters:
//             Address: Word    ; The address of the Slot to find
//
// Result:
//        Returns the PAddressSlot of the found slot if available else returns nil
//
// function BinarySearch(const DataSortedAscending: array of Integer;
// const ElementValueWanted: Integer): Integer;
// var
//   MinIndex, MaxIndex: Integer;
//   MedianIndex, MedianValue: Integer;
//  begin
//      MinIndex := Low(DataSortedAscending);
//      MaxIndex := High(DataSortedAscending);
//      while MinIndex <= MaxIndex do begin
//          MedianIndex := (MinIndex + MaxIndex) div 2; (* If you're going to change the data type here e.g. Integer to SmallInt consider the possibility of an overflow. All it needs to go bad is MinIndex=(High(MinIndex) div 2), MaxIndex = Succ(MinIndex). *)
//          MedianValue := DataSortedAscending[MedianIndex];
//          if ElementValueWanted < MedianValue then
//              MaxIndex := Pred(MedianIndex)
//          else if ElementValueWanted = MedianValue then begin
//              Result := MedianIndex;
//              Exit; (* Successful exit. *)
//          end else
//              MinIndex := Succ(MedianIndex);
//      end;
//      Result := -1; (* We couldn't find it. *)
//  end;

//
// ***************************************************************************
function BinarySearchAddressSlot(Address: Word): Integer;
var
  Min, Max, Middle: Integer;
  MidAddress: Word;
begin
  Min := 0;
  Max := AddressSlotInfo.Count - 1;
  while Min <= Max do
  begin
    Middle := (Min + Max) shr 1;
    MidAddress := AddressSlotInfo.SortedSlots[Middle]^.Address;
    if Address < MidAddress then
      Max := Middle - 1
    else
    if Address = MidAddress then
    begin
      Result := Middle;
      Exit
    end else
      Min := Middle + 1
  end;
  Result := -1;
end;

// ***************************************************************************
//  procedure AddressSlot_FindSlot;
//
//  Parameters:
//           Address:  Address of the Loco/Consist to search database for
//
//  Result:
//         Pointer to the AddressSlot record
//
//  Description:
//     Returns the AddressSlot if found, else returns nil
//
// ***************************************************************************
function AddressSlot_FindSlot(Address: Word; AutoAllocate: Boolean): PAddressSlot;
var
  Index: Integer;
begin
  Result := PAddressSlot( nil);
  if Address = 0 then
    Result := @AddressSlotInfo.ZeroSlot
  else begin
    Index := BinarySearchAddressSlot(Address);
    if Index > -1 then
      Result := AddressSlotInfo.SortedSlots[Index]
    else
    if AutoAllocate then
      Result := AddressSlot_Allocate(Address)
  end
end;

// ***************************************************************************
//  procedure AddressSlot_QueueSpeedDCCMessage;
//
//  Parameters:
//           Address:  AddressSlot to send Speed Message To
//           HighPriority:  Place the DCC Message into the Priority Buffer
//
//  Result:
//         True:   Successfully placed message
//         False:  Failed to place message
//
//  Description:
//     Helper function to decode the speed type, build a NMRA DCC packet and
//  place it in the Track Queue
//
// ***************************************************************************
function AddressSlot_QueueSpeedDCCMessage(ASlot: PAddressSlot; HighPriority: Boolean): Boolean;
var
  DCCCommandByte: Byte;
  NewDCCMessage: TDCCQueueMessage;
  AddressHi, AddressLo: Byte;
begin
  if ASlot = @AddressSlotInfo.ZeroSlot then
    Result := True
  else begin
    Result := False;
    if ASlot <> nil then
    begin
      AddressHi := 0;
      AddressLo := 0;
      AddressSlot_EncodeAddressToNMRA_Format(ASlot, AddressHi, AddressLo, False);

      // If 14 or 28 Step then add the "01xxxxxx" code, move the direction bit to the correct bit, pick up the correct code from the Speed Map Tables
      if ASlot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_28_BIT = 1 then
        DCCCommandByte := OPS_SPEED_DIR_COMMAND or (ASlot^.SpeedDir and $7F) or ((ASlot^.SpeedDir shr 2) and %00100000)
      else
      if ASlot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_14_BIT = 1 then
        DCCCommandByte := OPS_SPEED_DIR_COMMAND or (ASlot^.SpeedDir and $7F) or ((ASlot^.SpeedDir shr 2) and %00100000)
      else
        NMRA_DCC_LoadMessage(@NewDCCMessage, AddressHi, AddressLo, %00111111, ASlot^.SpeedDir, 0, 4);   // 128 step is an extended message so it must be a long address

      if ASlot^.Flags.ADDRESS_SLOT_FLAGS_SPEED_128_BIT = 0 then
      begin
        if AddressHi = 0 then    // Is a short address, the command station converters this to a short address for older decoders
          NMRA_DCC_LoadMessage(@NewDCCMessage, AddressLo, DCCCommandByte, 0, 0, 0, 2)
        else
          NMRA_DCC_LoadMessage(@NewDCCMessage, AddressHi, AddressLo, DCCCommandByte, 0, 0, 3);   // Is a long address
      end;

      Result := NMRA_DCC_QueueMessage(@Track, @NewDCCMessage, HighPriority)
    end;
  end
end;

// ***************************************************************************
//  procedure AddressSlot_QueueFunctionDCCMessage;
//
//  Parameters:
//           Slot:           AddressSlot to send Speed Message To
//           FunctionGroup:  The group of functions (1-5) to access
//           HighPriority:   Place the DCC Message into the Priority Buffer
//
//  Result:
//         True:   Successfully placed message
//         False:  Failed to place message
//
//  Description:
//     Helper function to decode the Function Bits, build a NMRA DCC packet and
//  place it in the Track Queue
//
// ***************************************************************************
function AddressSlot_QueueFunctionDCCMessage(ASlot: PAddressSlot; FunctionGroup: Byte; HighPriority: Boolean): Boolean;
var
  NewDCCMessage: TDCCQueueMessage;
  AddressHi, AddressLo, i: Byte;
  Params: array[0..5] of Byte;
begin
  if ASlot = @AddressSlotInfo.ZeroSlot then
    Result := True
  else begin
    Result := False;
    if ASlot <> nil then
    begin
      AddressHi := 0;
      AddressLo := 0;
      AddressSlot_EncodeAddressToNMRA_Format(ASlot, AddressHi, AddressLo, False);

      Params[2] := 0;     // Rest of the indexes will be filled in for sure
      Params[3] := 0;
      Params[4] := 0;

      if AddressHi = 0 then
      begin
        Params[0] := AddressLo;
        Params[5] := 2;
        i := 1;
      end else
      begin
        Params[0] := AddressHi;
        Params[1] := AddressLo;
        Params[5] := 3;
        i := 2;
      end;
      
      if FunctionGroup = 1 then
        Params[i] := %10000000 or (ASlot^.Functions and $001F)
      else
      if FunctionGroup = 2 then
        Params[i] := %10100000 or ((ASlot^.Functions shr 5) and $000F)
      else
      if FunctionGroup = 3 then
        Params[i] := %10110000 or ((ASlot^.Functions shr 9) and $000F)
      else
      if FunctionGroup = 4 then
      begin
        Params[i] := %11011110;
        Params[i+1] := Lo(ASlot^.FunctionsEx);
        Inc(Params[5]);
      end else
      if FunctionGroup = 5 then
      begin
        Params[i] := %11011111;
        Params[i+1] := Hi(ASlot^.FunctionsEx);
        Inc(Params[5]);
      end;
      
      NMRA_DCC_LoadMessage(@NewDCCMessage, Params[0], Params[1], Params[2], Params[3], Params[4], Params[5]);
      Result := NMRA_DCC_QueueMessage(@Track, @NewDCCMessage, HighPriority)
    end;
  end
end;

// ***************************************************************************
//  procedure AddressSlot_EncodeAddressToNMRA_Format;
//
//  Parameters:
//           Slot:           AddressSlot to send Speed Message To
//           AddressHi,
//           AddressLo:      The calculated NMRA bytes for the Mobile Address
//
//  Result:
//         True:   Successfully placed message
//         False:  Failed to place message
//
//  Description:
//     Helper function to decode the Function Bits, build a NMRA DCC packet and
//  place it in the Track Queue
//
// ***************************************************************************
procedure AddressSlot_EncodeAddressToNMRA_Format(ASlot: PAddressSlot; var AddressHi, AddressLo: Byte; ForceShortInXpressnetRange: Boolean);
begin
  AddressHi := 0;
  AddressLo := 0;
  if ASlot <> nil then
  begin
    AddressLo := Lo(ASlot^.Address);
    AddressHi := %11000000 or Hi(ASlot^.Address);                               // Assume long address
    if ASlot^.Address <= MAX_XPRESSNET_SHORT_ADDRESS then                       // If it is a "short address" (1..99), the command station converts this to a basic address message
    begin
      if ForceShortInXpressnetRange then
        AddressHi := 0
      else
      if CommandStation.FlagsEx.COMMANDSTATION_FLAGSEX_ALWAYS_USE_LONG_ADDRESSES = 0 then   // Are we always forcing long addressess?
        AddressHi := 0
    end
  end
end;

// *****************************************************************************
//
// procedure AddressSlot_ExtractDoubleHeaderSecondSlot
//
//   Parameters:
//              Slot:   Address Slot to pull the Double header second Address out of
//
//   Returns:
//      None
//
//  Description:
//                Address of the other Double header
//
// *****************************************************************************
function AddressSlot_ExtractDoubleHeaderSecondSlot(ASlot: PAddressSlot): PAddressSlot;
begin
  Result := PAddressSlot( nil);
  if ASlot <> @AddressSlotInfo.ZeroSlot then
  begin
    Result := PAddressSlot( ASlot^.PrevSlot);
    if Result = nil then
      Result := PAddressSlot( ASlot^.NextSlot);
  end
end;

// ***************************************************************************
//  procedure AddressSlot_WalkMU_ChainLast;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           The AddresSlot that matches the passes request or nil if none match
//
//  Description:
//           Walks the Slot MU_Chain to the last Slot (could be the Consist Slot)
//
// ***************************************************************************
function AddressSlot_WalkMU_ChainLast(ASlot: PAddressSlot): PAddressSlot;
begin
  Result := PAddressSlot( nil);
  if (ASlot <> nil) and (ASlot <> @AddressSlotInfo.ZeroSlot) then
  begin
    Result := AddressSlot_WalkMU_ChainRoot(ASlot);
    if Result <> nil then
    begin
      Result := ASlot;
      while Result^.NextSlot <> 0 do
        Result := PAddressSlot(Result^.NextSlot)
    end
  end
end;

// ***************************************************************************
//  procedure AddressSlot_WalkMU_ChainRoot;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           The AddresSlot that matches the passes request or nil if none match
//
//  Description:
//           Walks the Slot MU_Chain to the Root (Consist Slot)
//
// ***************************************************************************
function AddressSlot_WalkMU_ChainRoot(ASlot: PAddressSlot): PAddressSlot;
begin
  Result := PAddressSlot( nil);
  if (ASlot <> nil) and (ASlot <> @AddressSlotInfo.ZeroSlot) then
  begin
    Result := ASlot;
    while Result^.PrevSlot <> 0 do
      Result := PAddressSlot(Result^.PrevSlot)
  end
end;

// ***************************************************************************
//  procedure AddressSlot_WalkMU_ChainFirst;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           The AddresSlot that matches the passes request or nil if none match
//
//  Description:
//           Walks the Slot MU_Chain to the first Slot after the Root (Consist Slot), if there is none it returns nil
//
// ***************************************************************************
function AddressSlot_WalkMU_ChainFirst(ASlot: PAddressSlot): PAddressSlot;
begin
  Result := AddressSlot_WalkMU_ChainRoot(ASlot);
  if Result <> nil then
  begin
    if Result^.NextSlot <> 0 then
      Result := PAddressSlot( Result^.NextSlot)
    else
      Result := PAddressSlot( nil);
  end
end;

// ***************************************************************************
//  procedure AddressSlot_WalkMU_ChainNext;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           The AddresSlot that matches the passes request or nil if none match
//
//  Description:
//           Walks the Slot MU_Chain to the next Slot after the passed slot, if there is none it returns nil
//
// ***************************************************************************
function AddressSlot_WalkMU_ChainNext(ASlot: PAddressSlot): PAddressSlot;
begin
  Result := PAddressSlot( nil);
  if (ASlot <> nil) and (ASlot <> @AddressSlotInfo.ZeroSlot) then
    Result := PAddressSlot( ASlot^.NextSlot)
end;

// ***************************************************************************
//  procedure AddressSlot_WalkMU_ChainPrev;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           The AddresSlot that matches the passes request or nil if none match
//
//  Description:
//           Walks the Slot MU_Chain to the prev Slot after the passed slot, if there is
//           none it returns nil (including if the previouis is the root, will not return the root)
//
// ***************************************************************************
function AddressSlot_WalkMU_ChainPrev(ASlot: PAddressSlot): PAddressSlot;
begin
  Result := PAddressSlot( nil);
  if (ASlot <> nil) and (ASlot <> @AddressSlotInfo.ZeroSlot) then
  begin
    Result := PAddressSlot( ASlot^.PrevSlot);
    if Result^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 1 then
      Result := PAddressSlot( nil)
  end
end;

// ***************************************************************************
//  procedure AddressSlot_WalkMU_ChainLastConsist;
//
//  Parameters:
//           None
//
//  Result:
//           The AddresSlot that matches the passes request or nil if none match
//
//  Description:
//           Walks the Slot MU_Chain to the last Consist Slot (could be the Consist Slot)
//
// ***************************************************************************
function AddressSlot_WalkMU_ChainLastConsist: PAddressSlot;
var
  i: Integer;
begin
  Result := PAddressSlot( nil);
  i := AddressSlotInfo.Count - 1;
  while i > -1 do
  begin
    if AddressSlotinfo.SortedSlots[i]^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 1 then
    begin
      Result := AddressSlotinfo.SortedSlots[i];
      Exit;
    end;
    Dec(i);
  end
end;

// ***************************************************************************
//  procedure AddressSlot_WalkMU_ChainFirstConsist;
//
//  Parameters:
//           None
//
//  Result:
//           The AddresSlot that matches the passes request or nil if none match
//
//  Description:
//           Walks the Slot MU_Chain to the first Consist Slot after the Root (Consist Slot), if there is none it returns nil
//
// ***************************************************************************
function AddressSlot_WalkMU_ChainFirstConsist: PAddressSlot;
var
  i: Integer;
  Count: Byte;
begin
  Result := PAddressSlot( nil);
  i := 0;
  Count := AddressSlotInfo.Count - 1;
  while i < Count do
  begin
    if AddressSlotinfo.SortedSlots[i]^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 1 then
    begin
      Result := AddressSlotinfo.SortedSlots[i];
      Exit;
    end;
    Inc(i);
  end
end;

// ***************************************************************************
//  procedure AddressSlot_WalkMU_ChainNextConsist;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           The AddresSlot that matches the passes request or nil if none match
//
//  Description:
//           Walks the Slot MU_Chain to the next Consist Slot after the passed slot, if there is none it returns nil
//
// ***************************************************************************
function AddressSlot_WalkMU_ChainNextConsist(ASlot: PAddressSlot): PAddressSlot;
var
  i: Integer;
  Count: Word;
begin
  Result := PAddressSlot( nil);
  if ASlot <> @AddressSlotInfo.ZeroSlot then
  begin
    i := BinarySearchAddressSlot(ASlot^.Address);
    if (i > -1) and (i < AddressSlotInfo.Count) then
    begin
      Count := AddressSlotInfo.Count - 1;
      while i < Count do
      begin
        if AddressSlotinfo.SortedSlots[i]^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 1 then
        begin
          Result := AddressSlotinfo.SortedSlots[i];
          Exit;
        end;
        Inc(i);
      end
    end
  end
end;

// ***************************************************************************
//  procedure AddressSlot_WalkMU_ChainPrevConsist;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           The AddresSlot that matches the passes request or nil if none match
//
//  Description:
//           Walks the Slot MU_Chain to the prev Consist Slot after the passed slot, if there is none it returns nil (including if the previouis is the root, will not return the root)
//
// ***************************************************************************
function AddressSlot_WalkMU_ChainPrevConsist(ASlot: PAddressSlot): PAddressSlot;
var
  i: Integer;
begin
  Result := PAddressSlot( nil);
  if ASlot <> @AddressSlotInfo.ZeroSlot then
  begin
    i := BinarySearchAddressSlot(ASlot^.Address);
    if (i > -1) and (i < AddressSlotInfo.Count) then
    begin
      while i > -1 do
      begin
        if AddressSlotinfo.SortedSlots[i]^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 1 then
        begin
          Result := AddressSlotinfo.SortedSlots[i];
          Exit;
        end;
        Dec(i);
      end
    end
  end
end;

// ***************************************************************************
//  procedure AddressSlot_WalkStackNext;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           True if the Slot was removed
//
//  Description:
//        Walks the Stack to the next
//
// ***************************************************************************
function AddressSlot_WalkStackNext(ASlot: PAddressSlot): PAddressSlot;
var
  i: Integer;
begin
  Result := PAddressSlot( nil);
  if ASlot <> @AddressSlotInfo.ZeroSlot then
  begin
    i := BinarySearchAddressSlot(ASlot^.Address);
    if (i > -1) and (i < AddressSlotInfo.Count - 1) then
      Result := AddressSlotinfo.SortedSlots[i + 1];
  end
end;

// ***************************************************************************
//  procedure AddressSlot_WalkStackNext;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           True if the Slot was removed
//
//  Description:
//        Walks the Stack to the prev
//
// ***************************************************************************
function AddressSlot_WalkStackPrev(ASlot: PAddressSlot): PAddressSlot;
var
  i: Integer;
begin
  Result := PAddressSlot( nil);
  if ASlot <> @AddressSlotInfo.ZeroSlot then
  begin
    i := BinarySearchAddressSlot(ASlot^.Address);
    if (i > 0) and (i < AddressSlotInfo.Count) then
      Result := AddressSlotinfo.SortedSlots[i - 1];
  end
end;

// ***************************************************************************
//  procedure AddressSlot_ExtractSlotFromMU_Chain;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           True if the Slot was removed
//
//  Description:
//       First Loco in the Stack
//
// ***************************************************************************
function AddressSlot_WalkStackFirst: PAddressSlot;
begin
  Result := PAddressSlot( nil);
  if AddressSlotInfo.Count > 0 then
    Result := AddressSlotInfo.SortedSlots[0]
end;

// ***************************************************************************
//  procedure AddressSlot_ExtractSlotFromMU_Chain;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           True if the Slot was removed
//
//  Description:
//       Last Loco in the Stack
//
// ***************************************************************************
function AddressSlot_WalkStackLast: PAddressSlot;
begin
  Result := PAddressSlot( nil);
  if AddressSlotInfo.Count > 0 then
    Result := AddressSlotInfo.SortedSlots[AddressSlotInfo.Count - 1]
end;

// ***************************************************************************
//  procedure AddressSlot_ExtractSlotFromMU_Chain;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           True if the Slot was removed
//
//  Description:
//       Remove the Slot from the linked list
//
// ***************************************************************************
function AddressSlot_ExtractSlotFromMU_Chain(ASlot: PAddressSlot): Boolean;
begin
  Result := False;
  if (ASlot <> nil) and (ASlot <> @AddressSlotInfo.ZeroSlot) then
  begin
    if ASlot^.PrevSlot <> 0 then
      PAddressSlot( ASlot^.PrevSlot)^.NextSlot := ASlot^.NextSlot;
    if ASlot^.NextSlot <> 0 then
      PAddressSlot( ASlot^.NextSlot)^.PrevSlot := ASlot^.PrevSlot;
    ASlot^.NextSlot := 0;
    ASlot^.PrevSlot := 0;
    ASlot^.Flags.ADDRESS_SLOT_FLAGS_MU_BIT := 0;
    ASlot^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT := 0;
    ASlot^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT := 0;
    Result := True;
  end
end;

// ***************************************************************************
//  procedure AddressSlot_InsertSlotIntoMU_Chain;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//           TargetSlot:     Insertion point of the passed Slot
//           SlotInsertPos:  Where to insert Slot with respect to the Target (before/after)
//
//  Result:
//           None
//
//  Description:
//       Insert the Slot in the linked list,  See the SLOT_INSERT_XXX constants
//
// ***************************************************************************
procedure AddressSlot_InsertSlotIntoMU_Chain(ASlot: PAddressSlot; TargetSlot: PAddressSlot; SlotInsertPos: Integer);
begin
  if (ASlot <> nil) and (ASlot <> @AddressSlotInfo.ZeroSlot) then
  begin
    case SlotInsertPos of
      SLOT_INSERT_NEXT :    // This case has a valid parent but may or may not have a valid child
        begin
          ASlot^.NextSlot := PAddressSlot( TargetSlot)^.NextSlot;
          ASlot^.PrevSlot := Word( TargetSlot);
          TargetSlot^.NextSlot := Word( ASlot);
          if ASlot^.NextSlot <> 0 then
            PAddressSlot( ASlot^.NextSlot)^.PrevSlot := Word( ASlot);
        end;
      SLOT_INSERT_PREV :      //  This case the Slot must have a valid parent and child
        begin
          ASlot^.NextSlot := Word( TargetSlot);
          ASlot^.PrevSlot := PAddressSlot( TargetSlot)^.PrevSlot;
          TargetSlot^.PrevSlot := Word( ASlot);
          PAddressSlot( ASlot^.PrevSlot)^.NextSlot := Word( ASlot);
        end;
    end;
    ASlot^.Flags.ADDRESS_SLOT_FLAGS_MU_BIT := 1
  end
end;

// ***************************************************************************
//  procedure AddressSlot_InMUorDoubleHeader;
//
//  Parameters:
//           Slot:           AddressSlot to use as the starting point for the Walk
//
//  Result:
//           None
//
//  Description:
//        Tests to see if the slot is in a mu or double header
//
// ***************************************************************************
function AddressSlot_InMUorDoubleHeader(ASlot: PAddressSlot): Boolean;
begin
  Result := (ASlot^.Flags.ADDRESS_SLOT_FLAGS_MU_BIT = 1) or (ASlot^.Flags.ADDRESS_SLOT_FLAGS_CONSIST_BIT = 1) or (ASlot^.Flags.ADDRESS_SLOT_FLAGS_DOUBLEHEADER_BIT = 1)
end;

end.