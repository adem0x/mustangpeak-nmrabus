unit NMRAnetMobileNode;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements the database that will be used for a NMRABus based Command Station
//
// ******************************************************************************

uses
  NMRAnetDefines,
  _25AAxxxx;
  
const
  MAX_MOBILE_NODE_COUNT           = 32;                                          // Number of Virtual Nodes (locomotives)
  
  MAX_EFFECTS                     = 28;                                         // Number of Effects (functions) per Node
  MAX_EFFECT_NAME_LEN             = 16;                                         // Number of bytes for naming of an Effect (function)
  MAX_NODE_NAME_LEN               = 16;                                         // Number of bytes for naming of the node
  
  MAX_FUNCTION_COUNT_DCC          = 32;                                         // 32 Bits used for Functions in NMRA DCC
  
  STATIC_DATA_BOUNDRIES           = 1024;                                       // Number of bytes in each Node for static data, becomes the offest to the data (i *  STATIC_DATA_BOUNDRIES)

  MNS_ALLOCATED                   = $01;                                        // Moble Node State = Allocated
  
type
  TEffectName = string[MAX_EFFECT_NAME_LEN];
  TMobileNodeName = string[MAX_NODE_NAME_LEN];

 { TEffectStatic = record                                                        // Function, FX, Effect information that is changed rarely, if ever while operating the layout
    Name: TEffectName;
  end;
  TEffectsStatic = array[0..MAX_EFFECTS-1] of TEffectStatic;
  
  TEffect = record                                                              // Function, FX, Effect information that is changed often while operating the layout
    Value: Word;
  end;
  TEffects = array[0..MAX_EFFECTS-1] of TEffect;
  
  TMobileNodeStatic = record                                                    // Node Information that is changed rarely, if ever while operating the layout
    Name: TMobileNodeName;
    Effects: TEffectsStatic;
  end;
  PMobileNodeStatic = ^TMobileNodeStatic;
  
  TMobileNode = record
    Motion: Word;                                                               // 2 Bytes:  Speed and Direction of the object in NMRAnet Float16 format
    Effects: TEffects;
    Static: PMobileNodeStatic;                                                  // Pointer to information that is stored in EEPROM
    State: Byte;                                                                // 1 Byte: Current State of the Mobile Item
  end;                                                                          // State of the Mobile Node, see the Mobile Node State constants (MNS_xxx)
  PMobileNode = ^TMobileNode;

  TMobileNodeList = record
    Nodes: array[0..MAX_MOBILE_NODE_COUNT-1] of TMobileNode;                    // Offsets into the EEPROM for the nodes
  end;
  PMobileNodeList = ^TMobileNodeList;
}
  // Special Case to reduce memory footprint for NMRA DCC
  TMobileDCCNodeStatic = record
    Name: TMobileNodeName;                                                      // Name for the Node
    FunctionNames: array[MAX_FUNCTION_COUNT_DCC] of TEffectName;                // Names for the Functions
    FunctionLatch: DWord;                                                       // If the Function is Latching or not
    NodeID: TNodeID;                                                            // Fixed Node ID for DCC Node
  end;
  PMobileDCCNodeStatic = ^TMobileDCCNodeStatic;
  
  TMobileDCCNode = record
    SpeedDir: Byte;                                                             // NMRA DCC Speed/Direction
    Address: Word;                                                              // NMRA DCC Address assigned to the Node
    FunctionState: DWord;                                                       // NMRA Functions Bit State (on/off) 32 Functions
    iEEPROM: Word;                                                              // Index into the EEPROM to information that is stored in EEPROM, mulitply by STATIC_DATA_BOUNDRIES to get the address into the EEPROM
    AliasID: Word;                                                              // NMRAnet Alias calculated from Node ID
    State: Byte;                                                                // State of the Mobile Node, see the Mobile Node State constants (MNS_xxx)
  end;
  PMobileDCCNode = ^TMobileDCCNode;

  TMobileDCCNodeList = record
    Nodes: array[0..MAX_MOBILE_NODE_COUNT-1] of TMobileDCCNode;
    State: Byte;
  end;
  PMobileDCCNodeList = ^TMobileDCCNodeList;

var
  MobileDCCNodeList: TMobileDCCNodeList;
  

  procedure NMRAnetMobileNode_InitializeEEPROM;
  procedure NMRAnetMobileNode_Initialize;
  function NMRAnetMobileNode_FindByAlias(Alias: Word): PMobileDCCNode;
  function NMRAnetMobileNode_FindByAddress(Address: Word): PMobileDCCNode;
  function NMRAnetMobileNode_Allocate: PMobileDCCNode;
  procedure NMRAnetMobileNode_Free(MobileNode: PMobileDCCNode);

implementation

procedure InitializeMobileDCCNode(MobileDCCNode: PMobileDCCNode);
begin
  if MobileDCCNode <> nil then
  begin
    MobileDCCNode^.SpeedDir := 0;
    MobileDCCNode^.FunctionState := 0;
    MobileDCCNode^.AliasID := 0;
    MobileDCCNode^.Address := 0;
    MobileDCCNode^.State := 0;
  end
end;


procedure InitializeMobileDCCNodeList(MobileDCCNodeList: PMobileDCCNodeList);
var
  i: Integer;
begin
  MobileDCCNodeList^.State := 0;
  for i := 0 to MAX_MOBILE_NODE_COUNT-1 do
  begin
    InitializeMobileDCCNode(@MobileDCCNodeList^.Nodes[i]);
    MobileDCCNodeList^.Nodes[i].iEEPROM := i;
  end
end;

// ***************************************************************************
//  procedure NMRAnetMobileNode_Initialize;
//
//  Parameters:
//
//  Result:
//
//  Description:
//
// ***************************************************************************
procedure NMRAnetMobileNode_Initialize;
begin
  InitializeMobileDCCNodeList(@MobileDCCNodeList)
end;

// ***************************************************************************
//  procedure NMRAnetMobileNode_InitializeEEPROM;
//
//  Parameters:
//
//  Result:
//
//  Description:
//
// ***************************************************************************
procedure NMRAnetMobileNode_InitializeEEPROM;
var
  i, j: Integer;
  EEPROMOffset: DWord;
  RecordOffset: PByte;
  Len: Word;
  Temp: TMobileDCCNodeStatic;
  s1: string[8];
begin
  for i := 0 to MAX_MOBILE_NODE_COUNT-1 do
  begin
    IntToStr(i, s1);
    Temp.Name := 'Mobile Node ' + s1;
    for j := 0 to MAX_FUNCTION_COUNT_DCC - 1 do
    begin
      IntToStr(j, s1);
      Temp.FunctionNames[j] := 'F' + s1;
    end;
    Temp.FunctionLatch := 0;
    Temp.NodeID := NMRABus.Node.ID;
    Temp.NodeID[0] := Temp.NodeID[0] + i + 1;                                   // Virtual Nodes are the base node ID for the command station + n
    for j := 0 to SizeOf(TMobileDCCNodeStatic) div 256 do
    begin
      EEPROMOffset := (MobileDCCNodeList.Nodes[i].iEEPROM * STATIC_DATA_BOUNDRIES) + (j * 256);
      RecordOffset := @Temp + (j * 256);
      Len := 256;
      if (j * 256) < SizeOf(TMobileDCCNodeStatic) then
        Len := SizeOf(TMobileDCCNodeStatic) mod 256;
      _25AAxxxx_Write(EEPROM_BANK_0, EEPROMOffset, Len, RecordOffset)
    end;
  end;
end;

// ***************************************************************************
//  procedure NMRAnetMobileNode_FindByAlias;
//
//  Parameters:
//
//  Result:
//
//  Description:
//
// ***************************************************************************
function NMRAnetMobileNode_FindByAlias(Alias: Word): PMobileDCCNode;
var
  i: Integer;
begin
  Result := PMobileDCCNode( nil);
  i := 0;
  while i < MAX_MOBILE_NODE_COUNT do
  begin
    if MobileDCCNodeList.Nodes[i].State and MNS_ALLOCATED <> 0 then
      if MobileDCCNodeList.Nodes[i].AliasID = Alias then
      begin
        Result := @MobileDCCNodeList.Nodes[i];
        Break;
      end;
    Inc(i);
  end;
end;

// ***************************************************************************
//  procedure NMRAnetMobileNode_FindByAddress;
//
//  Parameters:
//
//  Result:
//
//  Description:
//
// ***************************************************************************
function NMRAnetMobileNode_FindByAddress(Address: Word): PMobileDCCNode;
var
  i: Integer;
begin
  Result := PMobileDCCNode( nil);
  i := 0;
  while i < MAX_MOBILE_NODE_COUNT do
  begin
    if MobileDCCNodeList.Nodes[i].State and MNS_ALLOCATED <> 0 then
      if MobileDCCNodeList.Nodes[i].Address = Address then
      begin
        Result := @MobileDCCNodeList.Nodes[i];
        Break;
      end;
    Inc(i);
  end;
end;

// ***************************************************************************
//  procedure NMRAnetMobileNode_Allocate;
//
//  Parameters:
//
//  Result:
//
//  Description:   DON'T FORGET to create the alias
//
// ***************************************************************************
function NMRAnetMobileNode_Allocate: PMobileDCCNode;
var
  i: Integer;
begin
  Result := PMobileDCCNode( nil);
  i := 0;
  while i < MAX_MOBILE_NODE_COUNT do
  begin
    if MobileDCCNodeList.Nodes[i].State and MNS_ALLOCATED = 0 then
    begin
      MobileDCCNodeList.Nodes[i].State := MobileDCCNodeList.Nodes[i].State or MNS_ALLOCATED;
      Result := @MobileDCCNodeList.Nodes[i];
      Break;
    end;
    Inc(i);
  end;
end;

// ***************************************************************************
//  procedure NMRAnetMobileNode_Free;
//
//  Parameters:
//
//  Result:
//
//  Description:
//
// ***************************************************************************
procedure NMRAnetMobileNode_Free(MobileNode: PMobileDCCNode);
begin
  InitializeMobileDCCNode(MobileNode)
end;


end.