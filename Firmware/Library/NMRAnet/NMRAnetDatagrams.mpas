unit NMRAnetDatagrams;

uses
  NMRAnetUtilities,
  CANDefines,
  CANStorage,
  NMRAnetDefines,
  NMRAnetDatagramDefines;

procedure NMRAnetDatagrams_Initialize;
procedure NMRAnetDatagrams_ProcessReceiveInterrupt(Buffer: PCANBuffer);
procedure NMRAnetDatagrams_ProcessReceive;
procedure NMRAnetDatagrams_ProcessTransmit;
procedure NMRAnetDatagrams_1ms_TimeTick;
procedure NMRAnetDatagrams_SetCallback(var Hook: PDatagramTaskCallbackFunc; Func: PDatagramTaskCallbackFunc);   // Hook is any variable in NMRAnetDatagramDefines: DatagramTrainControlHook, DatagramMemConfigurationHook, etc


// defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure EnableCANInterrupt(Enable: Boolean); external;
// defined in the NMRAnetStateMachine.mpas file
  function TryTransmitNMRABusLayerMsg(VariableField: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes; Buffer: PCANBuffer): Boolean; external;

implementation

// *****************************************************************************
//  procedure NMRAnetDatagrams_Initialize;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetDatagrams_Initialize;
var
  i, j: Integer;
begin
  for i := 0 to LEN_DATAGRAM_ARRAY - 1 do
  begin
    DatagramRecieve.List[i].iState := DATAGRAM_EMPTY;
    DatagramRecieve.List[i].iState := 0;
    for j := 0 to LEN_DATAGRAM-1 do
      DatagramRecieve.List[i].DataBytes[j] := 0;
  end;
  DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_START;
  DatagramRecieve.iActiveDatagram := 0;
  for i := 0 to LEN_DATAGRAM_BUFFER_OVERFLOW_LIST-1 do
    DatagramRecieve.BufferOverflowList[i] := 0;
    
  DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_START;
  DatagramTransmit.Datagram.iState := DATAGRAM_EMPTY;
  
  DatagramUnknownCallback := PDatagramTaskCallbackFunc(nil);
  DatagramTrainControlCallback := PDatagramTaskCallbackFunc(nil);
  DatagramMemConfigurationCallback := PDatagramTaskCallbackFunc(nil);
end;


// *****************************************************************************
//
// procedure NMRAnetDatagrams_SetCallback;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Not really a necessary function just helps future use in reminding
//              how these Callbacks work.
//
//              Callback is the variable int NMRAnetDatagramDefines
//                           DatagramUnknownCallback: PDatagramTaskCallbackFunc;
//                           DatagramTrainControlCallback: PDatagramTaskCallbackFunc;
//                           DatagramMemConfigurationCallback: PDatagramTaskCallbackFunc;
//                           etc
//
// *****************************************************************************
procedure NMRAnetDatagrams_SetCallback(var Callback: PDatagramTaskCallbackFunc; Func: PDatagramTaskCallbackFunc);
begin
  Callback := Func
end;

// *****************************************************************************
//
// procedure NMRAnetDatagrams_1ms_TimeTick;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Updates internal flags to track for various timeout conditions mainly for the bus.
//
//              WARNING: Application must make sure that the Datagram Array is not
//              modified in an interrupt when calling this function...... Disable the CAN for
//              the time this takes to run.
//
// *****************************************************************************
procedure NMRAnetDatagrams_1ms_TimeTick;
var
  i: Integer;
begin
  for i := 0 to LEN_DATAGRAM_ARRAY - 1 do
  begin
    if DatagramRecieve.List[i].iState = DATAGRAM_IN_PROCESS then
    begin
      if DatagramRecieve.List[i].iWatchdog < DATAGRAM_WATCHDOG_MAX then                 // Latch it at DATAGRAM_WATCHDOG_MAX
        Inc(DatagramRecieve.List[i].iWatchdog)                                          // Increase the Watchdog counter
    end
  end;
end;

function TrySendDatagramResponse(Datagram: PDatagramBuffer; MTI: Byte; ErrorCode: PDatagramErrorCode; CodeByteCount: Byte; NextDatagramState: Byte): Boolean;
var
  Buffer: TCANBuffer;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    NMRAnetUtilities_CreateNMRABusMessagePacket(MTI_ADDRESSED, Datagram^.SourceAlias, @Buffer);
    Buffer.DataBytes[0] := MTI;
    if ErrorCode <> PDatagramErrorCode( nil) then
    begin
      Buffer.DataBytes[1] := ErrorCode^[0];
      Buffer.DataBytes[2] := ErrorCode^[1];
    end;
    Buffer.DataCount := CodeByteCount;
    if CANStorage_AddToList(@TX_NMRAnetBufferList, @Buffer) then
    begin
      StartCANMessageEngine();      
      Datagram^.iState := NextDatagramState;                                    // Set the new state of the Datagram buffer
      Result := True
    end
  end
end;

// *****************************************************************************
//  procedure SendAnyBufferFullResponses;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure SendAnyBufferFullResponses(Datagram: PDatagramBuffer);
var
  i: Integer;
begin
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    i := 0;
    while i < LEN_DATAGRAM_BUFFER_OVERFLOW_LIST do
    begin
      if DatagramRecieve.BufferOverflowList[i] <> 0 then
      begin
        if TrySendDatagramResponse(Datagram, MTI_DATAGRAM_REJECTED, @DATAGRAM_REJECTED_BUFFER_FULL, 3, DATAGRAM_EMPTY) then
          DatagramRecieve.BufferOverflowList[i] := 0;
        Exit;
      end;
        Inc(i); 
    end;
  end
end;

// *****************************************************************************
//  procedure DispatchSpecialDatagramLogRequest;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchSpecialDatagramLogRequest(Datagram: PDatagramBuffer);
begin
  Datagram^.iState := DATAGRAM_TASK_RESPONDED
end;

// *****************************************************************************
//  procedure DispatchSpecialDatagramLogReply;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchSpecialDatagramLogReply(Datagram: PDatagramBuffer);
begin
  Datagram^.iState := DATAGRAM_TASK_RESPONDED
end;

// *****************************************************************************
//  procedure DispatchSpecialDatagramMemConfiguration;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchSpecialDatagramMemConfiguration(Datagram: PDatagramBuffer);
begin
  if DatagramMemConfigurationCallback <> PDatagramTaskCallbackFunc(nil) then
  begin
    if DatagramMemConfigurationCallback(Datagram) then
      Datagram^.iState := DATAGRAM_TASK_RESPONDED
  end else
    Datagram^.iState := DATAGRAM_TASK_RESPONDED
end;

// *****************************************************************************
//  procedure DispatchSpecialDatagramRemoteButton;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchSpecialDatagramRemoteButton(Datagram: PDatagramBuffer);
begin
  Datagram^.iState := DATAGRAM_TASK_RESPONDED
end;

// *****************************************************************************
//  procedure DispatchSpecialDatagramDisplay;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchSpecialDatagramDisplay(Datagram: PDatagramBuffer);
begin
  Datagram^.iState := DATAGRAM_TASK_RESPONDED
end;

// *****************************************************************************
//  procedure DispatchSpecialDatagramTrainControl;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchSpecialDatagramTrainControl(Datagram: PDatagramBuffer);
begin      
  if DatagramTrainControlCallback <> PDatagramTaskCallbackFunc( nil) then
  begin
    if DatagramTrainControlCallback(Datagram) then
      Datagram^.iState := DATAGRAM_TASK_RESPONDED
  end else
    Datagram^.iState := DATAGRAM_TASK_RESPONDED
end;


// *****************************************************************************
//  procedure NMRAnetDatagrams_ProcessTransmit;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetDatagrams_ProcessTransmit;
var
  Buffer: TCANBuffer;
  i: Integer;
begin
  case DatagramTransmit.iState of
    STATE_DATAGRAM_TRANSMIT_START :
      begin
        if DatagramTransmit.Datagram.iState <> DATAGRAM_EMPTY then
        begin
          if DatagramTransmit.Datagram.iByteCount < 9 then
            DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME
          else
            DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_MULTI_FRAME
        end
      end;
    STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME :
      begin
        DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_SINGLE_FRAME;
      end;
    STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_SINGLE_FRAME  :
      begin
        case DatagramTransmit.iState of
          DATAGRAM_EMPTY              : begin
                                          if DatagramTransmit.Datagram.iByteCount < 9 then
                                          begin
                                             if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
                                             begin
                                               for i := 0 to DatagramTransmit.Datagram.iByteCount - 1 do
                                                 Buffer.DataBytes[i] := DatagramTransmit.Datagram.DataBytes[i];
                                               Buffer.DataCount := DatagramTransmit.Datagram.iByteCount;
                                               if TryTransmitNMRABusLayerMsg(MTI_DATAGRAM_ONLY_FRAME, DatagramTransmit.Datagram.SourceAlias, 0, nil, @Buffer) then
                                               begin
                                                 DatagramTransmit.Datagram.iState := DATAGRAM_TRANSFER_COMPLETE;
                                                 DatagramTransmit.Datagram.iWatchdog := 0;
                                                 DatagramTransmit.iState := STATE_DATAGRAM_RECEIVE_NEXT;        // Wait to see if target responses
                                               end;
                                             end
                                          end else
                                          begin
                                          end
                                        end;
          DATAGRAM_IN_PROCESS         : begin
                                        end;                                            // The Datagram Packet Buffer is currently collecting/transmitting frames
          DATAGRAM_TRANSFER_COMPLETE  : begin
                                        end;                                             // The Datagram Packet has responded to the sender and ready for use (DATAGRAM_REJECTED_BUFFER_FULL response needed)
          DATAGRAM_TASK_RESPONDED     : begin

                                        end;
        end;
        DatagramTransmit.iState := STATE_DATAGRAM_RECEIVE_START;
      end;
    STATE_DATAGRAM_TRANSMIT_MULTI_FRAME      :
      begin
        DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_MULTI_FRAME;
      end;
    STATE_DATAGRAM_TRANSMIT_NEXT_MULTI_FRAME      :
      begin
         DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_MULTI_FRAME;
      end;
    STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_MULTI_FRAME      :
      begin
        DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_START
      end
   else
     DatagramTransmit.iState := STATE_DATAGRAM_RECEIVE_START;
   end;
end;

// *****************************************************************************
//  procedure NMRAnetDatagrams_ProcessReceive;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetDatagrams_ProcessReceive;
var
  ActiveDatagram: PDatagramBuffer;
  Buffer: TCANBuffer;
begin
  ActiveDatagram := @DatagramRecieve.List[DatagramRecieve.iActiveDatagram];
  case DatagramRecieve.iState of
    STATE_DATAGRAM_RECEIVE_START :
      begin
        case ActiveDatagram^.iState of
          DATAGRAM_IN_PROCESS         : begin
                                          if ActiveDatagram^.iWatchdog >= DATAGRAM_WATCHDOG_MAX then
                                            DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_ABANDONED    // Too long between datagram frames, it is abandoned
                                          else
                                            DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_NEXT;
                                        end;
          DATAGRAM_TRANSFER_COMPLETE  : DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_RESPOND          // The datagram has been fully received time to respond to hte sender
        else
          DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_NEXT;                           // Move to the next Datagram Buffer
        end;
      end;
    STATE_DATAGRAM_RECEIVE_ABANDONED :
      begin
        if TrySendDatagramResponse(ActiveDatagram, MTI_DATAGRAM_REJECTED, @DATAGRAM_REJECTED_OUT_OF_ORDER, 3, DATAGRAM_EMPTY) then
          DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_NEXT;
      end;
    STATE_DATAGRAM_RECEIVE_RESPOND  :
      begin
        case ActiveDatagram^.ErrorCode of
          DGE_NONE                 :  begin      
                                        case ActiveDatagram^.Databytes[0] of
                                      //    DATAGRAM_TYPE_LOG_REQUEST     : DispatchSpecialDatagramLogRequest(ActiveDatagram);                // ?? unknown
                                      //    DATAGRAM_TYPE_LOG_REPLY       : DispatchSpecialDatagramLogReply(ActiveDatagram);                  // ?? unknown
                                          DATAGRAM_TYPE_CONFIGURATION   : DispatchSpecialDatagramMemConfiguration(ActiveDatagram);          // Memory Configuration Protocol
                                      //    DATAGRAM_TYPE_REMOTE_BUTTON   : DispatchSpecialDatagramRemoteButton(ActiveDatagram);              // Remote Button Configuration
                                      //    DATAGRAM_TYPE_DISPLAY         : DispatchSpecialDatagramDisplay(ActiveDatagram);                   // Display Protocol
                                          DATAGRAM_TYPE_TRAIN_CONTROL   : DispatchSpecialDatagramTrainControl(ActiveDatagram);              // Train Control Protocol
                                        end;
                                        
                                        if ActiveDatagram^.iState = DATAGRAM_TASK_RESPONDED then
                                        begin
                                          if TrySendDatagramResponse(ActiveDatagram, MTI_DATAGRAM_RECIEVED_OK, nil, 1, DATAGRAM_EMPTY) then
                                            DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_NEXT;
                                        end
                                     end;
          DGE_FRAME_OUT_OF_ORDER   : if TrySendDatagramResponse(ActiveDatagram, MTI_DATAGRAM_REJECTED, @DATAGRAM_REJECTED_OUT_OF_ORDER, 3, DATAGRAM_EMPTY) then
                                       DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_NEXT;
          DGE_BUFFER_FULL          : if TrySendDatagramResponse(ActiveDatagram, MTI_DATAGRAM_REJECTED, @DATAGRAM_REJECTED_BUFFER_FULL, 3, DATAGRAM_EMPTY) then
                                       DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_NEXT;
        end
      end;
    STATE_DATAGRAM_RECEIVE_NEXT      :
      begin
        SendAnyBufferFullResponses(ActiveDatagram);
        
        Inc(DatagramRecieve.iActiveDatagram);
        if DatagramRecieve.iActiveDatagram >= LEN_DATAGRAM_ARRAY then
          DatagramRecieve.iActiveDatagram := 0;
        DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_START
      end
   else
     DatagramRecieve.iState := STATE_DATAGRAM_RECEIVE_START;
   end;
end;

// *****************************************************************************
//  function TryAllocateBuffer;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function TryAllocateBuffer(var Datagram: PDatagramBuffer): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := 0;
  while (i < LEN_DATAGRAM_ARRAY) and not Result do
  begin
    if DatagramRecieve.List[i].iState = DATAGRAM_EMPTY then
    begin                                                                       // Grab the first empty buffer
      Datagram := @DatagramRecieve.List[i];                                             // It is NOT initialized
      Datagram^.ErrorCode := 0;
      Result := True
    end;
    Inc(i);
  end
end;

// *****************************************************************************
//  function FindInProcessDatagram;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function FindInProcessDatagram(SourceAlias: Word; var Datagram: PDatagramBuffer): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := 0;
  while (i < LEN_DATAGRAM_ARRAY) and not Result do
  begin
    if DatagramRecieve.List[i].iState = DATAGRAM_IN_PROCESS then
      if NMRAnetUtilities_CompareAliasIDs(DatagramRecieve.List[i].SourceAlias, SourceAlias) then
      begin
        Datagram := @DatagramRecieve.List[i];
        Result := True
      end;
    Inc(i)
  end
end;

// *****************************************************************************
//  procedure UpdateFrameCount;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure UpdateFrameCount(Datagram: PDatagramBuffer);
begin
  if Datagram^.ErrorCode = DGE_NONE then                                        // If in Error has already failed this function
  begin
    Inc(Datagram^.iFrameCount);                                                 // Next Frame
    Datagram^.iWatchdog := 0;                                                   // Reset the Watchdog since the source connected again
    if Datagram^.iFrameCount >= DATAGRAM_MAX_FRAME_COUNT then                   // Source sent too many frames
    begin
      Datagram^.iFrameCount := 0;
      Datagram^.iByteCount := 0;
      Datagram^.ErrorCode := DGE_FRAME_OUT_OF_ORDER                             // Ready for a "Frame out of Order" Response
    end
  end;
end;

// *****************************************************************************
//  procedure StoreBytes;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure StoreBytes(Datagram: PDatagramBuffer; var Buffer: TCANBuffer);
var
  i, Offset: Integer;
begin
  if Datagram^.ErrorCode = DGE_NONE then        // Only store if thre is no error
  begin
    Offset := Datagram^.iByteCount;
    for i := 0 to Buffer.DataCount - 1 do
    begin
      Datagram^.DataBytes[i + Offset] := Buffer.DataBytes[i];
      Inc(Datagram^.iByteCount);
    end;
  end
end;

// *****************************************************************************
//  procedure AddToBufferOverflowList;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure AddToBufferOverflowList(Datagram: PDatagramBuffer);
var
  i: Integer;
begin
  i := 0;
  while i < LEN_DATAGRAM_BUFFER_OVERFLOW_LIST do
  begin
    if DatagramRecieve.BufferOverflowList[i] = 0 then
    begin
      DatagramRecieve.BufferOverflowList[i] := Datagram^.SourceAlias;
      Exit;
    end
  end;
end;

// *****************************************************************************
//  procedure NMRAnetDatagrams_ProcessReceive;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetDatagrams_ProcessReceiveInterrupt(Buffer: PCANBuffer);
var
  Datagram: PDatagramBuffer;
begin
  Datagram := PDatagramBuffer( nil);
  case Buffer^.ID and MTI_TYPE_MASK of
    MTI_DATAGRAM_ONLY_FRAME :
      begin
        if TryAllocateBuffer(Datagram) then
        begin
          Datagram^.SourceAlias := Buffer^.ID and MASK_SOURCE_ALIAS;
          Datagram^.iByteCount := 0;
          Datagram^.iFrameCount := 0;
          StoreBytes(Datagram, Buffer^);
          Datagram^.iState := DATAGRAM_TRANSFER_COMPLETE;                           // Ready for a "Full" Response
        end
      end;
    MTI_DATAGRAM_FRAME_START :
      begin
        if TryAllocateBuffer(Datagram) then
        begin
          Datagram^.SourceAlias := Buffer^.ID and MASK_SOURCE_ALIAS;
          Datagram^.iByteCount := 0;
          Datagram^.iFrameCount := 0;
          Datagram^.iWatchdog := 0;
          StoreBytes(Datagram, Buffer^);
          Datagram^.iState := DATAGRAM_IN_PROCESS;
        end
      end;
    MTI_DATAGRAM_FRAME :
      begin
        if FindInProcessDatagram(Buffer^.ID and MASK_SOURCE_ALIAS, Datagram) then
        begin
          UpdateFrameCount(Datagram);
          StoreBytes(Datagram, Buffer^);
        end
      end;
    MTI_DATAGRAM_FRAME_END :
      begin
        if FindInProcessDatagram(Buffer^.ID and MASK_SOURCE_ALIAS, Datagram) then
        begin
          UpdateFrameCount(Datagram);
          StoreBytes(Datagram, Buffer^);
          Datagram^.iState := DATAGRAM_TRANSFER_COMPLETE;                         // Ready for a "Full" Response
        end else
          AddToBufferOverflowList(Datagram);
      end;
   end;
end;

end.