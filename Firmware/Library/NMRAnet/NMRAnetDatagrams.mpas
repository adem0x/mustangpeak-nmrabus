unit NMRAnetDatagrams;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//
// ******************************************************************************

uses
  NMRAnetUtilities,
  CANDefines,
  CANStorage,
  NMRAnetBufferPoolsDefines,
  NMRAnetDefines,
  NMRAnetDatagramDefines,
  NMRAnetConfigurationProtocol;

procedure NMRAnetDatagrams_Initialize;
procedure NMRAnetDatagrams_InitializeDatagramBuffer(DatagramBuffer: PDatagramBuffer);
procedure NMRAnetDatagrams_ProcessTransmit(Node: PNMRAnetNode);
procedure NMRAnetDatagrams_100ms_TimeTick(Node: PNMRAnetNode);
procedure NMRAnetDatagrams_SetCallback(var Hook: PDatagramTaskCallbackFunc; Func: PDatagramTaskCallbackFunc);   // Hook is any variable in NMRAnetDatagramDefines: DatagramTrainControlHook, DatagramMemConfigurationHook, etc


// defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure EnableCANInterrupt(Enable: Boolean); external;
// defined in the NMRAnetStateMachine.mpas file
  function TryTransmitNMRABusLayerMsg(Node: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes): Boolean; external;

implementation

procedure NMRAnetDatagrams_InitializeDatagramBuffer(Buffer: PDatagramBuffer);
var
  i, j: Integer;
begin
  if Buffer <> nil then
  begin
    Buffer^.State := CBS_EMPTY;
    Buffer^.Alias := 0;
    Buffer^.Next := 0;
    Buffer^.RefCount := 0;
    Buffer^.mCode := 0;
    Buffer^.Tag := 0;

    Buffer^.iByteCount := 0;
    Buffer^.iWatchdog := 0;
    Buffer^.ErrorCode.MTI := MTI_EXTENSION_DATAGRAM_RECIEVED_OK;                // Assume Success
    Buffer^.ErrorCode.Count := 1;                                               // Assume only the MTI
    Buffer^.ErrorCode.SubType[0] := 0;
    Buffer^.ErrorCode.SubType[1] := 0;
    Buffer^.iRetransmit := 0;
    Buffer^.iFrameCount := 0;
    Buffer^.iStateMachine := 0;                                                 // Not sure if is TX or RX at this point but does not matter for start
    for j := 0 to LEN_DATAGRAM-1 do
      Buffer^.DataBytes[j] := 0;
  end
end;

// *****************************************************************************
//  procedure NMRAnetDatagrams_Initialize;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetDatagrams_Initialize;
begin
  DatagramCallbackFunc := PDatagramTaskCallbackFunc(nil);
  DatagramTrainControlCallbackFunc := PDatagramTaskCallbackFunc(nil);
  DatagramMemConfigurationCallbackFunc := PDatagramTaskCallbackFunc(nil);
end;


// *****************************************************************************
//
// procedure NMRAnetDatagrams_SetCallback;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Not really a necessary function just helps future use in reminding
//              how these Callbacks work.
//
//              Callback is the variable int NMRAnetDatagramDefines
//                           DatagramUnknownCallback: PDatagramTaskCallbackFunc;
//                           DatagramTrainControlCallback: PDatagramTaskCallbackFunc;
//                           DatagramMemConfigurationCallback: PDatagramTaskCallbackFunc;
//                           etc
//
// *****************************************************************************
procedure NMRAnetDatagrams_SetCallback(var Hook: PDatagramTaskCallbackFunc; Func: PDatagramTaskCallbackFunc);
begin
  Hook := Func
end;

// *****************************************************************************
//
// procedure NMRAnetDatagrams_100ms_TimeTick;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Updates internal flags to track for various timeout conditions mainly for the bus.
//
//              WARNING: Application must make sure that the Datagram Array is not
//              modified in an interrupt when calling this function...... Disable the CAN for
//              the time this takes to run.
//
// *****************************************************************************
procedure NMRAnetDatagrams_100ms_TimeTick(Node: PNMRAnetNode);
var
  DatagramBuffer: PDatagramBuffer;
begin

//   NEED TO DEAL WITH ABANDON DATAGRAMS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1



{  if Node^.Msg <> nil then
  begin
    if Node^.Msg^.State and RMB_BUFFER_DATAGRAM <> 0 then                                           // See if the buffer is a Datagram Pointer
    begin
      DatagramBuffer :=  PDatagramBuffer(Node^.Msg^.BufferPtr);
      if DatagramBuffer^.iWatchdog < DATAGRAM_WATCHDOG_MAX then                 // Latch it at DATAGRAM_WATCHDOG_MAX
        Inc( DatagramBuffer^.iWatchdog)                                          // Increase the Watchdog counter
    end
  end; }
end;

// *****************************************************************************
//  function TrySendDatagramResponse;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function TrySendDatagramResponse(Node: PNMRAnetNode; Datagram: PDatagramBuffer; NextDatagramState: Byte): Boolean;
var
  Buffer: TCANBuffer;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    NMRAnetUtilities_CreateNMRABusMessagePacket(Node, @Buffer, MTI_ADDRESSED, Datagram^.Alias, Datagram^.iByteCount, nil);
    Buffer.DataBytes[0] := Datagram^.ErrorCode.MTI;
    Buffer.DataBytes[1] := Datagram^.ErrorCode.SubType[0];
    Buffer.DataBytes[2] := Datagram^.ErrorCode.SubType[1];

    if CANStorage_AddToList(@TX_NMRAnetBufferList, @Buffer) then
    begin
      StartCANMessageEngine();      
      Datagram^.State := NextDatagramState;                                    // Set the new state of the Datagram buffer
      Result := True
    end
  end
end;

// *****************************************************************************
//  procedure SendBufferFullResponses;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure SendBufferFullResponses(Node: PNMRAnetNode);
var
  i: Integer;
  Datagram: TDatagramBuffer;
begin
 { if Node^.DatagramReceive <> nil then
  begin
    if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
    begin
      i := 0;
      while i < LEN_DATAGRAM_BUFFER_OVERFLOW_LIST do
      begin
        if Node^.DatagramOverflowList[i] <> 0 then
        begin
          Datagram.Alias := Node^.DatagramOverflowList[i];
          NMRANetUtilities_LoadDatagramResultBytes(@Datagram, MTI_TYPE_DATAGRAM_REJECTED, @DATAGRAM_RESULT_REJECTED_BUFFER_FULL);
          if TrySendDatagramResponse(Node, @Datagram, DATAGRAM_BUFFER_EMPTY) then
            Node^.DatagramOverflowList[i] := 0;
          Exit;
        end;
        Inc(i);
      end;
    end
  end     }
end;


// *****************************************************************************
//  procedure DispatchSpecialDatagramMemConfiguration;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchSpecialDatagramMemConfiguration(Node: PNMRAnetNode; Datagram: PDatagramBuffer; NextHandledState, NextUnHandledState: Byte);
var
  Handled: Boolean;
begin
  Handled := False;
  if DatagramMemConfigurationCallbackFunc <> PDatagramTaskCallbackFunc(nil) then
    DatagramMemConfigurationCallbackFunc(Node, Datagram, Handled);
  
  NMRAnetConfigurationProtocol_HandleDatagram(Datagram);
    
  if Handled then
    Datagram^.iStateMachine := NextHandledState
  else
    Datagram^.iStateMachine := NextUnHandledState
end;


// *****************************************************************************
//  procedure DispatchSpecialDatagramTrainControl;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchSpecialDatagramTrainControl(Node: PNMRAnetNode; Datagram: PDatagramBuffer; NextHandledState, NextUnHandledState: Byte);
var
  Handled: Boolean;
begin      
  Handled := False;
  if DatagramTrainControlCallbackFunc <> PDatagramTaskCallbackFunc( nil) then
    DatagramTrainControlCallbackFunc(Node, Datagram, Handled);
    
  if Handled then
    Datagram^.iStateMachine := NextHandledState
  else
    Datagram^.iStateMachine := NextUnHandledState
end;

// *****************************************************************************
//  procedure DispatchDatagram;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchDatagram(Node: PNMRAnetNode; Datagram: PDatagramBuffer; NextHandledState, NextUnHandledState: Byte);
var
  Handled: Boolean;
begin
  Handled := False;
  if DatagramCallbackFunc <> PDatagramTaskCallbackFunc( nil) then
    DatagramCallbackFunc(Node, Datagram, Handled);
    
  if Handled then
    Datagram^.iStateMachine := NextHandledState
  else
    Datagram^.iStateMachine := NextUnHandledState
end;

// *****************************************************************************
//  procedure TransmitClassifyDatagram;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure TransmitClassifyDatagram(Datagram: PDatagramBuffer; NextState_Single, NextState_Multi: Byte);
begin
 { if Datagram^.State <> DATAGRAM_BUFFER_EMPTY then
  begin
    Datagram^.iReTransmit := 0;
    Datagram^.iFrameCount := 0;
    if Datagram^.iByteCount < 9 then                      // It is a single Frame Datagram
      Datagram^.iStateMachine := NextState_Single
    else
      Datagram^.iStateMachine:= NextState_Multi
  end    }
end;


// *****************************************************************************
//  procedure TransmitClassifyDatagram;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure TransmitSingleDatagram(Node: PNMRAnetNode; Buffer: PCANBuffer; Datagram: PDatagramBuffer; SourceAliasID: Word; NextState: Byte);
begin
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_DATAGRAM_ONLY_FRAME, Datagram^.Alias, Datagram^.iByteCount, PCAN_DataBytes( @Datagram^.DataBytes[0]) ) then
    begin
      Inc(Datagram^.iRetransmit);
      Datagram^.iWatchdog := 0;
      Datagram^.iStateMachine := NextState
     end
  end
end;

// *****************************************************************************
//  procedure TransmitMultiDatagram;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure TransmitMultiDatagram(Node: PNMRAnetNode; Buffer: PCANBuffer; Datagram: PDatagramBuffer; SourceAlias: Word; NextState: Byte);
var
  Count: Byte;
  MTI: DWord;
begin
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    Count := 8;                                                                 // Take a guess
    if Datagram^.iFrameCount = 0 then                                           // Calculate the MTI value for the Frame to be sent
      MTI := MTI_DATAGRAM_FRAME_START
    else
    if Datagram^.iFrameCount = (Datagram^.iByteCount - 1) div 8 then
    begin
      Count := Datagram^.iByteCount - (Datagram^.iFrameCount * 8);
      MTI := MTI_DATAGRAM_FRAME_END
    end else
      MTI := MTI_DATAGRAM_FRAME;

    if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI, Datagram^.Alias, Count, PCAN_DataBytes( @Datagram^.DataBytes[Datagram^.iFrameCount * 8])) then
    begin
      Inc(Datagram^.iFrameCount);
      Datagram^.iWatchdog := 0;
      if MTI = MTI_DATAGRAM_FRAME_END then
      begin
        Inc(Datagram^.iRetransmit);
        Datagram^.iStateMachine := NextState;
      end
    end
  end
end;

// *****************************************************************************
//  procedure TransmitWaitForResponse;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure TransmitWaitForResponse(Datagram: PDatagramBuffer; NextState_Okay, NextState_Retry, NextState_Bailout: Byte);
begin
  // DATAGRAM_BUFFER_TRANSFER_COMPLETE will be set by NMRAnetStateMachine.HandleDatagramResponse when the target datagram responds
 { if Datagram^.State = DATAGRAM_BUFFER_TRANSFER_COMPLETE then
  begin
    case Datagram^.ErrorCode.MTI of
       MTI_TYPE_DATAGRAM_RECIEVED_OK :
         begin
           Datagram^.State := DATAGRAM_BUFFER_EMPTY;
           Datagram^.iStateMachine := NextState_Okay;
         end;
       MTI_TYPE_DATAGRAM_REJECTED :                                            // Rejected, decode what the issue was
         begin

           if DATAGRAM_RESULT_REJECTED_RESEND_MASK[0] and Datagram^.ErrorCode.SubType[1] <> 0 then
           begin    
             // Try to Resend
             if Datagram^.iRetransmit < DATAGRAM_MAX_RETRY_COUNT then
             begin
               Datagram^.iWatchdog := 0;
               Datagram^.iFrameCount := 0;
               Datagram^.State := DATAGRAM_BUFFER_IN_PROCESS;
               Datagram^.iStateMachine := NextState_Retry
             end else 
             begin
               Datagram^.State := DATAGRAM_BUFFER_EMPTY;
               Datagram^.iStateMachine := NextState_Bailout;
             end;
           end else
           if DATAGRAM_RESULT_REJECTED_NO_RESENT_MASK[0] and Datagram^.ErrorCode.SubType[1] <> 0 then
           begin
             // Don't Resend

             // TODO: STORE A LIST OF NODES TO NOT SEND TO????????
             
             Datagram^.iStateMachine := NextState_Bailout;
             Datagram^.State := DATAGRAM_BUFFER_EMPTY;
           end else
           begin
             // Don't know what happended
             Datagram^.iStateMachine := NextState_Bailout;
             Datagram^.State := DATAGRAM_BUFFER_EMPTY;
           end;
         end;
     end; // case
  end else
  begin
    if Datagram^.iWatchdog >= DATAGRAM_WATCHDOG_MAX then
    begin
      if Datagram^.iRetransmit >= DATAGRAM_MAX_RETRY_COUNT then
      begin
        Datagram^.State := DATAGRAM_BUFFER_EMPTY;
        Datagram^.iStateMachine := NextState_Bailout;
      end else
      begin
        Datagram^.iWatchdog := 0;
        Datagram^.iFrameCount := 0;
        Datagram^.iStateMachine := NextState_Retry
      end
    end
  end  }
end;

// *****************************************************************************
//  procedure NMRAnetDatagrams_ProcessTransmit;
//
//  Parameters:
//
//  Result:
//
//  Description: The StateMachine index is stored within each Datagram Buffer. As
//               such a hung datagram due to a non-responsve target will not hang up
//               other datagrams being dealt with
// *****************************************************************************
procedure NMRAnetDatagrams_ProcessTransmit(Node: PNMRAnetNode);
var
  Buffer: TCANBuffer;
  ActiveDatagram: PDatagramBuffer;
begin
{  if Node^.DatagramTransmit <> nil then
  begin
    ActiveDatagram := Node^.DatagramTransmit;
    if ActiveDatagram^.State <> DATAGRAM_BUFFER_EMPTY then
    begin
      case ActiveDatagram^.iStateMachine of
        STATE_DATAGRAM_TRANSMIT_START                          : TransmitClassifyDatagram(ActiveDatagram, STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME, STATE_DATAGRAM_TRANSMIT_MULTI_FRAME);
        STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME                   : TransmitSingleDatagram(Node, @Buffer, ActiveDatagram, Node^.Node.AliasID, STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_SINGLE_FRAME);
        STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_SINGLE_FRAME : TransmitWaitForResponse(ActiveDatagram, STATE_DATAGRAM_TRANSMIT_START, STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME, STATE_DATAGRAM_TRANSMIT_START);
        STATE_DATAGRAM_TRANSMIT_MULTI_FRAME                    : TransmitMultiDatagram(Node, @Buffer, ActiveDatagram, Node^.Node.AliasID, STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_MULTI_FRAME);
        STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_MULTI_FRAME  : TransmitWaitForResponse(ActiveDatagram, STATE_DATAGRAM_TRANSMIT_START, STATE_DATAGRAM_TRANSMIT_MULTI_FRAME, STATE_DATAGRAM_TRANSMIT_START)
       else
         ActiveDatagram^.iStateMachine := STATE_DATAGRAM_TRANSMIT_START;
       end;
    end;
  end    }                        // TODO THIS WILL BE RECURSIVE INTO THE LINKED LIST!!!@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
end;

procedure ProcessAbandonedDatagram(Datagram: PDatagramBuffer; AbandonState, NextState: Byte);
begin
  if Datagram^.iWatchdog >= DATAGRAM_WATCHDOG_MAX then
  begin
    NMRANetUtilities_LoadDatagramResultBytes(Datagram, MTI_EXTENSION_DATAGRAM_REJECTED, @DATAGRAM_RESULT_REJECTED_OUT_OF_ORDER);
    Datagram^.iStateMachine := AbandonState    // Too long between datagram frames, it is abandoned
  end else
    Datagram^.iStateMachine := NextState;
end;

end.