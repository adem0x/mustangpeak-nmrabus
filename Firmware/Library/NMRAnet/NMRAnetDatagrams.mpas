unit NMRAnetDatagrams;

uses
  NMRAnetUtilities,
  CANDefines,
  CANStorage,
  NMRAnetDefines,
  NMRAnetDatagramDefines;

procedure NMRAnetDatagrams_Initialize;
procedure NMRAnetDatagrams_ProcessReceiveInterrupt(Buffer: PCANBuffer);
procedure NMRAnetDatagrams_ProcessReceive;
procedure NMRAnetDatagrams_ProcessTransmit;
procedure NMRAnetDatagrams_1ms_TimeTick;
procedure NMRAnetDatagrams_SetSpecialCallback(var Hook: PDatagramSpecialTaskCallbackFunc; Func: PDatagramSpecialTaskCallbackFunc);   // Hook is any variable in NMRAnetDatagramDefines: DatagramTrainControlHook, DatagramMemConfigurationHook, etc
procedure NMRAnetDatagrams_SetCallback(var Hook: PDatagramTaskCallbackFunc; Func: PDatagramTaskCallbackFunc);   // Hook is any variable in NMRAnetDatagramDefines: DatagramTrainControlHook, DatagramMemConfigurationHook, etc

// defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure EnableCANInterrupt(Enable: Boolean); external;
// defined in the NMRAnetStateMachine.mpas file
  function TryTransmitNMRABusLayerMsg(VariableField: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes; Buffer: PCANBuffer): Boolean; external;

implementation

// *****************************************************************************
//  procedure NMRAnetDatagrams_Initialize;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetDatagrams_Initialize;
var
  i, j: Integer;
begin
  for i := 0 to LEN_DATAGRAM_RECEIVE_ARRAY - 1 do
  begin
    DatagramReceive.List[i].iState := DATAGRAM_BUFFER_EMPTY;
    DatagramReceive.List[i].iState := 0;
    for j := 0 to LEN_DATAGRAM-1 do
      DatagramReceive.List[i].DataBytes[j] := 0;
  end;
  DatagramReceive.iState := STATE_DATAGRAM_RECEIVE_START;
  DatagramReceive.iActiveDatagram := 0;
  for i := 0 to LEN_DATAGRAM_BUFFER_OVERFLOW_LIST-1 do
    DatagramReceive.BufferOverflowList[i] := 0;
    
  for i := 0 to LEN_DATAGRAM_TRANSMIT_ARRAY - 1 do
  begin
    DatagramTransmit.List[i].iState := DATAGRAM_BUFFER_EMPTY;
    DatagramTransmit.List[i].iState := 0;
    for j := 0 to LEN_DATAGRAM-1 do
      DatagramTransmit.List[i].DataBytes[j] := 0;
  end;
  DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_START;
  DatagramTransmit.iActiveDatagram := 0;
  
  DatagramCallback := PDatagramTaskCallbackFunc(nil);
  DatagramTrainControlCallback := PDatagramSpecialTaskCallbackFunc(nil);
  DatagramMemConfigurationCallback := PDatagramSpecialTaskCallbackFunc(nil);
end;


// *****************************************************************************
//
// procedure NMRAnetDatagrams_SetSpecialCallback;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Not really a necessary function just helps future use in reminding
//              how these Callbacks work.
//
//              Callback is the variable int NMRAnetDatagramDefines
//                           DatagramUnknownCallback: PDatagramTaskCallbackFunc;
//                           DatagramTrainControlCallback: PDatagramTaskCallbackFunc;
//                           DatagramMemConfigurationCallback: PDatagramTaskCallbackFunc;
//                           etc
//
// *****************************************************************************
procedure NMRAnetDatagrams_SetSpecialCallback(var Hook: PDatagramSpecialTaskCallbackFunc; Func: PDatagramSpecialTaskCallbackFunc);
begin
  Hook := Func
end;

// *****************************************************************************
//
// procedure NMRAnetDatagrams_SetCallback;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Not really a necessary function just helps future use in reminding
//              how these Callbacks work.
//
//              Callback is the variable int NMRAnetDatagramDefines
//                           DatagramUnknownCallback: PDatagramTaskCallbackFunc;
//                           DatagramTrainControlCallback: PDatagramTaskCallbackFunc;
//                           DatagramMemConfigurationCallback: PDatagramTaskCallbackFunc;
//                           etc
//
// *****************************************************************************
procedure NMRAnetDatagrams_SetCallback(var Hook: PDatagramTaskCallbackFunc; Func: PDatagramTaskCallbackFunc);
begin
  Hook := Func
end;

// *****************************************************************************
//
// procedure NMRAnetDatagrams_1ms_TimeTick;
//
//  Parameters:
//                None
//  Returns:
//                None
//  Description:
//              Updates internal flags to track for various timeout conditions mainly for the bus.
//
//              WARNING: Application must make sure that the Datagram Array is not
//              modified in an interrupt when calling this function...... Disable the CAN for
//              the time this takes to run.
//
// *****************************************************************************
procedure NMRAnetDatagrams_1ms_TimeTick;
var
  i: Integer;
begin
  for i := 0 to LEN_DATAGRAM_RECEIVE_ARRAY - 1 do
  begin
    if DatagramReceive.List[i].iState = DATAGRAM_BUFFER_IN_PROCESS then
    begin
      if DatagramReceive.List[i].iWatchdog < DATAGRAM_WATCHDOG_MAX then                 // Latch it at DATAGRAM_WATCHDOG_MAX
        Inc(DatagramReceive.List[i].iWatchdog)                                          // Increase the Watchdog counter
    end
  end;
end;

// *****************************************************************************
//  function FindMatchingInProcessTransmitDatagram;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function FindMatchingInProcessTransmitDatagram(Alias: Word; var Datagram: PDatagramBuffer): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := 0;
  while i < LEN_DATAGRAM_TRANSMIT_ARRAY do
  begin
    if DatagramTransmit.List[i].iState = DATAGRAM_BUFFER_IN_PROCESS then
      if NMRAnetUtilities_CompareAliasIDs(DatagramTransmit.List[i].Alias, Alias) then
      begin
        Datagram := @DatagramReceive.List[i];
        Result := True;
        Exit;
      end;
    Inc(i)
  end
end;

// *****************************************************************************
//  function TrySendDatagramResponse;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function TrySendDatagramResponse(Datagram: PDatagramBuffer; NextDatagramState: Byte): Boolean;
var
  Buffer: TCANBuffer;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    NMRAnetUtilities_CreateNMRABusMessagePacket(MTI_ADDRESSED, Datagram^.Alias, @Buffer);
    Buffer.DataBytes[0] := Datagram^.ErrorCode.MTI;
    Buffer.DataBytes[1] := Datagram^.ErrorCode.SubType[0];
    Buffer.DataBytes[2] := Datagram^.ErrorCode.SubType[1];

    if CANStorage_AddToList(@TX_NMRAnetBufferList, @Buffer) then
    begin
      StartCANMessageEngine();      
      Datagram^.iState := NextDatagramState;                                    // Set the new state of the Datagram buffer
      Result := True
    end
  end
end;

// *****************************************************************************
//  procedure SendBufferFullResponses;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure SendBufferFullResponses;
var
  i: Integer;
  Datagram: TDatagramBuffer;
begin
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    i := 0;
    while i < LEN_DATAGRAM_BUFFER_OVERFLOW_LIST do
    begin
      if DatagramReceive.BufferOverflowList[i] <> 0 then
      begin
        Datagram.Alias := DatagramReceive.BufferOverflowList[i];
        NMRANetUtilities_LoadDatagramResultBytes(@Datagram, MTI_DATAGRAM_REJECTED, DATAGRAM_RESULT_REJECTED_BUFFER_FULL);
        if TrySendDatagramResponse(@Datagram, DATAGRAM_BUFFER_EMPTY) then
          DatagramReceive.BufferOverflowList[i] := 0;
        Exit;
      end;
        Inc(i); 
    end;
  end
end;


// *****************************************************************************
//  procedure DispatchSpecialDatagramMemConfiguration;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchSpecialDatagramMemConfiguration(Datagram: PDatagramBuffer; NextState: Byte);
begin
  if DatagramMemConfigurationCallback <> PDatagramSpecialTaskCallbackFunc(nil) then
    DatagramMemConfigurationCallback(Datagram);
  DatagramTransmit.iState := NextState;
end;


// *****************************************************************************
//  procedure DispatchSpecialDatagramTrainControl;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchSpecialDatagramTrainControl(Datagram: PDatagramBuffer; NextState: Byte);
begin      
  if DatagramTrainControlCallback <> PDatagramSpecialTaskCallbackFunc( nil) then
    DatagramTrainControlCallback(Datagram);
  DatagramTransmit.iState := NextState
end;

// *****************************************************************************
//  procedure DispatchDatagram;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function DispatchDatagram(Datagram: PDatagramBuffer; NextState: Byte): Boolean;
begin
  Result := True;
  if DatagramCallback <> PDatagramTaskCallbackFunc( nil) then
    DatagramCallback(Datagram, Result)
  else
    Result := False;
  DatagramTransmit.iState := NextState
end;

// *****************************************************************************
//  procedure DispatchDatagramTransmissionResponse;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure DispatchDatagramTransmissionResponse(Datagram: PDatagramBuffer; NextState: Byte);
var
  TransmitDatagram: PDatagramBuffer;
begin
  if FindMatchingInProcessTransmitDatagram(Datagram^.Alias, TransmitDatagram) then            // See if the response datagram is the response for a datagram we sent and are waiting for
  begin
    TransmitDatagram^.ErrorCode.MTI := Datagram^.ErrorCode.MTI;                 // Copy over the results that destination node passed in the received Datagram Result message
    TransmitDatagram^.ErrorCode.SubType := Datagram^.ErrorCode.SubType;
    TransmitDatagram^.iState := DATAGRAM_BUFFER_TRANSFER_COMPLETE;
  end;
  DatagramTransmit.iState := NextState
end;


// *****************************************************************************
//  procedure TryReTransmitDatagram;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure TryReTransmitDatagram(Datagram: PDatagramBuffer; RetryState, FailureState: Byte);
begin
  Inc(Datagram^.iRetransmit);
  if Datagram^.iRetransmit > DATAGRAM_MAX_RETRY_COUNT then
  begin
    Datagram^.iState := DATAGRAM_BUFFER_EMPTY;
    DatagramTransmit.iState := FailureState
  end else
    DatagramTransmit.iState := RetryState
end;

// *****************************************************************************
//  procedure WaitingForDatagramResponse;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure WaitingForDatagramResponse(Datagram: PDatagramBuffer; RetryState, FailureState: Byte);
begin
  if Datagram^.iState = DATAGRAM_BUFFER_TRANSFER_COMPLETE then      // DATAGRAM_BUFFER_TRANSFER_COMPLETE will be set by the ProcessReceive when the destination node Responds to the datagram
  begin
  {   case Datagram^.ErrorCode of
        DGE_NONE                  : DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_NEXT;  // All done
        DGE_FRAME_OUT_OF_ORDER    : TryReTransmitDatagram(Datagram, STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME, STATE_DATAGRAM_TRANSMIT_NEXT);
        DGE_BUFFER_FULL           : TryReTransmitDatagram(Datagram, STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME, STATE_DATAGRAM_TRANSMIT_NEXT);
     end;     }
  end else
    if Datagram^.iWatchdog > DATAGRAM_WATCHDOG_MAX then
      TryReTransmitDatagram(Datagram, STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME, STATE_DATAGRAM_TRANSMIT_NEXT);
end;

// *****************************************************************************
//  procedure NMRAnetDatagrams_ProcessTransmit;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetDatagrams_ProcessTransmit;
var
  Buffer: TCANBuffer;
  ActiveDatagram: PDatagramBuffer;
  i: Integer;
begin
  ActiveDatagram := @DatagramTransmit.List[DatagramTransmit.iActiveDatagram];
  
  case DatagramTransmit.iState of
  
    STATE_DATAGRAM_TRANSMIT_START :
      begin
        if ActiveDatagram^.iState <> DATAGRAM_BUFFER_EMPTY then
        begin
          if ActiveDatagram^.iByteCount < 9 then                      // It is a single Frame Datagram
            DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME
          else
            DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_MULTI_FRAME
        end
      end;
      
    STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME :
      begin
        if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
        begin
          for i := 0 to ActiveDatagram^.iByteCount - 1 do                             // Copy the Data into the CAN Buffer
            Buffer.DataBytes[i] := ActiveDatagram^.DataBytes[i];
          Buffer.DataCount := ActiveDatagram^.iByteCount;                             // Copy the Size of the Data into the CAN Buffer
          
          if TryTransmitNMRABusLayerMsg(MTI_DATAGRAM_ONLY_FRAME, ActiveDatagram^.Alias, 0, nil, @Buffer) then
          begin
            ActiveDatagram^.iWatchdog := 0;
            ActiveDatagram^.iReTransmit := 0;
            DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_SINGLE_FRAME;
          end;
        end
      end;
      
    STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_SINGLE_FRAME :  
      begin
        WaitingForDatagramResponse(ActiveDatagram, STATE_DATAGRAM_TRANSMIT_SINGLE_FRAME, STATE_DATAGRAM_TRANSMIT_NEXT);
      end;
      
    STATE_DATAGRAM_TRANSMIT_MULTI_FRAME :
      begin
        DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_MULTI_FRAME;
      end;
      
    STATE_DATAGRAM_TRANSMIT_NEXT_MULTI_FRAME :
      begin
         DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_MULTI_FRAME;
      end;
      
    STATE_DATAGRAM_TRANSMIT_WAIT_FOR_RESPONSE_MULTI_FRAME :
      begin
        WaitingForDatagramResponse(ActiveDatagram, STATE_DATAGRAM_TRANSMIT_MULTI_FRAME, STATE_DATAGRAM_TRANSMIT_NEXT);
      end;
      
    STATE_DATAGRAM_TRANSMIT_NEXT :
      begin
        Inc(DatagramTransmit.iActiveDatagram);
        if DatagramTransmit.iActiveDatagram > LEN_DATAGRAM_TRANSMIT_ARRAY then DatagramTransmit.iActiveDatagram := 0;
        DatagramTransmit.iState := STATE_DATAGRAM_TRANSMIT_START
      end
   else
     DatagramTransmit.iState := STATE_DATAGRAM_RECEIVE_START;
   end;
end;

procedure ProcessAbandonedDatagram(Datagram: PDatagramBuffer; AbandonState, NextState: Byte);
begin
  if Datagram^.iWatchdog >= DATAGRAM_WATCHDOG_MAX then
  begin
    NMRANetUtilities_LoadDatagramResultBytes(Datagram, MTI_DATAGRAM_REJECTED, DATAGRAM_RESULT_REJECTED_OUT_OF_ORDER);
    DatagramReceive.iState := AbandonState    // Too long between datagram frames, it is abandoned
  end else
    DatagramReceive.iState := NextState;
end;

// *****************************************************************************
//  procedure NMRAnetDatagrams_ProcessReceive;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetDatagrams_ProcessReceive;
var
  ActiveDatagram: PDatagramBuffer;
  Buffer: TCANBuffer;
begin
  ActiveDatagram := @DatagramReceive.List[DatagramReceive.iActiveDatagram];
  case DatagramReceive.iState of
  
    STATE_DATAGRAM_RECEIVE_START :
      begin
        case ActiveDatagram^.iState of
          DATAGRAM_BUFFER_IN_PROCESS         : ProcessAbandonedDatagram(ActiveDatagram, STATE_DATAGRAM_SENDING_RESPONSE, STATE_DATAGRAM_RECEIVE_NEXT);
          DATAGRAM_BUFFER_TRANSFER_COMPLETE  : DatagramReceive.iState := STATE_DATAGRAM_RECEIVE_COMPLETE  // The datagram has been fully received time to respond to hte sender
        else
          DatagramReceive.iState := STATE_DATAGRAM_RECEIVE_NEXT;                // Move to the next Datagram Buffer if the State is corrupted
        end;
      end;
      
    STATE_DATAGRAM_RECEIVE_COMPLETE  :             // ProcessReceiveInterrupt has completed the datagram on the CAN layer
      begin                                        // it has filled in the ErrorCode within that Statemachine during Receive
        case ActiveDatagram^.ErrorCode.MTI of
          MTI_DATAGRAM_RECIEVED_OK : begin
                                        case ActiveDatagram^.Databytes[0] of
                                          // Responses expected through a transmission of a datagram
                                          MTI_DATAGRAM_RECIEVED_OK,
                                          MTI_DATAGRAM_REJECTED         : DispatchDatagramTransmissionResponse(ActiveDatagram, STATE_DATAGRAM_RECEIVE_NEXT);
                                          // Unsolicited datagrams sent to node
                                          DATAGRAM_TYPE_CONFIGURATION   : DispatchSpecialDatagramMemConfiguration(ActiveDatagram, STATE_DATAGRAM_SENDING_RESPONSE);          // Memory Configuration Protocol
                                          DATAGRAM_TYPE_TRAIN_CONTROL   : DispatchSpecialDatagramTrainControl(ActiveDatagram, STATE_DATAGRAM_SENDING_RESPONSE)              // Train Control Protocol
                                        else begin
                                           // Return Not Accepted for any datagram types not handled
                                           if not DispatchDatagram(ActiveDatagram, STATE_DATAGRAM_SENDING_RESPONSE) then
                                           begin
                                              NMRANetUtilities_LoadDatagramResultBytes(ActiveDatagram, MTI_DATAGRAM_REJECTED, DATAGRAM_RESULT_REJECTED_SOURCE_DATAGRAMS_NOT_ACCEPTED);
                                              DatagramReceive.iState := STATE_DATAGRAM_SENDING_RESPONSE;
                                            end
                                          end;
                                        end;
           end;
          MTI_DATAGRAM_REJECTED    : begin   // The Receive Statemachine has already loaded up the ErrorCode field with the reason for the Rejection
                                         DatagramReceive.iState := STATE_DATAGRAM_SENDING_RESPONSE;
                                     end;
        end
      end;
      
    STATE_DATAGRAM_SENDING_RESPONSE  :     // Make sure the ErrorCode informatoin is preloaded into the Datagram before entering this State
      begin
        if TrySendDatagramResponse(ActiveDatagram, DATAGRAM_BUFFER_EMPTY) then
          DatagramReceive.iState := STATE_DATAGRAM_RECEIVE_NEXT;
      end;
      
    STATE_DATAGRAM_ERROR_RESPONSES  :
      begin
        SendBufferFullResponses;
        DatagramReceive.iState := STATE_DATAGRAM_RECEIVE_NEXT
      end;
      
    STATE_DATAGRAM_RECEIVE_NEXT      :
      begin
        Inc(DatagramReceive.iActiveDatagram);
        if DatagramReceive.iActiveDatagram >= LEN_DATAGRAM_RECEIVE_ARRAY then
          DatagramReceive.iActiveDatagram := 0;
        DatagramReceive.iState := STATE_DATAGRAM_RECEIVE_START
      end
   else
     DatagramReceive.iState := STATE_DATAGRAM_RECEIVE_START;
   end;
end;

// *****************************************************************************
//  function TryAllocateBuffer;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function TryAllocateBuffer(var Datagram: PDatagramBuffer): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := 0;
  while (i < LEN_DATAGRAM_RECEIVE_ARRAY) and not Result do
  begin
    if DatagramReceive.List[i].iState = DATAGRAM_BUFFER_EMPTY then
    begin                                                                       // Grab the first empty buffer
      Datagram := @DatagramReceive.List[i];                                     // It is NOT initialized
      Datagram^.ErrorCode.MTI := MTI_DATAGRAM_RECIEVED_OK;
      Result := True
    end;
    Inc(i);
  end
end;

// *****************************************************************************
//  function FindMatchingInProcessReceiveDatagram;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
function FindMatchingInProcessReceiveDatagram(Alias: Word; var Datagram: PDatagramBuffer): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := 0;
  while i < LEN_DATAGRAM_RECEIVE_ARRAY do
  begin
    if DatagramReceive.List[i].iState = DATAGRAM_BUFFER_IN_PROCESS then
      if NMRAnetUtilities_CompareAliasIDs(DatagramReceive.List[i].Alias, Alias) then
      begin
        Datagram := @DatagramReceive.List[i];
        Result := True;
        Exit;
      end;
    Inc(i)
  end
end;

// *****************************************************************************
//  procedure UpdateFrameCount;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure UpdateFrameCount(Datagram: PDatagramBuffer);
begin
  if Datagram^.ErrorCode.MTI = MTI_DATAGRAM_RECIEVED_OK then                     // If in Error has already failed this function
  begin
    Inc(Datagram^.iFrameCount);                                                 // Next Frame
    Datagram^.iWatchdog := 0;                                                   // Reset the Watchdog since the source connected again
    if Datagram^.iFrameCount >= DATAGRAM_MAX_FRAME_COUNT then                   // Source sent too many frames
    begin
      Datagram^.iFrameCount := 0;
      Datagram^.iByteCount := 0;
      Datagram^.ErrorCode.MTI := MTI_DATAGRAM_REJECTED;
      Datagram^.ErrorCode.SubType := DATAGRAM_RESULT_REJECTED_OUT_OF_ORDER      // Ready for a "Frame out of Order" Response
    end
  end;
end;

// *****************************************************************************
//  procedure StoreBytes;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure StoreBytes(Datagram: PDatagramBuffer; var Buffer: TCANBuffer);
var
  i, Offset: Integer;
begin
  if Datagram^.ErrorCode.MTI = MTI_DATAGRAM_RECIEVED_OK then        // Only store if thre is no error
  begin
    Offset := Datagram^.iByteCount;
    for i := 0 to Buffer.DataCount - 1 do
    begin
      Datagram^.DataBytes[i + Offset] := Buffer.DataBytes[i];
      Inc(Datagram^.iByteCount);
    end;
  end
end;

// *****************************************************************************
//  procedure AddToBufferOverflowList;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure AddToBufferOverflowList(Datagram: PDatagramBuffer);
var
  i: Integer;
begin
  i := 0;
  while i < LEN_DATAGRAM_BUFFER_OVERFLOW_LIST do
  begin
    if DatagramReceive.BufferOverflowList[i] = 0 then
    begin
      DatagramReceive.BufferOverflowList[i] := Datagram^.Alias;
      Exit;
    end
  end;
end;

// *****************************************************************************
//  procedure NMRAnetDatagrams_ProcessReceive;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetDatagrams_ProcessReceiveInterrupt(Buffer: PCANBuffer);
var
  Datagram: PDatagramBuffer;
begin
  Datagram := PDatagramBuffer( nil);
  case Buffer^.ID and MTI_TYPE_MASK of
    MTI_DATAGRAM_ONLY_FRAME :
      begin
        if TryAllocateBuffer(Datagram) then
        begin
          Datagram^.Alias := Buffer^.ID and MASK_SOURCE_ALIAS;
          Datagram^.iByteCount := 0;
          Datagram^.iFrameCount := 0;
          StoreBytes(Datagram, Buffer^);
          Datagram^.iState := DATAGRAM_BUFFER_TRANSFER_COMPLETE;                // Ready for a "Full" Response
        end
      end;
    MTI_DATAGRAM_FRAME_START :
      begin
        if TryAllocateBuffer(Datagram) then
        begin
          Datagram^.Alias := Buffer^.ID and MASK_SOURCE_ALIAS;
          Datagram^.iByteCount := 0;
          Datagram^.iFrameCount := 0;
          Datagram^.iWatchdog := 0;
          StoreBytes(Datagram, Buffer^);
          Datagram^.iState := DATAGRAM_BUFFER_IN_PROCESS;
        end
      end;
    MTI_DATAGRAM_FRAME :
      begin
        if FindMatchingInProcessReceiveDatagram(Buffer^.ID and MASK_SOURCE_ALIAS, Datagram) then
        begin
          UpdateFrameCount(Datagram);
          StoreBytes(Datagram, Buffer^);
        end
      end;
    MTI_DATAGRAM_FRAME_END :
      begin
        if FindMatchingInProcessReceiveDatagram(Buffer^.ID and MASK_SOURCE_ALIAS, Datagram) then
        begin
          UpdateFrameCount(Datagram);
          StoreBytes(Datagram, Buffer^);
          Datagram^.iState := DATAGRAM_BUFFER_TRANSFER_COMPLETE;                // Ready for a "Full" Response
        end else
          AddToBufferOverflowList(Datagram);
      end;
   end;
end;

end.