unit NMRAnetAbbreviatedConfigurationProtocol;

uses
  NMRAnetUtilities,
  CANStorage,
  NMRAnetAppDefines,
  CANDefines,
  NMRAnetDefines,
  NMRAnetAbbreviatedConfigurationProtocolDefines;
  
  
procedure NMRAnetAbbreviatedConfigurationProtocol_Initialize(NodeBuffer: PNMRAnetNodeBuffer);
procedure NMRAnetAbbreviatedConfigurationProtocol_Process(NodeBuffer: PNMRAnetNodeBuffer);
function NMRAnetAbbreviatedConfigurationProtocol_ProcessReceiveFromInterruptContext(NodeBuffer: PNMRAnetNodeBuffer; var ActiveBuffer: PACDI_ReceiveBuffer; SourceAlias: Word; DataBytes: PCAN_DataBytes): Boolean;
function NMRAnetAbbreviatedConfigurationProtocol_QueueTransmit(NodeBuffer: PNMRAnetNodeBuffer; DestAlias: Word): Boolean;
procedure NMRAnetAbbreviatedConfigurationProtocol_ReplyCallback(Callback: PACDI_ReceiveCallbackFunc);
procedure NMRAnetAbbreviatedConfigurationProtocol_1ms_TimeTick(NodeBuffer: PNMRAnetNodeBuffer);

  // defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;

implementation

// *****************************************************************************
//  procedure NMRAnetAbbreviatedConfigurationProtocol_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetAbbreviatedConfigurationProtocol_Initialize(NodeBuffer: PNMRAnetNodeBuffer);
var
  i, j: Integer;
begin
  ACDI_ReceiveCallbackFunc := PACDI_ReceiveCallbackFunc( nil);
  
  NodeBuffer^.ACDI_TransmitBufferList.iActiveBuffer := 0;
  for i := 0 to LEN_ACDI_TRANSMIT_BUFFER_ARRAY - 1 do
  begin
    NodeBuffer^.ACDI_TransmitBufferList.List[i].State := ACDI_BUFFER_STATE_EMPTY;
    NodeBuffer^.ACDI_TransmitBufferList.List[i].iState := STATE_ACDI_TX_START;
    NodeBuffer^.ACDI_TransmitBufferList.List[i].DestAlias := 0;
    NodeBuffer^.ACDI_TransmitBufferList.List[i].SourceAlias := 0;
    NodeBuffer^.ACDI_TransmitBufferList.List[i].iNextChar := 0;
  end;
  
  for i := 0 to LEN_ACDI_RECEIVE_BUFFER_ARRAY - 1 do
  begin
    NodeBuffer^.ACDI_ReceiveBufferList.List[i].State := ACDI_BUFFER_STATE_EMPTY;
    NodeBuffer^.ACDI_ReceiveBufferList.List[i].SourceAlias := 0;
    NodeBuffer^.ACDI_ReceiveBufferList.List[i].iState := ACDI_RECEIVE_MFG_VERSION;
    for j := 0 to ACDI_LEN_MFG-1 do                                             // Not needed just helps with debugging
      NodeBuffer^.ACDI_ReceiveBufferList.List[i].Mfg[j] := $FF;
    for j := 0 to ACDI_LEN_MFG_NAME-1 do
      NodeBuffer^.ACDI_ReceiveBufferList.List[i].MfgName[j] := $FF;
    for j := 0 to ACDI_LEN_MFG_HW_VER-1 do
      NodeBuffer^.ACDI_ReceiveBufferList.List[i].MfgHWVer[j] := $FF;
    for j := 0 to ACDI_LEN_MFG_SW_VER-1 do
      NodeBuffer^.ACDI_ReceiveBufferList.List[i].MfgSWVer[j] := $FF;
    for j := 0 to ACDI_LEN_USER_NAME-1 do
     NodeBuffer^. ACDI_ReceiveBufferList.List[i].UserName[j] := $FF;
    for j := 0 to ACDI_LEN_USER_DESC-1 do
      NodeBuffer^.ACDI_ReceiveBufferList.List[i].UserDesc[j] := $FF;
  end;
end;

procedure NMRAnetAbbreviatedConfigurationProtocol_1ms_TimeTick(NodeBuffer: PNMRAnetNodeBuffer);
var
  i: Integer;
begin
  for i := 0 to LEN_ACDI_RECEIVE_BUFFER_ARRAY - 1 do
  begin
    if NodeBuffer^.ACDI_ReceiveBufferList.List[i].State = ACDI_BUFFER_STATE_PROCESSING then
    begin
      if NodeBuffer^.ACDI_ReceiveBufferList.List[i].iWatchdog <= ACDI_WATCHDOG_MAX then
        Inc(NodeBuffer^.ACDI_ReceiveBufferList.List[i].iWatchdog)
      else
        NodeBuffer^.ACDI_ReceiveBufferList.List[i].State := ACDI_BUFFER_STATE_EMPTY         // The buffer has been abandon reset it
    end
  end;
end;

procedure NMRAnetAbbreviatedConfigurationProtocol_ReplyCallback(Callback: PACDI_ReceiveCallbackFunc);
begin
  ACDI_ReceiveCallbackFunc := Callback
end;

// *****************************************************************************
//  procedure NMRAnetAbbreviatedConfigurationProtocol_QueueTransmit
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetAbbreviatedConfigurationProtocol_QueueTransmit(NodeBuffer: PNMRAnetNodeBuffer; DestAlias: Word): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := 0;
  while i < LEN_ACDI_TRANSMIT_BUFFER_ARRAY do
  begin
    if NodeBuffer^.ACDI_TransmitBufferList.List[i].State = ACDI_BUFFER_STATE_EMPTY then
    begin
      NodeBuffer^.ACDI_TransmitBufferList.List[i].State :=  ACDI_BUFFER_STATE_PROCESSING;
      NodeBuffer^.ACDI_TransmitBufferList.List[i].DestAlias := DestAlias;
      NodeBuffer^.ACDI_TransmitBufferList.List[i].SourceAlias := NodeBuffer^.Node.AliasID;
      Result := True;
      Break
    end;
    Inc(i)
  end;
end;

// *****************************************************************************
//  procedure NullChar
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NullChar(CANBuffer: PCANBuffer; TransmitBuffer: PACDI_TransmitBuffer; NextState: Byte);
begin
  CANBuffer^.DataBytes[CANBuffer^.DataCount] := #0;
  TransmitBuffer^.iNextChar := 0;
  Inc(CANBuffer^.DataCount);
  TransmitBuffer^.iTransferState := NextState;
end;

// *****************************************************************************
//  procedure LoadChars
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure LoadChars(CANBuffer: PCANBuffer; TransmitBuffer: PACDI_TransmitBuffer; Str: ^Char; StringLen: Word; NextState: Byte);
begin
  if TransmitBuffer^.iNextChar < StringLen then
  begin
    CANBuffer^.DataBytes[CANBuffer^.DataCount] := Str^;
    Inc(Str);
    Inc(TransmitBuffer^.iNextChar);
    Inc(CANBuffer^.DataCount);
  end else
    TransmitBuffer^.iTransferState := NextState;
end;

// *****************************************************************************
//  procedure VersionIndicator
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure VersionIndicator(CANBuffer: PCANBuffer; TransmitBuffer: PACDI_TransmitBuffer; NextState: Byte);
begin
  CANBuffer^.DataBytes[CANBuffer^.DataCount] := ACDI_VERSION;
  Inc(CANBuffer^.DataCount);
  TransmitBuffer^.iNextChar := 0;
  TransmitBuffer^.iTransferState := NextState;
end;


// *****************************************************************************
//  procedure NMRAnetAbbreviatedConfigurationProtocol_Process
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetAbbreviatedConfigurationProtocol_Process(NodeBuffer: PNMRAnetNodeBuffer);
var
  ActiveBuffer: PACDI_TransmitBuffer;
  CANBuffer: TCANBuffer;
  LenMfg, LenMfgName, LenMfgHWVer, LenMfgSWVer, LenUserName, LenUserDesc: Word;
begin
  ActiveBuffer := @NodeBuffer^.ACDI_TransmitBufferList.List[NodeBuffer^.ACDI_TransmitBufferList.iActiveBuffer];
  case ActiveBuffer^.iState of
    STATE_ACDI_TX_START :
      begin
        if ActiveBuffer^.State <> ACDI_BUFFER_STATE_EMPTY then
        begin
          ActiveBuffer^.iTransferState := ACDI_TRANSMIT_VERSION_MFG_INFO;
          ActiveBuffer^.iState := STATE_ACDI_TX_PROCESSING_CHARS;
        end;
      end;
    STATE_ACDI_TX_PROCESSING_CHARS :
      begin
        if not CANStorage_ListFull(@TX_NMRAnetBufferList) then                  // Make sure we can send the message before building it
        begin
          CANBuffer.DataCount := 0;
          CANBuffer.DataBytes[CANBuffer.DataCount] := MTI_TYPE_SIMPLENODE_IDENTIFY_INFO_REPLY;
          Inc(CANBuffer.DataCount);
          
          LenMfg      := Length(ABBREVIATED_CDI_MFG);
          LenMfgName  := Length(ABBREVIATED_CDI_MFG_NAME);
          LenMfgHWVer := Length(ABBREVIATED_CDI_MFG_HW_VER);
          LenMfgSWVer := Length(ABBREVIATED_CDI_MFG_SW_VER);
          LenUserName := Length(ABBREVIATED_CDI_USER_NAME);
          LenUserDesc := Length(ABBREVIATED_CDI_USER_DISC);

          while (ActiveBuffer^.iTransferState <> ACDI_TRANSMIT_COMPLETE) and (CANBuffer.DataCount < 8) do
          begin
            case ActiveBuffer^.iTransferState of
              ACDI_TRANSMIT_VERSION_MFG_INFO  : VersionIndicator(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_MFG);
              ACDI_TRANSMIT_MFG               : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_MFG[ActiveBuffer^.iNextChar], LenMfg, ACDI_TRANSMIT_MFG_NULL);
              ACDI_TRANSMIT_MFG_NULL          : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_MFG_NAME);
              ACDI_TRANSMIT_MFG_NAME          : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_MFG_NAME[ActiveBuffer^.iNextChar], LenMfgName, ACDI_TRANSMIT_MFG_NAME_NULL);
              ACDI_TRANSMIT_MFG_NAME_NULL     : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_MFG_HW_VER);
              ACDI_TRANSMIT_MFG_HW_VER        : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_MFG_HW_VER[ActiveBuffer^.iNextChar], LenMfgHWVer, ACDI_TRANSMIT_MFG_HW_NULL);
              ACDI_TRANSMIT_MFG_HW_NULL       : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_MFG_SW_VER);
              ACDI_TRANSMIT_MFG_SW_VER        : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_MFG_SW_VER[ActiveBuffer^.iNextChar], LenMfgSWVer, ACDI_TRANSMIT_MFG_SW_NULL);
              ACDI_TRANSMIT_MFG_SW_NULL       : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_VERSION_USER_INFO);
              ACDI_TRANSMIT_VERSION_USER_INFO : VersionIndicator(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_USER_NAME);
              ACDI_TRANSMIT_USER_NAME         : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_USER_NAME[ActiveBuffer^.iNextChar], LenUserName, ACDI_TRANSMIT_USER_NAME_NULL);
              ACDI_TRANSMIT_USER_NAME_NULL    : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_USER_DESC);
              ACDI_TRANSMIT_USER_DESC         : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_USER_DISC[ActiveBuffer^.iNextChar], LenUserDesc, ACDI_TRANSMIT_USER_DESC_NULL);
              ACDI_TRANSMIT_USER_DESC_NULL    : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_COMPLETE);
            end;
          end;
          
          NMRAnetUtilities_CreateNMRABusMessagePacket(NodeBuffer, @CANBuffer, FT_PROTOCOL_ACDI, ActiveBuffer^.DestAlias, CANBuffer.DataCount, nil);
          CANStorage_AddToList(@TX_NMRAnetBufferList, @CANBuffer);
          StartCANMessageEngine();

          if CANBuffer.DataCount < 8 then
          begin
            ActiveBuffer^.State := ACDI_BUFFER_STATE_EMPTY;
            ActiveBuffer^.iState := STATE_ACDI_TX_START;
          end
        end
      end;
  end;
  
  Inc(NodeBuffer^.ACDI_TransmitBufferList.iActiveBuffer);
  if NodeBuffer^.ACDI_TransmitBufferList.iActiveBuffer >= LEN_ACDI_TRANSMIT_BUFFER_ARRAY then
    NodeBuffer^.ACDI_TransmitBufferList.iActiveBuffer := 0;
end;


// *****************************************************************************
//  procedure NMRAnetAbbreviatedConfigurationProtocol_FindReceiveBuffer
//     Parameters:
//     Returns:
//
//     Description:   WARNING: This statemachine is run in the context of the CAN
//                             Interrupt....
//
// *****************************************************************************
procedure FindReceiveBuffer(NodeBuffer: PNMRAnetNodeBuffer; var ReceiveBuffer: PACDI_ReceiveBuffer; IncommingSourceAlias: Word);
var
  i: Integer;
begin
  ReceiveBuffer := PACDI_ReceiveBuffer(nil);

  for i := 0 to LEN_ACDI_RECEIVE_BUFFER_ARRAY - 1 do                            // Look for an in progress reply for this SourceAlias
  begin
    if NodeBuffer^.ACDI_ReceiveBufferList.List[i].State = ACDI_BUFFER_STATE_PROCESSING then
      if NodeBuffer^.ACDI_ReceiveBufferList.List[i].SourceAlias = IncommingSourceAlias then
      begin
        ReceiveBuffer := @NodeBuffer^.ACDI_ReceiveBufferList.List[i];                       // Leave it alone to continue
        ReceiveBuffer^.iWatchdog := 0;
        Exit
      end;
  end;
  
  if ReceiveBuffer = nil then                                                   // If there is no in progress replies start a fresh one
  begin
    for i := 0 to LEN_ACDI_RECEIVE_BUFFER_ARRAY - 1 do
      if NodeBuffer^.ACDI_ReceiveBufferList.List[i].State = ACDI_BUFFER_STATE_EMPTY then
      begin
        ReceiveBuffer := @NodeBuffer^.ACDI_ReceiveBufferList.List[i];
        ReceiveBuffer^.iState := ACDI_RECEIVE_MFG_VERSION;
        ReceiveBuffer^.State := ACDI_BUFFER_STATE_PROCESSING;
        ReceiveBuffer^.NextChar := @ReceiveBuffer^.Mfg[0];
        ReceiveBuffer^.SourceAlias := IncommingSourceAlias;
        ReceiveBuffer^.iWatchdog := 0;
        Exit
      end
  end;
end;


procedure HandleReceiveVersion(ReceiveBuffer: PACDI_ReceiveBuffer; DataBytes: PCAN_DataBytes; var iByte: Byte; Version: ^Byte; NextState: Byte);
begin
  Version^ := DataBytes^[iByte];
  Inc(iByte);
  ReceiveBuffer^.iState := NextState;
end;


procedure HandleReceiveNextString(ReceiveBuffer: PACDI_ReceiveBuffer; DataBytes: PCAN_DataBytes; var iByte: Byte; NextState: Byte);
begin
  while iByte < 8 do
  begin
    ReceiveBuffer^.NextChar^ := DataBytes^[iByte];
    if DataBytes^[iByte] = #0 then                                              // use the null in our string
    begin
      case ReceiveBuffer^.iState of
        ACDI_RECEIVE_MFG         : ReceiveBuffer^.NextChar := @ReceiveBuffer^.MfgName[0];
        ACDI_RECEIVE_MFG_NAME    : ReceiveBuffer^.NextChar := @ReceiveBuffer^.MfgHWVer[0];
        ACDI_RECEIVE_MFG_HW_VER  : ReceiveBuffer^.NextChar := @ReceiveBuffer^.MfgSWVer[0];
        ACDI_RECEIVE_MFG_SW_VER  : ReceiveBuffer^.NextChar := @ReceiveBuffer^.UserName[0];
        ACDI_RECEIVE_USER_NAME   : ReceiveBuffer^.NextChar := @ReceiveBuffer^.UserDesc[0];
      end;
      Inc(iByte);
      ReceiveBuffer^.iState := NextState;
      Exit
    end else
    begin
      Inc(ReceiveBuffer^.NextChar);                                             // Not to the end of the string yet
      Inc(iByte);
    end
  end
end;

// *****************************************************************************
//  procedure NMRAnetAbbreviatedConfigurationProtocol_ProcessReceiveInterruptContext
//     Parameters:
//     Returns:
//
//     Description:   WARNING: This statemachine is run in the context of the CAN
//                             Interrupt....
//
// *****************************************************************************
function NMRAnetAbbreviatedConfigurationProtocol_ProcessReceiveFromInterruptContext(NodeBuffer: PNMRAnetNodeBuffer; var ActiveBuffer: PACDI_ReceiveBuffer; IncommingSourceAlias: Word; DataBytes: PCAN_DataBytes): Boolean;
var
  iByte: Byte;
begin
  Result := False;
  iByte := 1;                                                                   // Always skip over the first MTI Type byte

  FindReceiveBuffer(NodeBuffer, ActiveBuffer, IncommingSourceAlias);
  if ActiveBuffer <> nil then
  begin
    ActiveBuffer^.iWatchdog := 0;
    while ((iByte < 8) and (ActiveBuffer^.iState < ACDI_RECEIVE_COMPLETE)) do
    begin
      case ActiveBuffer^.iState of
        ACDI_RECEIVE_MFG_VERSION  : begin HandleReceiveVersion(ActiveBuffer, DataBytes, iByte, @ActiveBuffer^.MfgVersion, ACDI_RECEIVE_MFG); end;
        ACDI_RECEIVE_MFG          : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_MFG_NAME); end;
        ACDI_RECEIVE_MFG_NAME     : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_MFG_HW_VER); end;
        ACDI_RECEIVE_MFG_HW_VER   : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_MFG_SW_VER);  end;
        ACDI_RECEIVE_MFG_SW_VER   : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_USER_VERSION); end;
        ACDI_RECEIVE_USER_VERSION : begin HandleReceiveVersion(ActiveBuffer, DataBytes, iByte, @ActiveBuffer^.UserVersion, ACDI_RECEIVE_USER_NAME); end;
        ACDI_RECEIVE_USER_NAME    : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_USER_DESC); end;
        ACDI_RECEIVE_USER_DESC    : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_COMPLETE); end;
        ACDI_RECEIVE_COMPLETE     : begin end;
      end;
    end;
    Result := ActiveBuffer^.iState = ACDI_RECEIVE_COMPLETE;
  end;
end;


end.