unit NMRAnetAbbreviatedConfigurationProtocol;

uses
  NMRAnetUtilities,
  CANStorage,
  NMRAnetAppDefines,
  CANDefines,
  NMRAnetDefines,
  NMRAnetAbbreviatedConfigurationProtocolDefines;
  
  
procedure NMRAnetAbbreviatedConfigurationProtocol_Initialize;
procedure NMRAnetAbbreviatedConfigurationProtocol_Process(NodeBuffer: PNMRAnetNodeBuffer);
function NMRAnetAbbreviatedConfigurationProtocol_ProcessReceiveFromInterruptContext(NodeBuffer: PNMRAnetNodeBuffer; var ActiveBuffer: PACDI_ReceiveBuffer; SourceAlias: Word; DataBytes: PCAN_DataBytes): Boolean;
function NMRAnetAbbreviatedConfigurationProtocol_QueueTransmit(NodeBuffer: PNMRAnetNodeBuffer; DestAlias: Word): Boolean;
procedure NMRAnetAbbreviatedConfigurationProtocol_ReplyCallback(Callback: PACDI_ReceiveCallbackFunc);
procedure NMRAnetAbbreviatedConfigurationProtocol_1ms_TimeTick(NodeBuffer: PNMRAnetNodeBuffer);
procedure NMRAnetAbbreviatedConfigurationProtocol_InitializeReceiveBuffer(ReceiveBuffer: PACDI_ReceiveBuffer);
procedure NMRAnetAbbreviatedConfigurationProtocol_InitializeTransmitBuffer(TransmitBuffer: PACDI_TransmitBuffer);

  // defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;

implementation

procedure NMRAnetAbbreviatedConfigurationProtocol_InitializeReceiveBuffer(ReceiveBuffer: PACDI_ReceiveBuffer);
var
  j: Integer;
begin
  if ReceiveBuffer <> nil then
  begin
    ReceiveBuffer^.State := ACDI_BUFFER_STATE_EMPTY;
    ReceiveBuffer^.SourceAlias := 0;
    ReceiveBuffer^.iState := ACDI_RECEIVE_MFG_VERSION;
    for j := 0 to ACDI_LEN_MFG-1 do                                             // Not needed just helps with debugging
      ReceiveBuffer^.Mfg[j] := $FF;
    for j := 0 to ACDI_LEN_MFG_NAME-1 do
      ReceiveBuffer^.MfgName[j] := $FF;
    for j := 0 to ACDI_LEN_MFG_HW_VER-1 do
      ReceiveBuffer^.MfgHWVer[j] := $FF;
    for j := 0 to ACDI_LEN_MFG_SW_VER-1 do
      ReceiveBuffer^.MfgSWVer[j] := $FF;
    for j := 0 to ACDI_LEN_USER_NAME-1 do
     ReceiveBuffer^.UserName[j] := $FF;
    for j := 0 to ACDI_LEN_USER_DESC-1 do
      ReceiveBuffer^.UserDesc[j] := $FF;
  end
end;

procedure NMRAnetAbbreviatedConfigurationProtocol_InitializeTransmitBuffer(TransmitBuffer: PACDI_TransmitBuffer);
begin
  if TransmitBuffer <> nil then
  begin
    TransmitBuffer^.State := ACDI_BUFFER_STATE_EMPTY;
    TransmitBuffer^.iState := STATE_ACDI_TX_START;
    TransmitBuffer^.DestAlias := 0;
    TransmitBuffer^.SourceAlias := 0;
    TransmitBuffer^.iNextChar := 0;
  end
end;

// *****************************************************************************
//  procedure NMRAnetAbbreviatedConfigurationProtocol_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetAbbreviatedConfigurationProtocol_Initialize;

begin
  ACDI_ReceiveCallbackFunc := PACDI_ReceiveCallbackFunc( nil);
end;


procedure NMRAnetAbbreviatedConfigurationProtocol_1ms_TimeTick(NodeBuffer: PNMRAnetNodeBuffer);
begin
  if NodeBuffer^.ACDI_ReceiveBuffer <> nil then
  begin
    if NodeBuffer^.ACDI_ReceiveBuffer^.State = ACDI_BUFFER_STATE_PROCESSING then
    begin
      if NodeBuffer^.ACDI_ReceiveBuffer^.iWatchdog <= ACDI_WATCHDOG_MAX then
        Inc(NodeBuffer^.ACDI_ReceiveBuffer^.iWatchdog)
      else
        NodeBuffer^.ACDI_ReceiveBuffer^.State := ACDI_BUFFER_STATE_EMPTY         // The buffer has been abandon reset it
    end                                                                         // TODO THIS WILL BE RECURSIVE INTO THE LINKED LIST!!!@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  end
end;

procedure NMRAnetAbbreviatedConfigurationProtocol_ReplyCallback(Callback: PACDI_ReceiveCallbackFunc);
begin
  ACDI_ReceiveCallbackFunc := Callback
end;

// *****************************************************************************
//  procedure NMRAnetAbbreviatedConfigurationProtocol_QueueTransmit
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetAbbreviatedConfigurationProtocol_QueueTransmit(NodeBuffer: PNMRAnetNodeBuffer; DestAlias: Word): Boolean;
begin
  Result := False;
  if NodeBuffer^.ACDI_TransmitBuffer <> nil then
  begin
    if NodeBuffer^.ACDI_TransmitBuffer^.State = ACDI_BUFFER_STATE_EMPTY then
    begin
      NodeBuffer^.ACDI_TransmitBuffer^.State :=  ACDI_BUFFER_STATE_PROCESSING;
      NodeBuffer^.ACDI_TransmitBuffer^.DestAlias := DestAlias;
      NodeBuffer^.ACDI_TransmitBuffer^.SourceAlias := NodeBuffer^.Node.AliasID;
      Result := True;
    end
  end
end;

// *****************************************************************************
//  procedure NullChar
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NullChar(CANBuffer: PCANBuffer; TransmitBuffer: PACDI_TransmitBuffer; NextState: Byte);
begin
  CANBuffer^.DataBytes[CANBuffer^.DataCount] := #0;
  TransmitBuffer^.iNextChar := 0;
  Inc(CANBuffer^.DataCount);
  TransmitBuffer^.iTransferState := NextState;
end;

// *****************************************************************************
//  procedure LoadChars
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure LoadChars(CANBuffer: PCANBuffer; TransmitBuffer: PACDI_TransmitBuffer; Str: ^Char; StringLen: Word; NextState: Byte);
begin
  if TransmitBuffer^.iNextChar < StringLen then
  begin
    CANBuffer^.DataBytes[CANBuffer^.DataCount] := Str^;
    Inc(Str);
    Inc(TransmitBuffer^.iNextChar);
    Inc(CANBuffer^.DataCount);
  end else
    TransmitBuffer^.iTransferState := NextState;
end;

// *****************************************************************************
//  procedure VersionIndicator
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure VersionIndicator(CANBuffer: PCANBuffer; TransmitBuffer: PACDI_TransmitBuffer; NextState: Byte);
begin
  CANBuffer^.DataBytes[CANBuffer^.DataCount] := ACDI_VERSION;
  Inc(CANBuffer^.DataCount);
  TransmitBuffer^.iNextChar := 0;
  TransmitBuffer^.iTransferState := NextState;
end;


// *****************************************************************************
//  procedure NMRAnetAbbreviatedConfigurationProtocol_Process
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetAbbreviatedConfigurationProtocol_Process(NodeBuffer: PNMRAnetNodeBuffer);
var
  ActiveBuffer: PACDI_TransmitBuffer;
  CANBuffer: TCANBuffer;
  LenMfg, LenMfgName, LenMfgHWVer, LenMfgSWVer, LenUserName, LenUserDesc: Word;
begin
  if NodeBuffer^.ACDI_TransmitBuffer <> nil then
  begin
    ActiveBuffer := NodeBuffer^.ACDI_TransmitBuffer;
    case ActiveBuffer^.iState of
      STATE_ACDI_TX_START :
        begin
          if ActiveBuffer^.State <> ACDI_BUFFER_STATE_EMPTY then
          begin
            ActiveBuffer^.iTransferState := ACDI_TRANSMIT_VERSION_MFG_INFO;
            ActiveBuffer^.iState := STATE_ACDI_TX_PROCESSING_CHARS;
          end;
        end;
      STATE_ACDI_TX_PROCESSING_CHARS :
        begin
          if not CANStorage_ListFull(@TX_NMRAnetBufferList) then                  // Make sure we can send the message before building it
          begin
            CANBuffer.DataCount := 0;
            CANBuffer.DataBytes[CANBuffer.DataCount] := MTI_TYPE_SIMPLENODE_IDENTIFY_INFO_REPLY;
            Inc(CANBuffer.DataCount);

            LenMfg      := Length(ABBREVIATED_CDI_MFG);
            LenMfgName  := Length(ABBREVIATED_CDI_MFG_NAME);
            LenMfgHWVer := Length(ABBREVIATED_CDI_MFG_HW_VER);
            LenMfgSWVer := Length(ABBREVIATED_CDI_MFG_SW_VER);
            LenUserName := Length(ABBREVIATED_CDI_USER_NAME);
            LenUserDesc := Length(ABBREVIATED_CDI_USER_DISC);

            while (ActiveBuffer^.iTransferState <> ACDI_TRANSMIT_COMPLETE) and (CANBuffer.DataCount < 8) do
            begin
              case ActiveBuffer^.iTransferState of
                ACDI_TRANSMIT_VERSION_MFG_INFO  : VersionIndicator(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_MFG);
                ACDI_TRANSMIT_MFG               : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_MFG[ActiveBuffer^.iNextChar], LenMfg, ACDI_TRANSMIT_MFG_NULL);
                ACDI_TRANSMIT_MFG_NULL          : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_MFG_NAME);
                ACDI_TRANSMIT_MFG_NAME          : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_MFG_NAME[ActiveBuffer^.iNextChar], LenMfgName, ACDI_TRANSMIT_MFG_NAME_NULL);
                ACDI_TRANSMIT_MFG_NAME_NULL     : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_MFG_HW_VER);
                ACDI_TRANSMIT_MFG_HW_VER        : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_MFG_HW_VER[ActiveBuffer^.iNextChar], LenMfgHWVer, ACDI_TRANSMIT_MFG_HW_NULL);
                ACDI_TRANSMIT_MFG_HW_NULL       : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_MFG_SW_VER);
                ACDI_TRANSMIT_MFG_SW_VER        : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_MFG_SW_VER[ActiveBuffer^.iNextChar], LenMfgSWVer, ACDI_TRANSMIT_MFG_SW_NULL);
                ACDI_TRANSMIT_MFG_SW_NULL       : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_VERSION_USER_INFO);
                ACDI_TRANSMIT_VERSION_USER_INFO : VersionIndicator(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_USER_NAME);
                ACDI_TRANSMIT_USER_NAME         : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_USER_NAME[ActiveBuffer^.iNextChar], LenUserName, ACDI_TRANSMIT_USER_NAME_NULL);
                ACDI_TRANSMIT_USER_NAME_NULL    : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_USER_DESC);
                ACDI_TRANSMIT_USER_DESC         : LoadChars(@CANBuffer, ActiveBuffer, @ABBREVIATED_CDI_USER_DISC[ActiveBuffer^.iNextChar], LenUserDesc, ACDI_TRANSMIT_USER_DESC_NULL);
                ACDI_TRANSMIT_USER_DESC_NULL    : NullChar(@CANBuffer, ActiveBuffer, ACDI_TRANSMIT_COMPLETE);
              end;
            end;

            NMRAnetUtilities_CreateNMRABusMessagePacket(NodeBuffer, @CANBuffer, FT_PROTOCOL_ACDI, ActiveBuffer^.DestAlias, CANBuffer.DataCount, nil);
            CANStorage_AddToList(@TX_NMRAnetBufferList, @CANBuffer);
            StartCANMessageEngine();

            if CANBuffer.DataCount < 8 then
            begin
              ActiveBuffer^.State := ACDI_BUFFER_STATE_EMPTY;
              ActiveBuffer^.iState := STATE_ACDI_TX_START;
            end
          end
        end;
    end;                           // TODO THIS WILL BE RECURSIVE INTO THE LINKED LIST!!!@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  end
end;


// *****************************************************************************
//  procedure NMRAnetAbbreviatedConfigurationProtocol_FindReceiveBuffer
//     Parameters:
//     Returns:
//
//     Description:   WARNING: This statemachine is run in the context of the CAN
//                             Interrupt....
//
// *****************************************************************************
procedure FindReceiveBuffer(NodeBuffer: PNMRAnetNodeBuffer; var ReceiveBuffer: PACDI_ReceiveBuffer; IncommingSourceAlias: Word);
begin
  ReceiveBuffer := PACDI_ReceiveBuffer(nil);
  
  if NodeBuffer^.ACDI_ReceiveBuffer <> nil then
  begin
    if NodeBuffer^.ACDI_ReceiveBuffer^.State = ACDI_BUFFER_STATE_PROCESSING then
    begin
      if NodeBuffer^.ACDI_ReceiveBuffer^.SourceAlias = IncommingSourceAlias then
      begin
        ReceiveBuffer := NodeBuffer^.ACDI_ReceiveBuffer;                        // Leave it alone to continue
        ReceiveBuffer^.iWatchdog := 0;
      end;
    end;

    if ReceiveBuffer = nil then                                                   // If there is no in progress replies start a fresh one
    begin
      if NodeBuffer^.ACDI_ReceiveBuffer^.State = ACDI_BUFFER_STATE_EMPTY then
      begin
        ReceiveBuffer := NodeBuffer^.ACDI_ReceiveBuffer;
        ReceiveBuffer^.iState := ACDI_RECEIVE_MFG_VERSION;
        ReceiveBuffer^.State := ACDI_BUFFER_STATE_PROCESSING;
        ReceiveBuffer^.NextChar := @ReceiveBuffer^.Mfg[0];
        ReceiveBuffer^.SourceAlias := IncommingSourceAlias;
        ReceiveBuffer^.iWatchdog := 0;
      end
    end;                                                     // TODO THIS WILL BE RECURSIVE INTO THE LINKED LIST!!!@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  end
end;


procedure HandleReceiveVersion(ReceiveBuffer: PACDI_ReceiveBuffer; DataBytes: PCAN_DataBytes; var iByte: Byte; Version: ^Byte; NextState: Byte);
begin
  Version^ := DataBytes^[iByte];
  Inc(iByte);
  ReceiveBuffer^.iState := NextState;
end;


procedure HandleReceiveNextString(ReceiveBuffer: PACDI_ReceiveBuffer; DataBytes: PCAN_DataBytes; var iByte: Byte; NextState: Byte);
begin
  while iByte < 8 do
  begin
    ReceiveBuffer^.NextChar^ := DataBytes^[iByte];
    if DataBytes^[iByte] = #0 then                                              // use the null in our string
    begin
      case ReceiveBuffer^.iState of
        ACDI_RECEIVE_MFG         : ReceiveBuffer^.NextChar := @ReceiveBuffer^.MfgName[0];
        ACDI_RECEIVE_MFG_NAME    : ReceiveBuffer^.NextChar := @ReceiveBuffer^.MfgHWVer[0];
        ACDI_RECEIVE_MFG_HW_VER  : ReceiveBuffer^.NextChar := @ReceiveBuffer^.MfgSWVer[0];
        ACDI_RECEIVE_MFG_SW_VER  : ReceiveBuffer^.NextChar := @ReceiveBuffer^.UserName[0];
        ACDI_RECEIVE_USER_NAME   : ReceiveBuffer^.NextChar := @ReceiveBuffer^.UserDesc[0];
      end;
      Inc(iByte);
      ReceiveBuffer^.iState := NextState;
      Exit
    end else
    begin
      Inc(ReceiveBuffer^.NextChar);                                             // Not to the end of the string yet
      Inc(iByte);
    end
  end
end;

// *****************************************************************************
//  procedure NMRAnetAbbreviatedConfigurationProtocol_ProcessReceiveInterruptContext
//     Parameters:
//     Returns:
//
//     Description:   WARNING: This statemachine is run in the context of the CAN
//                             Interrupt....
//
// *****************************************************************************
function NMRAnetAbbreviatedConfigurationProtocol_ProcessReceiveFromInterruptContext(NodeBuffer: PNMRAnetNodeBuffer; var ActiveBuffer: PACDI_ReceiveBuffer; IncommingSourceAlias: Word; DataBytes: PCAN_DataBytes): Boolean;
var
  iByte: Byte;
begin
  Result := False;
  iByte := 1;                                                                   // Always skip over the first MTI Type byte

  FindReceiveBuffer(NodeBuffer, ActiveBuffer, IncommingSourceAlias);
  if ActiveBuffer <> nil then
  begin
    ActiveBuffer^.iWatchdog := 0;
    while ((iByte < 8) and (ActiveBuffer^.iState < ACDI_RECEIVE_COMPLETE)) do
    begin
      case ActiveBuffer^.iState of
        ACDI_RECEIVE_MFG_VERSION  : begin HandleReceiveVersion(ActiveBuffer, DataBytes, iByte, @ActiveBuffer^.MfgVersion, ACDI_RECEIVE_MFG); end;
        ACDI_RECEIVE_MFG          : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_MFG_NAME); end;
        ACDI_RECEIVE_MFG_NAME     : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_MFG_HW_VER); end;
        ACDI_RECEIVE_MFG_HW_VER   : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_MFG_SW_VER);  end;
        ACDI_RECEIVE_MFG_SW_VER   : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_USER_VERSION); end;
        ACDI_RECEIVE_USER_VERSION : begin HandleReceiveVersion(ActiveBuffer, DataBytes, iByte, @ActiveBuffer^.UserVersion, ACDI_RECEIVE_USER_NAME); end;
        ACDI_RECEIVE_USER_NAME    : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_USER_DESC); end;
        ACDI_RECEIVE_USER_DESC    : begin HandleReceiveNextString(ActiveBuffer, DataBytes, iByte, ACDI_RECEIVE_COMPLETE); end;
        ACDI_RECEIVE_COMPLETE     : begin end;
      end;
    end;
    Result := ActiveBuffer^.iState = ACDI_RECEIVE_COMPLETE;
  end;
end;


end.