unit NMRAnetStateMachine;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRAnet StateMachine for the main loop in a program.
//
// ******************************************************************************

uses
  NMRAnetEventDefines,
  NMRAnetAppDefines,
  NMRAnetDefines,
  NMRAnetUtilities,
  NMRAnetCANReceive,
  CANStorage,
  CANDefines,
  NMRAnetDatagrams,
  NMRAnetDatagramDefines,
  NMRAnetConfigurationProtocol,
  NMRAnetConfigurationProtocolDefines,
  NMRAnetAbbreviatedConfigurationProtocol,
  NMRAnetAbbreviatedConfigurationProtocolDefines;

{$I Options.inc}


  procedure NMRAnetStateMachine_Process(NodeBuffer: PNMRAnetNode);
  procedure NMRAnetStateMachine_Disconnect(NodeBuffer: PNMRAnetNode);
  procedure NMRAnetStateMachine_Initialize(NodeBuffer: PNMRAnetNode);
  procedure NMRAnetStateMachine_1ms_Timer(NodeBuffer: PNMRAnetNode);
  
  // Receive Callback Helper Functions.  This could be done with separate callbacks for different message
  // types but that would require callback function variables that could get expensive in memory allocation so
  // here just look at the Response nCode and the CRC_xxx constants to decode what message was received for complex
  // and the SRC_xxx constants for the Simple callback
  procedure NMRAnetStateMachine_SetSimpleCallbackFunc(CallBack: PSimpleActionCallbackFunc);
  procedure NMRAnetStateMachine_SetComplexCallbackFunc(CallBack: PComplexActionCallbackFunc);
  
  // Send Helper Functions
  function NMRAnetStateMachine_TrySendIdentifyProducer(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; EventID: PEventID): Boolean;
  function NMRAnetStateMachine_TrySendIdentifyConsumer(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; EventID: PEventID): Boolean;
  function NMRAnetStateMachine_TrySendIdentifyEvents(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer): Boolean;
  function NMRAnetStateMachine_TrySendAliasMapEnquiry(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer): Boolean;
  function NMRAnetStateMachine_TrySendVerifyNodeID(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; DestinationAliasID: Word): Boolean;
  function NMRAnetStateMachine_TrySendAbbreviatedCDI(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; DestinationAliasID: Word): Boolean;
  
  // Exported Functions
  function TryTransmitNMRABusLayerMsg(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes): Boolean;

  // defined in the user program
  procedure GetUniqueIDFunc(var HiID, LoID: DWord); external;
  
  // defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure LockCANInterrupt; external;
  procedure UnLockCANInterrupt; external;
  
var
  TX_CANBufferList: TCANBufferList; external;
  TX_NMRAnetBufferList: TCANBufferList; external;

implementation

function NMRAnetStateMachine_TrySendAbbreviatedCDI(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; DestinationAliasID: Word): Boolean;
var
//  BrokenBuffer: TCANBUffer;   BUG IN VERSION 5.60 with this
  DataBytes: TCAN_DataBytes;
begin
  DataBytes[0] := MTI_TYPE_SIMPLENODE_IDENTIFY_INFO_REQUEST;
  Result := TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, FT_PRODUCER_IDENDIFY, DestinationAliasID, 1, @DataBytes);
end;

function NMRAnetStateMachine_TrySendIdentifyProducer(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; EventID: PEventID): Boolean;
//var
//  BrokenBuffer: TCANBUffer;   BUG IN VERSION 5.60 with this
begin
  Result := TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, FT_PRODUCER_IDENDIFY, 0, EVENT_ARRAY_LENGTH, PCAN_DataBytes( EventID));
end;

function NMRAnetStateMachine_TrySendIdentifyConsumer(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; EventID: PEventID): Boolean;
//var
//  Buffer: TCANBUffer;   BUG IN VERSION 5.60 with this
begin
  Result := TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, FT_CONSUMER_IDENTIFY, 0, EVENT_ARRAY_LENGTH,  PCAN_DataBytes( EventID));
end;

function NMRAnetStateMachine_TrySendIdentifyEvents(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer): Boolean;
//var
//  Buffer: TCANBUffer;   BUG IN VERSION 5.60 with this
begin
  Result := TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, FT_EVENTS_IDENTIFY, 0, 0, nil);
end;

function NMRAnetStateMachine_TrySendAliasMapEnquiry(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer): Boolean;
begin
  Result := TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, FT_AME, 0, 0, nil);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_TrySendVerifyNodeID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetStateMachine_TrySendVerifyNodeID(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; DestinationAliasID: Word): Boolean;
var
  DataBytes: TCAN_DataBytes;
begin
  if DestinationAliasID <> 0 then
  begin
    DataBytes[0] := MTI_TYPE_VERIFY_NODE_ID_NUMBER_DEST;
    Result := TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, FT_VERIFY_NODE_ID_NUMBER_DEST, DestinationAliasID, 1, @DataBytes);
  end else
    Result := TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, FT_VERIFY_NODE_ID_NUMBER, 0, 0, nil);
end;

// *****************************************************************************
//  procedure FlushActionList
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure ReleaseActions(NodeBuffer: PNMRAnetNode);
begin
  if NodeBuffer^.Actions <> nil then
  begin
    NodeBuffer^.Actions^.State := QAS_EMPTY;
    NodeBuffer^.Actions := PQueuedActions( nil);
  end
end;

// *****************************************************************************
//  procedure FlushLists
//     Parameters:
//     Returns:
//
//     Description: Clears the lists
//
// *****************************************************************************
procedure FlushLists;
begin
  CANStorage_FlushList(@TX_CANBufferList);                                      // Flush any pending packets
  CANStorage_FlushList(@TX_NMRAnetBufferList);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the BufferArray
//              LasterBuffer   : Pointer to the last item in the BufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure NMRAnetStateMachine_InitializeList(ListPtr: PCANBufferList; BufferArrayPtr: PCANBufferArray; ListLength: Byte);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.Size := ListLength;
  ListPtr^.Head := @BufferArrayPtr^[0];
  ListPtr^.Tail := @BufferArrayPtr^[0];
  ListPtr^.Count := 0;
  ListPtr^.MaxCount := 0;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_SetSimpleCallbackFunc(CallBack: PSimpleActionCallbackFunc);
begin
  SimpleActionCallbackFunc := Callback;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_SetComplexCallbackFunc(CallBack: PComplexActionCallbackFunc);
begin
  ComplexActionCallbackFunc := Callback;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_Initialize(NodeBuffer: PNMRAnetNode);
begin
  NodeBuffer^.DatagramReceive := PDatagramBuffer(nil);
  NodeBuffer^.DatagramTransmit := PDatagramBuffer(nil);
  NodeBuffer^.ACDI_TransmitBuffer := PACDI_TransmitBuffer(nil);
  NodeBuffer^.ACDI_ReceiveBuffer := PACDI_ReceiveBuffer(nil);
  NodeBuffer^.Actions := PQueuedActions(nil);
  NMRAnetDatagrams_Initialize(NodeBuffer);
  NMRAnetCANReceive_Initialize;
  NMRAnetConfigurationProtocol_Initialize(NodeBuffer);
  NMRAnetAbbreviatedConfigurationProtocol_Initialize(NodeBuffer);
  SimpleActionCallbackFunc := PSimpleActionCallbackFunc( nil);
  ComplexActionCallbackFunc := PComplexActionCallbackFunc( nil);
  NodeBuffer^.State := 0;
  GetUniqueIDFunc(NodeBuffer^.Node.ID[1], NodeBuffer^.Node.ID[0]);
  NodeBuffer^.Node.Seed[0] := NodeBuffer^.Node.ID[0];
  NodeBuffer^.Node.Seed[1] := NodeBuffer^.Node.ID[1];
  NodeBuffer^.iStateMachine := STATE_NMRABUS_START;
  NMRAnetStateMachine_InitializeList(@TX_CANBufferList, @TX_CANBuffer, TX_CAN_BUFFER_LEN);
  NMRAnetStateMachine_InitializeList(@TX_NMRAnetBufferList, @TX_NMRAnet_Buffer, TX_NMRANET_BUFFER_LEN);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_1ms_Timer;
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_1ms_Timer(NodeBuffer: PNMRAnetNode);
begin
  Inc(NodeBuffer^.LoginTimeCount);
  NMRAnetDatagrams_1ms_TimeTick(Nodebuffer);
  NMRAnetAbbreviatedConfigurationProtocol_1ms_TimeTick(NodeBuffer);
end;

// *****************************************************************************
//  function TestReceivedMsgFlags
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function TestReceivedMsgFlags(NodeBuffer: PNMRAnetNode; Flag: Word): Boolean;
begin
  if NodeBuffer^.Actions <> nil then
    Result := NodeBuffer^.Actions^.SimpleActionFlags and Flag <> 0
  else
    Result := False
end;

// *****************************************************************************
//  function ClearReceivedMsgFlags
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure ClearReceivedMsgFlags(NodeBuffer: PNMRAnetNode; Flag: Word);
begin
  LockCANInterrupt;
  if NodeBuffer^.Actions <> nil then
    NodeBuffer^.Actions^.SimpleActionFlags := NodeBuffer^.Actions^.SimpleActionFlags and not Flag;
  UnLockCANInterrupt;
end;

// *****************************************************************************
//  function DuplicateDetected
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function DuplicateDetected(NodeBuffer: PNMRAnetNode; Flag: Word; NextState: Byte): Boolean;
begin
  Result := False;
  if TestReceivedMsgFlags(NodeBuffer, Flag) then
  begin
    ClearReceivedMsgFlags(NodeBuffer, Flag);
    NodeBuffer^.iStateMachine := NextState;
    Result := True
  end
end;


// *****************************************************************************
//  procedure TryTransmitCANLayerMsg
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function TryTransmitCANLayerMsg(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; ): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_CANBufferList) then
  begin
    NMRAnetUtilities_CreateCANControlFramePacket(NodeBuffer, Buffer, VariableField);
    if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True
    end
  end ;
end;

// *****************************************************************************
//  procedure TryTransmitNMRABusLayerMsg
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function TryTransmitNMRABusLayerMsg(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    NMRAnetUtilities_CreateNMRABusMessagePacket(NodeBuffer, Buffer, VariableField, DestinationAlias, DataCount, DataBytes);
    if CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True;
    end
  end
end;

// *****************************************************************************
//  function NextComplexAction
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function FindStoredComplexAction(NodeBuffer: PNMRAnetNode; nCode: Word): PQueuedAction;
var
  i: Word;
begin
  i := 0;
  Result := nil;
  if NodeBuffer^.Actions <> nil then
  begin
    while i < LEN_QUEUED_Action_LIST do
    begin
      if NodeBuffer^.Actions^.List[i].nCode = nCode then
      begin
        Result := @NodeBuffer^.Actions^.List[i];
        Exit
      end;
      Inc(i);
    end;
  end
end;

// *****************************************************************************
//  procedure HandleOptionalInteraction
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure HandleOptionalInteraction(Action: PQueuedAction);
begin
end;

// *****************************************************************************
//  procedure SendCANLayerSimpleAction
//
//     Parameters:  Buffer - Buffer to load to send
//                  VariableField - MIT Coding for the Message to Send
//                  Flag - Flag to test for to decide if the Action is needed
//                  NextState - next state in the statemachine once the Action is handled
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure SendCANLayerSimpleAction(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; Flag: Word; NextState: Byte);
begin
  if NodeBuffer^.Actions <> nil then
  begin
    if TestReceivedMsgFlags(NodeBuffer, Flag) then
      if TryTransmitCANLayerMsg(NodeBuffer, Buffer, VariableField) then
        ClearReceivedMsgFlags(NodeBuffer, Flag);
    NodeBuffer^.Actions^.iState := NextState
  end
end;

// *****************************************************************************
//  procedure SendNMRAnetLayerSimpleAction
//
//     Parameters:  Buffer - Buffer to load to send
//                  VariableField - MIT Coding for the Message to Send
//                  Flag - Flag to test for to decide if the Action is needed
//                  NextState - next state in the statemachine once the Action is handled
//
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure SendNMRAnetLayerSimpleAction(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; Flag: Word; NextState: Byte);
begin
  if NodeBuffer^.Actions <> nil then
  begin
    if TestReceivedMsgFlags(NodeBuffer, Flag) then
      if TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, VariableField, 0, 0, nil) then
      begin
        if SimpleActionCallbackFunc <> nil then
          SimpleActionCallbackFunc(NodeBuffer, Flag);
        ClearReceivedMsgFlags(NodeBuffer, Flag);
      end;
    NodeBuffer^.Actions^.iState := NextState
  end
end;

// *****************************************************************************
//  procedure SendNMRALayerSimpleSendAllConsumerProducer
//
//     Parameters:  Buffer - Buffer to load to send
//                  VariableField - MIT Coding for the Message to Send
//                  nCode - The type of Action needed to test for to decide if the Action is needed
//                  NextState - next state in the statemachine once the Action is handled
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure SendNMRALayerSimpleSendAllConsumerProducer(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; NextState: Byte);
begin
  if NodeBuffer^.Actions <> nil then
  begin
    if TestReceivedMsgFlags(NodeBuffer, SRC_SEND_ALL_CONSUMER_PRODUCER_IDENTIFIED) then
    begin
      {$IFDEF SUPPORT_AT_LEAST_ONE_PRODUCED_EVENT}
      if NodeBuffer^.Actions^.Tag < MAX_SUPPORTED_EVENTS_PRODUCED then
      begin
        if TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, FT_PRODUCER_IDENTIFIED, 0, 8, @SUPPORTED_EVENTS_PRODUCED[NodeBuffer^.Actions^.Tag]) then
          Inc(NodeBuffer^.Actions^.Tag);
      end else
      {$ENDIF}
      {$IFDEF SUPPORT_AT_LEAST_ONE_CONSUMED_EVENT}
      if NodeBuffer^.Actions^.Tag < MAX_SUPPORTED_EVENTS then
      begin
        if TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, FT_CONSUMER_IDENTIFIED, 0, 8, @SUPPORTED_EVENTS_CONSUMED[NodeBuffer^.Actions^.Tag-MAX_SUPPORTED_EVENTS_PRODUCED]) then
          Inc(NodeBuffer^.Actions^.Tag);
      end else
      {$ENDIF}
      begin
        if SimpleActionCallbackFunc <> nil then
          SimpleActionCallbackFunc(NodeBuffer, SRC_SEND_ALL_CONSUMER_PRODUCER_IDENTIFIED);
        ClearReceivedMsgFlags(NodeBuffer, SRC_SEND_ALL_CONSUMER_PRODUCER_IDENTIFIED);              // Done
        NodeBuffer^.Actions^.iState := NextState
      end
    end else
      NodeBuffer^.Actions^.iState := NextState                                       // Can't skip over this one until done with all sending
  end
end;

// *****************************************************************************
//  procedure SendNMRAnetLayerComplexAction
//
//     Parameters:  Buffer - Buffer to load to send
//                  VariableField - MIT Coding for the Message to Send
//                  nCode - The type of Action needed to test for to decide if the Action is needed
//                  NextState - next state in the statemachine once the Action is handled
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure SendNMRAnetLayerComplexAction(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; IsAddressed: Boolean; nCode: Word; NextState: Byte);
var
  Action: PQueuedAction;
  TargetAlias: Word;
begin
  if NodeBuffer^.Actions <> nil then
  begin
    Action := FindStoredComplexAction(NodeBuffer, nCode);
    if Action <> nil then
    begin
      if IsAddressed then
        TargetAlias := Action^.FromAlias
      else
        TargetAlias := 0;
      if TryTransmitNMRABusLayerMsg(NodeBuffer, Buffer, VariableField, TargetAlias, Action^.DataCount, @Action^.DataBytes) then
      begin
        if ComplexActionCallbackFunc <> nil then
          ComplexActionCallbackFunc(NodeBuffer, Action);
        Action^.nCode := CRC_EMPTY;
        NodeBuffer^.Actions^.iState := NextState;
      end;
    end else
      NodeBuffer^.Actions^.iState := NextState
  end
end;

// *****************************************************************************
//  procedure SendACDI_Request
//
//     Parameters:
//
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure SendACDI_Request(NodeBuffer: PNMRAnetNode; nCode: Word; NextState: Byte);
var
  Action: PQueuedAction;
begin
  if NodeBuffer^.Actions <> nil then
  begin
    Action := FindStoredComplexAction(NodeBuffer, nCode);                                 // Look for Datagram Actions from Nodes this node sent a Datagram to
    if Action <> nil then
    begin
      if NMRAnetAbbreviatedConfigurationProtocol_QueueTransmit(NodeBuffer, Action^.FromAlias) then
        Action^.nCode := CRC_EMPTY;
    end;
    NodeBuffer^.Actions^.iState := NextState
  end
end;


// *****************************************************************************
//  procedure DispatchDatagramAction
//
//     Parameters:
//
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure DispatchDatagramAction(NodeBuffer: PNMRAnetNode; nCode: Word; NextState: Byte);
var
  Action: PQueuedAction;
  Datagram: PDatagramBuffer;
begin
  if NodeBuffer^.Actions <> nil then
  begin
    Action := FindStoredComplexAction(NodeBuffer, nCode);                                 // Look for Datagram Actions from Nodes this node sent a Datagram to
    if Action <> nil then
    begin
      if NodeBuffer^.DatagramTransmit <> nil then
      begin                                                             // A node is responding to a Datagram this node sent
        Datagram := NodeBuffer^.DatagramTransmit;
        if Datagram^.State = DATAGRAM_BUFFER_IN_PROCESS then                     // Only look for transmit buffers that have Datagram Tranmissions in Process
          if NMRAnetUtilities_CompareAliasIDs(Datagram^.Alias, Action^.FromAlias) then
          begin                                                                   // The alias that sent the Action (OK/Rejected) is in the list of Nodes that we sent a Datagram to!
            Datagram^.ErrorCode.MTI := Action^.DataBytes[0];                    // Copy over the results that destination node passed in the received Datagram Result message
            Datagram^.ErrorCode.SubType[0] := Action^.DataBytes[2];
            Datagram^.ErrorCode.SubType[1] := Action^.DataBytes[1];
            Datagram^.State := DATAGRAM_BUFFER_TRANSFER_COMPLETE;
            Action^.nCode := CRC_EMPTY;                                         // Free the Action
            Exit;
          end;
      end;                                          // TODO THIS WILL BE RECURSIVE INTO THE LINKED LIST!!!@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
      Action^.nCode := CRC_EMPTY;                                               // The Action was found but there was no matching transmiting nodes
    end;
    NodeBuffer^.Actions^.iState := NextState
  end
end;

// *****************************************************************************
//  procedure DispatchMessageAction
//
//     Parameters:
//
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure DispatchMessageAction(NodeBuffer: PNMRAnetNode; nCode: Word; NextState: Byte);
var
  Action: PQueuedAction;
begin
  if NodeBuffer^.Actions <> nil then
  begin
    Action := FindStoredComplexAction(NodeBuffer, nCode);                                 // Look for Complex Actions from Nodes this node sent a Datagram to
    if Action <> nil then
    begin
      if ComplexActionCallbackFunc <> nil then
        ComplexActionCallbackFunc(NodeBuffer, Action);
      Action^.nCode := CRC_EMPTY;
    end;
    NodeBuffer^.Actions^.iState := NextState
  end
end;

// *****************************************************************************
//  procedure DispatchACDI_ReplyAction
//
//     Parameters:
//
//     Returns:
//
//     Description:  The CAN Frames are collected in the CAN Interrupt code to
//                   make up the full ACDI message Reply that is passed here.
//
// *****************************************************************************
procedure DispatchACDI_ReplyAction(NodeBuffer: PNMRAnetNode; nCode: Word; NextState: Byte);
var
  Action: PQueuedAction;
  Buffer: Word;
begin
  if NodeBuffer^.Actions <> nil then
  begin
    Action := FindStoredComplexAction(NodeBuffer, nCode);                                 // Look for ACDI Actions from Nodes this node
    if Action <> nil then
    begin
      Buffer := Action^.DataBytes[1] shl 8;
      Buffer := (Buffer or Action^.DataBytes[0]);
      if ACDI_ReceiveCallbackFunc <> nil then
        ACDI_ReceiveCallbackFunc(NodeBuffer, PACDI_ReceiveBuffer( Buffer));  // Snuck in
      Action^.nCode := CRC_EMPTY;
    end;
    NodeBuffer^.Actions^.iState := NextState
  end
end;

// *****************************************************************************
//  procedure Actions_Process
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure Actions_Process(NodeBuffer: PNMRAnetNode; Buffer: PCANBuffer);
const
  ADDRESSED = True;
  NONADDRESSED = False;
  
begin
  if NodeBuffer^.Actions <> nil then
  begin
    if not DuplicateDetected(NodeBuffer, SRC_DUPLICATE_NODE_ID, STATE_NMRABUS_DUPLICATE_FULL_ID) then  // Highest Priority, if detected the main loop needs to change state
      if not DuplicateDetected(NodeBuffer, SRC_DUPLICATE_ALIAS, STATE_NMRABUS_INHIBITED) then          // Next Highest Priority, if detected the main loop needs to change state
      begin
        case NodeBuffer^.Actions^.iState of
          // These Actions needs a Action message sent and were queued up at the Interrupt level automagically
          STATE_NMRABUS_RESPONSE_SEND_RID                          : SendCANLayerSimpleAction(NodeBuffer, Buffer, FT_RID, SRC_SEND_RID, STATE_NMRABUS_RESPONSE_SEND_AMD);
          STATE_NMRABUS_RESPONSE_SEND_AMD                          : SendCANLayerSimpleAction(NodeBuffer, Buffer, FT_AMD, SRC_SEND_AMD, STATE_NMRABUS_RESPONSE_SEND_VERIFIED_NODE);
          STATE_NMRABUS_RESPONSE_SEND_VERIFIED_NODE                : SendNMRAnetLayerSimpleAction(NodeBuffer, Buffer, FT_VERIFIED_NODE_ID_NUMBER, SRC_SEND_VERIFIED_NODE, STATE_NMRABUS_RESPONSE_SEND_PROTOCOL_SUPPORT);
          STATE_NMRABUS_RESPONSE_SEND_PROTOCOL_SUPPORT             : SendNMRAnetLayerComplexAction(NodeBuffer, Buffer, FT_PROTOCOL_SUPPORT_RESPONSE, ADDRESSED, CRC_SEND_PROTOCOL_SUPPORT, STATE_NMRABUS_RESPONSE_SEND_CONSUMER_IDENTIFIED);                           // Simple Action
          STATE_NMRABUS_RESPONSE_SEND_CONSUMER_IDENTIFIED          : SendNMRAnetLayerComplexAction(NodeBuffer, Buffer, FT_CONSUMER_IDENTIFIED, NONADDRESSED, CRC_SEND_CONSUMER_IDENTIFIED, STATE_NMRABUS_RESPONSE_SEND_PRODUCER_IDENTIFIED);
          STATE_NMRABUS_RESPONSE_SEND_PRODUCER_IDENTIFIED          : begin
                                                                       SendNMRAnetLayerComplexAction(NodeBuffer, Buffer, FT_PRODUCER_IDENTIFIED, NONADDRESSED, CRC_SEND_PRODUCER_IDENTIFIED, STATE_NMRABUS_RESPONSE_SEND_ALL_CONSUMER_PRODUCERS);
                                                                       NodeBuffer^.Actions^.Tag := 0;   // Get ready for next state
                                                                      end;
          STATE_NMRABUS_RESPONSE_SEND_ALL_CONSUMER_PRODUCERS        : SendNMRALayerSimpleSendAllConsumerProducer(NodeBuffer, Buffer, STATE_NMRABUS_RESPONSE_SEND_OPTIONAL_INTERACTION_REJECTED);
          STATE_NMRABUS_RESPONSE_SEND_OPTIONAL_INTERACTION_REJECTED : SendNMRAnetLayerComplexAction(NodeBuffer, Buffer, FT_OPTIONAL_INTERACTION_REJECTED, ADDRESSED, CRC_SEND_OPTIONAL_INTERACTION_REJECTED, STATE_NMRABUS_SEND_ACDI_REQUEST);
          STATE_NMRABUS_SEND_ACDI_REQUEST                           : SendACDI_Request(NodeBuffer, STATE_NMRABUS_SEND_ACDI_REQUEST, STATE_NMRABUS_DATAGRAM_RECEIVED_OK);

          // These Actions do NOT need a predefined Action message sent
          STATE_NMRABUS_DATAGRAM_RECEIVED_OK                        : DispatchDatagramAction(NodeBuffer, CRC_DATAGRAM_RECEIVED_OK, STATE_NMRABUS_DATAGRAM_REJECTED);
          STATE_NMRABUS_DATAGRAM_REJECTED                           : DispatchDatagramAction(NodeBuffer, CRC_DATAGRAM_REJECTED, STATE_NMRABUS_RESPONSE_CONSUMER_IDENTIFIED);
          STATE_NMRABUS_RESPONSE_CONSUMER_IDENTIFIED                : DispatchMessageAction(NodeBuffer, CRC_CONSUMER_IDENTIFIED, STATE_NMRABUS_RESPONSE_PRODUCER_IDENTIFIED);
          STATE_NMRABUS_RESPONSE_PRODUCER_IDENTIFIED                : DispatchMessageAction(NodeBuffer, CRC_PRODUCER_IDENTIFIED, STATE_NMRABUS_RESPONSE_AMR);
          STATE_NMRABUS_RESPONSE_AMR                                : DispatchMessageAction(NodeBuffer, CRC_AMR, STATE_NMRABUS_RESPONSE_AMD);
          STATE_NMRABUS_RESPONSE_AMD                                : DispatchMessageAction(NodeBuffer, CRC_AMD, STATE_NMRABUS_RESPONSE_PC_EVENT_REPORT);
          STATE_NMRABUS_RESPONSE_PC_EVENT_REPORT                    : DispatchMessageAction(NodeBuffer, CRC_PC_EVENT_REPORT, STATE_NMRABUS_VERIFIED_NODE_ID);
          STATE_NMRABUS_VERIFIED_NODE_ID                            : DispatchMessageAction(NodeBuffer, CRC_VERIFIED_NODE_ID, STATE_NMRABUS_ACDI_REPLY);
          STATE_NMRABUS_ACDI_REPLY                                  : DispatchACDI_ReplyAction(NodeBuffer, CRC_ACDI_REPLY, STATE_NMRABUS_RESPONSE_SEND_RID)

        else
          NodeBuffer^.Actions^.iState := STATE_NMRABUS_RESPONSE_SEND_RID;
        end;
      end
  end
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Process
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************

procedure NMRAnetStateMachine_Process(NodeBuffer: PNMRAnetNode);
var
  Buffer: TCANBuffer;     
  VariableField: DWord;
begin
  case NodeBuffer^.iStateMachine of
    STATE_NMRABUS_START :
      begin
        NodeBuffer^.State := BS_INHIBITED or BS_UNITIALIZED;
        FlushLists;
        while CAN_Engine.State and CES_TRANSMITTING <> 0 do;                             // Wait for the last transmited packet
        NodeBuffer^.iStateMachine := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_GENERATE_NODE_ALIAS :
      begin
        NodeBuffer^.Node.AliasID := NMRAnetUtilities_CreateAliasID(NodeBuffer^.Node.Seed, False);
        NodeBuffer^.iCID := 0;
        NodeBuffer^.iStateMachine := STATE_NMRABUS_TRANSMIT_CID;
      end;
    STATE_RANDOM_NUMBER_GENERATOR :
      begin
        NMRAnetUtilities_PsudoRandomNumberGeneratorOnSeed(NodeBuffer^.Node.Seed);
        NodeBuffer^.iStateMachine := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_TRANSMIT_CID :
      begin
        case NodeBuffer^.iCID of
          0 : VariableField := FT_CID0;   // Queue up
          1 : VariableField := FT_CID1;
          2 : VariableField := FT_CID2;
          3 : VariableField := FT_CID3;
        end;
        if TryTransmitCANLayerMsg(NodeBuffer, @Buffer, VariableField) then
          NodeBuffer^.iStateMachine := STATE_NMRABUS_NEXT_CDI;
      end;
    STATE_NMRABUS_NEXT_CDI :
      begin
        if NodeBuffer^.iCID < 3 then
        begin
          Inc(NodeBuffer^.iCID);
          NodeBuffer^.iStateMachine := STATE_NMRABUS_TRANSMIT_CID
        end else 
        begin
          if CAN_Engine.State and CES_TRANSMITTING = 0 then     // Wait until the transmission is complete before waiting the 200ms
          begin
            NodeBuffer^.iStateMachine := STATE_NMRABUS_WAITSTATE;
            NodeBuffer^.LoginTimeCount := 0;
          end
        end
      end;
    STATE_NMRABUS_WAITSTATE :
      begin
        if NodeBuffer^.LoginTimeCount > MAX_BUS_LOGIN_TIMEOUT then
          NodeBuffer^.iStateMachine := STATE_NMRABUS_SEND_LOGIN_RID;
      end;
    STATE_NMRABUS_SEND_LOGIN_RID :
      begin
        if not DuplicateDetected(NodeBuffer, SRC_DUPLICATE_ALIAS, STATE_RANDOM_NUMBER_GENERATOR) then
          if TryTransmitCANLayerMsg(NodeBuffer, @Buffer, FT_RID) then
            NodeBuffer^.iStateMachine := STATE_NMRABUS_SEND_LOGIN_AMD;
      end;
    STATE_NMRABUS_SEND_LOGIN_AMD :
      begin
        if not DuplicateDetected(NodeBuffer, SRC_DUPLICATE_ALIAS, STATE_RANDOM_NUMBER_GENERATOR) then
          if TryTransmitCANLayerMsg(NodeBuffer, @Buffer, FT_AMD) then
          begin
            NodeBuffer^.State := NodeBuffer^.State or BS_PERMITED and not BS_INHIBITED;
            NodeBuffer^.iStateMachine := STATE_NMRABUS_INITIALIZED
          end
      end;
    STATE_NMRABUS_INITIALIZED :
      begin
        if not DuplicateDetected(NodeBuffer, SRC_DUPLICATE_ALIAS, STATE_RANDOM_NUMBER_GENERATOR) then
          if TryTransmitNMRABusLayerMsg(NodeBuffer, @Buffer, FT_INITIALIZATION_COMPLETE, 0, 0, nil) then
          begin
            NodeBuffer^.iStateMachine := STATE_NMRABUS_LOGIN_IDENTIFY_EVENTS;
            NodeBuffer^.State := NodeBuffer^.State or BS_INITIALIZED and not BS_UNITIALIZED
          end
      end;
    STATE_NMRABUS_LOGIN_IDENTIFY_EVENTS :
      begin
        LockCANInterrupt;
        if NMRAnetCANReceive_AllocateActions(NodeBuffer) then
        begin
          NodeBuffer^.Actions^.SimpleActionFlags := NodeBuffer^.Actions^.SimpleActionFlags or SRC_SEND_ALL_CONSUMER_PRODUCER_IDENTIFIED;
          NodeBuffer^.iStateMachine := STATE_NMRABUS_PERMITTED;
        end;
        UnLockCANInterrupt;
      end;
    STATE_NMRABUS_PERMITTED :
      begin
        Actions_Process(NodeBuffer, @Buffer);                                 // Handle auto Actions to CAN/NMRAnet messages coming in
        NMRAnetDatagrams_ProcessReceive(NodeBuffer);                                        // Handle Datagrams coming in
        NMRAnetDatagrams_ProcessTransmit(NodeBuffer);                           // Handle Datagrams going out
        NMRAnetConfigurationProtocol_Process(NodeBuffer);
        NMRAnetAbbreviatedConfigurationProtocol_Process(NodeBuffer);
      end;
    STATE_NMRABUS_INHIBITED :
      begin
        if TryTransmitCANLayerMsg(NodeBuffer, @Buffer, FT_AMR) then
        begin
          FlushLists;
          ReleaseActions(NodeBuffer);
          NodeBuffer^.State := NodeBuffer^.State or BS_INHIBITED and not BS_PERMITED;
          NodeBuffer^.iStateMachine := STATE_RANDOM_NUMBER_GENERATOR;
        end
      end;
    STATE_NMRABUS_DUPLICATE_FULL_ID :
      begin
        if TryTransmitCANLayerMsg(NodeBuffer, @Buffer, FT_AMR) then
        begin
          FlushLists;
          ReleaseActions(NodeBuffer);
          NodeBuffer^.State := NodeBuffer^.State or BS_INHIBITED and not BS_PERMITED;
          NodeBuffer^.iStateMachine := STATE_NMRABUS_TAKE_OFFLINE
        end
      end;
    STATE_NMRABUS_TAKE_OFFLINE :
      begin
    //    if TryTransmitNMRABusLayerMsg(PCER_DUPLICATE_ID..., @Buffer) then
    //    begin
    //      NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NodeBuffer^.iStateMachine := STATE_NMRABUS_OFFLINE
    //    end
      end;
    STATE_NMRABUS_OFFLINE :
      begin
        // Done until reboot
      end
  else
    NodeBuffer^.iStateMachine := STATE_NMRABUS_START;
  end
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_Disconnect(NodeBuffer: PNMRAnetNode);
begin
  NodeBuffer^.iStateMachine := STATE_NMRABUS_INHIBITED
end;

end.