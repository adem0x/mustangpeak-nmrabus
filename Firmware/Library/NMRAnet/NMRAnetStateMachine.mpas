unit NMRAnetStateMachine;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRABus specifications
//
// ******************************************************************************


uses
  NMRAnetDefines,
  NMRAnetUtilities,
  NMRAnetCANReceive,
  CANStorage,
  CANDefines,
  NMRAnetDatagrams,
  NMRAnetDatagramDefines;

{$I Options.inc}

type
  TDatagramPacketHandlerFunc = procedure(DatagramBuffer: PDatagramBuffer; var DoDefault: Boolean);
  PDatagramPacketHandlerFunc = ^TDatagramPacketHandlerFunc;
  TStreamPacketHandlerFunc = procedure(CANBuffer: PCANBuffer; var DoDefault: Boolean);
  PStreamPacketHandlerFunc = ^TStreamPacketHandlerFunc;


  procedure NMRAnetStateMachine_Process;
  procedure NMRAnetStateMachine_Disconnect;
  procedure NMRAnetStateMachine_Initialize;
  procedure NMRAnetStateMachine_1ms_Timer;


  // defined in the user program
  procedure GetUniqueIDFunc(var HiID, LoID: DWord); external;
  
  // defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure EnableCANInterrupt(Enable: Boolean); external;
  
var
  TX_CANBufferList: TCANBufferList; external;
  TX_NMRAnetBufferList: TCANBufferList; external;


implementation


// *****************************************************************************
//  procedure FlushResponseList
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure FlushResponses;
var
  i, j: Integer;
begin
  NMRABus.Responses.SimpleResponseFlags := 0;
  NMRABus.Responses.ListIndex := 0;
  NMRABus.Responses.SimpleIndexMask := 0;
  NMRABus.Responses.iState := 0;
  NMRABus.Responses.iCDI := 0;
  for i := 0 to LEN_QUEUED_RESPONSE_LIST - 1 do
  begin
    NMRABus.Responses.List[i].ResponseCode := 0;
    NMRABus.Responses.List[i].DestinationNodeAlias := 0;
    for j := 0 to CAN_DATA_LEN - 1 do
      NMRABus.Responses.List[i].DataBytes[j] := 0;
  end;
end;

// *****************************************************************************
//  procedure FlushLists
//     Parameters:
//     Returns:
//
//     Description: Clears the lists
//
// *****************************************************************************
procedure FlushLists;
begin
  CANStorage_FlushList(@TX_CANBufferList);                                      // Flush any pending packets
  CANStorage_FlushList(@TX_NMRAnetBufferList);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the BufferArray
//              LasterBuffer   : Pointer to the last item in the BufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure NMRAnetStateMachine_InitializeList(ListPtr: PCANBufferList; BufferArrayPtr: PCANBufferArray; ListLength: Byte);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.Size := ListLength;
  ListPtr^.Head := @BufferArrayPtr^[0];
  ListPtr^.Tail := @BufferArrayPtr^[0];
  ListPtr^.Count := 0;
  ListPtr^.MaxCount := 0;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_Initialize;
begin
  NMRAnetDatagrams_Initialize;
  NMRAnetCANReceive_Initialize;
  NMRABus.State := 0;
  NMRABus.Interrupt_State := 0;
  GetUniqueIDFunc(NMRABus.Node_ID[1], NMRABus.Node_ID[0]);
  NMRABus.Unique_ID_Global_Seed[0] := NMRABus.Node_ID[0];
  NMRABus.Unique_ID_Global_Seed[1] := NMRABus.Node_ID[1];
  NMRABus.iState := STATE_NMRABUS_START;
  FlushResponses;
  NMRAnetStateMachine_InitializeList(@TX_CANBufferList, @TX_CANBuffer, TX_CAN_BUFFER_LEN);
  NMRAnetStateMachine_InitializeList(@TX_NMRAnetBufferList, @TX_NMRAnet_Buffer, TX_NMRANET_BUFFER_LEN);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_1ms_Timer;
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_1ms_Timer;
begin
  Inc(NMRABus.LoginTimeCount);
  NMRAnetDatagrams_1ms_TimeTick;
end;


// ***********************************************************************************************************
// CAN RECEIVE METHODS
//************************************************************************************************************

// ***********************************************************************************************************
// MESSAGELOOP RESPONSE METHODS
//************************************************************************************************************

// *****************************************************************************
//  procedure TryTransmitCANLayerMsg
//     Parameters:
//     Returns:
//
//     Description: Clears the lists
//
// *****************************************************************************
function TryTransmitCANLayerMsg(VariableField: DWord; Buffer: PCANBuffer): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_CANBufferList) then
  begin
    NMRAnetUtilities_CreateCANControlFramePacket(VariableField, Buffer);
    if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True
    end
  end
end;

// *****************************************************************************
//  procedure TryTransmitNMRABusLayerMsg
//     Parameters:
//     Returns:
//
//     Description: Clears the lists
//
// *****************************************************************************
function TryTransmitNMRABusLayerMsg(VariableField: DWord; DestinationAlias: Word; Buffer: PCANBuffer): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    NMRAnetUtilities_CreateNMRABusMessagePacket(VariableField, DestinationAlias, Buffer);
    if CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True;
    end
  end
end;

function TestReceivedMsgFlags(Flags: Word; Clear: Boolean): Boolean;
var
  Temp: Word;
begin
 // EnableCANInterrupt(False);
  Temp := NMRABus.Responses.SimpleResponseFlags;
  if Clear then
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags and not Flags;
  Result := Temp and Flags <> 0;
 // EnableCANInterrupt(True);
end;

procedure SimpleResponse_Process;
begin

end;

procedure Response_Process;
begin
  case NMRABus.Responses.iState of
    STATE_RESPONSE_START :
      begin
        if NMRABus.Responses.SimpleResponseFlags = 0 then
          NMRABus.Responses.iState := STATE_RESPONSE_NEXT_SIMPLE_RESPONSE
        else
          NMRABus.Responses.iState := STATE_RESPONSE_SIMPLE_RESPONSE
      end;
    STATE_RESPONSE_SIMPLE_RESPONSE :
      begin
        case NMRABus.Responses.SimpleIndexMask of
          $0001 : 
            begin
               if NMRABus.Responses.SimpleIndexMask and NMRABus.Responses.SimpleResponseFlags <> 0 then
               begin
               end
            end;
          $0002 : begin end;
          $0004 : begin end;
          $0008 : begin end;
          $0010 : begin end;
          $0020 : begin end;
          $0040 : begin end;
          $0080 : begin end;
          $0100 : begin end;
          $0200 : begin end;
          $0400 : begin end;
          $0800 : begin end;
          $1000 : begin end;
          $2000 : begin end;
          $4000 : begin end;
          $4000 : begin end;
        end;
        NMRABus.Responses.iState := STATE_RESPONSE_NEXT_SIMPLE_RESPONSE
      end;
    STATE_RESPONSE_NEXT_SIMPLE_RESPONSE :
      begin
        if NMRABus.Responses.SimpleIndexMask < $8000 then
         NMRABus.Responses.SimpleIndexMask := NMRABus.Responses.SimpleIndexMask shr 1
        else
          NMRABus.Responses.SimpleIndexMask := $0001;

        NMRABus.Responses.iState := STATE_RESPONSE_COMPLEX_RESPONSE
      end;
    STATE_RESPONSE_COMPLEX_RESPONSE :
      begin
        NMRABus.Responses.iState := STATE_RESPONSE_NEXT_COMPLEX_RESPONSE
      end;
    STATE_RESPONSE_NEXT_COMPLEX_RESPONSE :
      begin
        Inc(NMRABus.Responses.ListIndex);
        NMRABus.Responses.iState := STATE_RESPONSE_START
      end
  else
    NMRABus.Responses.iState := STATE_RESPONSE_START;
  end
end;

procedure NMRAnetStateMachine_Process;
var
  Buffer: TCANBuffer;
  VariableField: DWord;
begin
  case NMRABus.iState of
    STATE_NMRABUS_START :
      begin
        NMRABus.State := BS_INHIBITED or BS_UNITIALIZED;
        FlushLists;
        while CANStorage_Transmitting do;                                       // Wait for the last transmited packet
        NMRABus.iState := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_GENERATE_NODE_ALIAS :
      begin
        NMRAnetUtilities_CreateAliasID(False);
        NMRABus.Responses.iCDI := 0;
        NMRABus.iState := STATE_NMRABUS_TRANSMIT_CID;
      end;
    STATE_RANDOM_NUMBER_GENERATOR :
      begin
        NMRAnetUtilities_PsudoRandomNumberGenerator;
        NMRABus.iState := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_TRANSMIT_CID :
      begin
        case NMRABus.Responses.iCDI of
          0 : VariableField := FT_CID0;   // Queue up
          1 : VariableField := FT_CID1;
          2 : VariableField := FT_CID2;
          3 : VariableField := FT_CID3;
        end;
        if TryTransmitCANLayerMsg(VariableField, @Buffer) then
          NMRABus.iState := STATE_NMRABUS_NEXT_CDI;
      end;
    STATE_NMRABUS_NEXT_CDI :
      begin
        if NMRABus.Responses.iCDI < 3 then
        begin
          Inc(NMRABus.Responses.iCDI);
          NMRABus.iState := STATE_NMRABUS_TRANSMIT_CID
        end else 
        begin
          if not CANStorage_Transmitting then                                   // Wait until the transmission is complete before waiting the 200ms
          begin
            NMRABus.iState := STATE_NMRABUS_WAITSTATE;
            NMRABus.LoginTimeCount := 0;
          end
        end
      end;
    STATE_NMRABUS_WAITSTATE :
      begin
        if NMRABus.LoginTimeCount > MAX_BUS_LOGIN_TIMEOUT then
          NMRABus.iState := STATE_NMRABUS_SEND_LOGIN_RID;
      end;
    STATE_NMRABUS_SEND_LOGIN_RID :
      begin
        if TestReceivedMsgFlags(SRF_DUPLICATE_ALIAS, True) then
          NMRABus.iState := STATE_RANDOM_NUMBER_GENERATOR
        else
        if TryTransmitCANLayerMsg(FT_RID, @Buffer) then
          NMRABus.iState := STATE_NMRABUS_SEND_LOGIN_AMD;
      end;
    STATE_NMRABUS_SEND_LOGIN_AMD :
      begin
        if TestReceivedMsgFlags(SRF_DUPLICATE_ALIAS, True) then
          NMRABus.iState := STATE_RANDOM_NUMBER_GENERATOR
        else
        if TryTransmitCANLayerMsg(FT_AMD, @Buffer) then
        begin
          NMRABus.State := NMRABus.State or BS_PERMITED and not BS_INHIBITED;
          NMRABus.iState := STATE_NMRABUS_INITIALIZED
        end
      end;
    STATE_NMRABUS_INITIALIZED :
      begin
        if TestReceivedMsgFlags(SRF_DUPLICATE_ALIAS, True) then
          NMRABus.iState := STATE_NMRABUS_GENERATE_NODE_ALIAS
        else
        if TryTransmitNMRABusLayerMsg(FT_INITIALIZATION_COMPLETE, 0, @Buffer) then
        begin
          NMRABus.iState := STATE_NMRABUS_PERMITTED;
          NMRABus.State := NMRABus.State or BS_INITIALIZED and not BS_UNITIALIZED
        end
      end;
    STATE_NMRABUS_PERMITTED :
      begin
        if TestReceivedMsgFlags(SRF_DUPLICATE_NODE_ID, True) then
          NMRABus.iState :=  STATE_NMRABUS_DUPLICATE_FULL_ID                    // Highest Priority
        else
        if TestReceivedMsgFlags(SRF_DUPLICATE_ALIAS, True) then
          NMRABus.iState := STATE_NMRABUS_INHIBITED
        else
          Response_Process
      end;
    STATE_NMRABUS_INHIBITED :
      begin
        if TryTransmitCANLayerMsg(FT_AMR, @Buffer) then
        begin
          FlushLists;
          FlushResponses;
          NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_RANDOM_NUMBER_GENERATOR;
        end
      end;
    STATE_NMRABUS_DUPLICATE_FULL_ID :
      begin
        if TryTransmitCANLayerMsg(FT_AMR, @Buffer) then
        begin
          FlushLists;
          FlushResponses;
          NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_NMRABUS_TAKE_OFFLINE
        end
      end;
    STATE_NMRABUS_TAKE_OFFLINE :
      begin
    //    if TryTransmitNMRABusLayerMsg(PCER_DUPLICATE_ID..., @Buffer) then
    //    begin
    //      NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_NMRABUS_OFFLINE
    //    end
      end;
    STATE_NMRABUS_OFFLINE :
      begin
        // Done until reboot
      end
  else
    NMRABus.iState := STATE_NMRABUS_START;
  end
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_Disconnect;
begin
  NMRABus.iState := STATE_NMRABUS_INHIBITED
end;

end.