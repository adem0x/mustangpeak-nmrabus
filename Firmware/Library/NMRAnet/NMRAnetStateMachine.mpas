unit NMRAnetStateMachine;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRAnet StateMachine for the main loop in a program.
//
// ******************************************************************************


// &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//
// MAY 12, 2012
//
//  THE PROTOCOL ID PROTOCOL RESULT IS STILL JUST HACKED.  NEED TO UNDERSTAND THE
//     FLAGS BETTER TO IMPLEMENT
// &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

uses
  NMRAnetEventDefines,
  NMRAnetAppDefines,
  NMRAnetDefines,
  NMRAnetUtilities,
  NMRAnetCANReceive,
  CANStorage,
  CANDefines,
  NMRAnetDatagrams,
  NMRAnetDatagramDefines,
  NMRAnetConfigurationProtocol,
  NMRAnetConfigurationProtocolDefines;

{$I Options.inc}


  procedure NMRAnetStateMachine_Process;
  procedure NMRAnetStateMachine_Disconnect;
  procedure NMRAnetStateMachine_Initialize;
  procedure NMRAnetStateMachine_1ms_Timer;
  procedure NMRAnetStateMachine_SetSimpleCallbackFunc(CallBack: PSimpleResponseCallbackFunc);
  procedure NMRAnetStateMachine_SetComplexCallbackFunc(CallBack: PComplexResponseCallbackFunc);
  function NMRAnetStateMachine_TrySendIdentifyProducer(Buffer: PCANBuffer; SourceAliasID: Word; EventID: PEventID): Boolean;
  function NMRAnetStateMachine_TrySendIdentifyConsumer(Buffer: PCANBuffer; SourceAliasID: Word; EventID: PEventID): Boolean;
  function NMRAnetStateMachine_TrySendIdentifyEvents(Buffer: PCANBuffer; SourceAliasID: Word): Boolean;
  function NMRAnetStateMachine_TrySendAliasMapEnquiry(Buffer: PCANBuffer; SourceAliasID: Word): Boolean;
  function NMRAnetStateMachine_TrySendVerifyNodeID(Buffer: PCANBuffer; DestinationAliasID, SourceAliasID: Word): Boolean;
  
  // Exported Functions
  function TryTransmitNMRABusLayerMsg(Buffer: PCANBuffer; VariableField: DWord; DestinationAlias, SourceAliasID: Word; DataCount: Byte; DataBytes: PCAN_DataBytes): Boolean;

  // defined in the user program
  procedure GetUniqueIDFunc(var HiID, LoID: DWord); external;
  
  // defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure LockCANInterrupt; external;
  procedure UnLockCANInterrupt; external;
  
var
  TX_CANBufferList: TCANBufferList; external;
  TX_NMRAnetBufferList: TCANBufferList; external;


implementation


function NMRAnetStateMachine_TrySendIdentifyProducer(Buffer: PCANBuffer; SourceAliasID: Word; EventID: PEventID): Boolean;
//var
//  BrokenBuffer: TCANBUffer;   BUG IN VERSION 5.60 with this
begin
  Result := TryTransmitNMRABusLayerMsg(Buffer, FT_PRODUCER_IDENDIFY, 0, SourceAliasID, EVENT_ARRAY_LENGTH, PCAN_DataBytes( EventID));
end;

function NMRAnetStateMachine_TrySendIdentifyConsumer(Buffer: PCANBuffer; SourceAliasID: Word; EventID: PEventID): Boolean;
//var
//  Buffer: TCANBUffer;   BUG IN VERSION 5.60 with this
begin
  Result := TryTransmitNMRABusLayerMsg(Buffer, FT_CONSUMER_IDENTIFY, 0, SourceAliasID, EVENT_ARRAY_LENGTH,  PCAN_DataBytes( EventID));
end;

function NMRAnetStateMachine_TrySendIdentifyEvents(Buffer: PCANBuffer; SourceAliasID: Word): Boolean;
//var
//  Buffer: TCANBUffer;   BUG IN VERSION 5.60 with this
begin
  Result := TryTransmitNMRABusLayerMsg(Buffer, FT_EVENTS_IDENTIFY, 0, SourceAliasID, 0, nil);
end;

function NMRAnetStateMachine_TrySendAliasMapEnquiry(Buffer: PCANBuffer; SourceAliasID: Word): Boolean;
begin
  Result := TryTransmitNMRABusLayerMsg(Buffer, FT_AME, 0, SourceAliasID, 0, nil);
end;

function NMRAnetStateMachine_TrySendVerifyNodeID(Buffer: PCANBuffer; DestinationAliasID, SourceAliasID: Word): Boolean;
var
  DataBytes: TCAN_DataBytes;
begin
  if DestinationAliasID <> 0 then
  begin
    DataBytes[0] := MTI_VERIFY_NODE_ID_NUMBER_DEST;
    Result := TryTransmitNMRABusLayerMsg(Buffer, FT_VERIFY_NODE_ID_NUMBER_DEST, DestinationAliasID, SourceAliasID, 1, @DataBytes);
  end else
    Result := TryTransmitNMRABusLayerMsg(Buffer, FT_VERIFY_NODE_ID_NUMBER, 0, SourceAliasID, 0, nil);
end;

// *****************************************************************************
//  procedure FlushResponseList
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure FlushResponses;
var
  i, j: Integer;
begin
  NMRABus.Responses.SimpleResponseFlags := 0;
  NMRABus.Responses.iState := 0;
  NMRABus.Responses.Tag := 0;
  for i := 0 to LEN_QUEUED_RESPONSE_LIST - 1 do
  begin
    NMRABus.Responses.List[i].nCode := CRC_EMPTY;
    NMRABus.Responses.List[i].Alias := 0;
    NMRABus.Responses.List[i].DataCount := 0;
    for j := 0 to CAN_DATA_LEN - 1 do
      NMRABus.Responses.List[i].DataBytes[j] := 0;
  end;
end;

// *****************************************************************************
//  procedure FlushLists
//     Parameters:
//     Returns:
//
//     Description: Clears the lists
//
// *****************************************************************************
procedure FlushLists;
begin
  CANStorage_FlushList(@TX_CANBufferList);                                      // Flush any pending packets
  CANStorage_FlushList(@TX_NMRAnetBufferList);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the BufferArray
//              LasterBuffer   : Pointer to the last item in the BufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure NMRAnetStateMachine_InitializeList(ListPtr: PCANBufferList; BufferArrayPtr: PCANBufferArray; ListLength: Byte);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.Size := ListLength;
  ListPtr^.Head := @BufferArrayPtr^[0];
  ListPtr^.Tail := @BufferArrayPtr^[0];
  ListPtr^.Count := 0;
  ListPtr^.MaxCount := 0;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_SetSimpleCallbackFunc(CallBack: PSimpleResponseCallbackFunc);
begin
  SimpleResponseCallbackFunc := Callback;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_SetComplexCallbackFunc(CallBack: PComplexResponseCallbackFunc);
begin
  ComplexResponseCallbackFunc := Callback;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_Initialize;
begin
  NMRAnetDatagrams_Initialize;
  NMRAnetCANReceive_Initialize;
  NMRAnetConfigurationProtocol_Initialize;
  SimpleResponseCallbackFunc := PSimpleResponseCallbackFunc( nil);
  ComplexResponseCallbackFunc := PComplexResponseCallbackFunc( nil);
  NMRABus.State := 0;
  GetUniqueIDFunc(NMRABus.Node.ID[1], NMRABus.Node.ID[0]);
  NMRABus.Node.Seed[0] := NMRABus.Node.ID[0];
  NMRABus.Node.Seed[1] := NMRABus.Node.ID[1];
  NMRABus.iState := STATE_NMRABUS_START;
  FlushResponses;
  NMRABus.Responses.BufferOverrunCount := 0;
  NMRAnetStateMachine_InitializeList(@TX_CANBufferList, @TX_CANBuffer, TX_CAN_BUFFER_LEN);
  NMRAnetStateMachine_InitializeList(@TX_NMRAnetBufferList, @TX_NMRAnet_Buffer, TX_NMRANET_BUFFER_LEN);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_1ms_Timer;
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_1ms_Timer;
begin
  Inc(NMRABus.LoginTimeCount);
  NMRAnetDatagrams_1ms_TimeTick;
end;

// *****************************************************************************
//  function TestReceivedMsgFlags
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function TestReceivedMsgFlags(Flag: Word): Boolean;
begin
  Result := NMRABus.Responses.SimpleResponseFlags and Flag <> 0
end;

// *****************************************************************************
//  function ClearReceivedMsgFlags
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure ClearReceivedMsgFlags(Flag: Word);
begin
  LockCANInterrupt;
  NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags and not Flag;
  UnLockCANInterrupt;
end;

// *****************************************************************************
//  function DuplicateDetected
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function DuplicateDetected(Flag: Word; NextState: Byte): Boolean;
begin
  Result := False;
  if TestReceivedMsgFlags(Flag) then
  begin
    ClearReceivedMsgFlags(Flag);
    NMRABus.iState := NextState;
    Result := True
  end
end;


// *****************************************************************************
//  procedure TryTransmitCANLayerMsg
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function TryTransmitCANLayerMsg(VariableField: DWord; SourceAliasID: Word; Buffer: PCANBuffer): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_CANBufferList) then
  begin
    NMRAnetUtilities_CreateCANControlFramePacket(Buffer, VariableField, SourceAliasID);
    if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True
    end
  end ;
end;

// *****************************************************************************
//  procedure TryTransmitNMRABusLayerMsg
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function TryTransmitNMRABusLayerMsg(Buffer: PCANBuffer; VariableField: DWord; DestinationAlias, SourceAliasID: Word; DataCount: Byte; DataBytes: PCAN_DataBytes): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    NMRAnetUtilities_CreateNMRABusMessagePacket(Buffer, VariableField, DestinationAlias, SourceAliasID, DataCount, DataBytes);
    if CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True;
    end
  end
end;

// *****************************************************************************
//  function NextComplexResponse
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function FindStoredComplexResponse(nCode: Word): PQueuedResponse;
var
  i: Word;
begin
  i := 0;
  Result := nil;
  while i < LEN_QUEUED_RESPONSE_LIST do
  begin
    if NMRABus.Responses.List[i].nCode = nCode then
    begin
      Result := @NMRABus.Responses.List[i];
      Exit
    end;
    Inc(i);
  end;
end;

// *****************************************************************************
//  procedure HandleOptionalInteraction
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure HandleOptionalInteraction(Response: PQueuedResponse);
begin
end;

// *****************************************************************************
//  procedure HandleCANLayerSimpleResponse
//
//     Parameters:  Buffer - Buffer to load to send
//                  VariableField - MIT Coding for the Message to Send
//                  Flag - Flag to test for to decide if the response is needed
//                  NextState - next state in the statemachine once the response is handled
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure HandleCANLayerSimpleResponse(Buffer: PCANBuffer; VariableField: DWord; SourceAliasID: Word; Flag: Word; NextState: Byte);
begin
  if TestReceivedMsgFlags(Flag) then
    if TryTransmitCANLayerMsg(VariableField, SourceAliasID, Buffer) then
      ClearReceivedMsgFlags(Flag);
  NMRABus.Responses.iState := NextState
end;

// *****************************************************************************
//  procedure HandleNMRAnetLayerSimpleResponse
//
//     Parameters:  Buffer - Buffer to load to send
//                  VariableField - MIT Coding for the Message to Send
//                  Flag - Flag to test for to decide if the response is needed
//                  NextState - next state in the statemachine once the response is handled
//
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure HandleNMRAnetLayerSimpleResponse(Buffer: PCANBuffer; VariableField: DWord; SourceAliasID: Word; Flag: Word; NextState: Byte);
begin
  if TestReceivedMsgFlags(Flag) then
    if TryTransmitNMRABusLayerMsg(Buffer, VariableField, 0, SourceAliasID, 0, nil) then
    begin
      if SimpleResponseCallbackFunc <> nil then
        SimpleResponseCallbackFunc(Flag);
      ClearReceivedMsgFlags(Flag);
    end;

  NMRABus.Responses.iState := NextState
end;

// *****************************************************************************
//  procedure HandleNMRALayerSimpleSendAllConsumerProducer
//
//     Parameters:  Buffer - Buffer to load to send
//                  VariableField - MIT Coding for the Message to Send
//                  nCode - The type of response needed to test for to decide if the response is needed
//                  NextState - next state in the statemachine once the response is handled
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure HandleNMRALayerSimpleSendAllConsumerProducer(Buffer: PCANBuffer; SourceAliasID: Word; NextState: Byte);
begin
  if TestReceivedMsgFlags(SRC_ALL_CONSUMER_PRODUCER_IDENTIFIED) then
  begin
    if NMRABus.Responses.Tag < MAX_SUPPORTED_EVENTS_PRODUCED then
    begin
      if TryTransmitNMRABusLayerMsg(Buffer, FT_PRODUCER_IDENTIFIED, 0, SourceAliasID, 8, @SUPPORTED_EVENTS_PRODUCED[NMRABus.Responses.Tag]) then
        Inc(NMRABus.Responses.Tag);
    end else
    if NMRABus.Responses.Tag < MAX_SUPPORTED_EVENTS then
    begin
      if TryTransmitNMRABusLayerMsg(Buffer, FT_CONSUMER_IDENTIFIED, 0, SourceAliasID, 8, @SUPPORTED_EVENTS_CONSUMED[NMRABus.Responses.Tag-MAX_SUPPORTED_EVENTS_PRODUCED]) then
        Inc(NMRABus.Responses.Tag);
    end else
    begin
      if SimpleResponseCallbackFunc <> nil then
        SimpleResponseCallbackFunc(SRC_ALL_CONSUMER_PRODUCER_IDENTIFIED);
      ClearReceivedMsgFlags(SRC_ALL_CONSUMER_PRODUCER_IDENTIFIED);              // Done
      NMRABus.Responses.iState := NextState
    end
  end else
    NMRABus.Responses.iState := NextState                                       // Can't skip over this one until done with all sending
end;

// *****************************************************************************
//  procedure HandleNMRAnetLayerComplexResponse
//
//     Parameters:  Buffer - Buffer to load to send
//                  VariableField - MIT Coding for the Message to Send
//                  nCode - The type of response needed to test for to decide if the response is needed
//                  NextState - next state in the statemachine once the response is handled
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure HandleNMRAnetLayerComplexResponse(Buffer: PCANBuffer; VariableField: DWord; SourceAliasID, nCode: Word; NextState: Byte);
var
  Response: PQueuedResponse;
begin
  Response := FindStoredComplexResponse(nCode);
  if Response <> nil then
    if TryTransmitNMRABusLayerMsg(Buffer, VariableField, Response^.Alias, SourceAliasID, Response^.DataCount, @Response^.DataBytes) then
    begin
      if ComplexResponseCallbackFunc <> nil then
        ComplexResponseCallbackFunc(Response);
      Response^.nCode := CRC_EMPTY;
    end;
  NMRABus.Responses.iState := NextState
end;

// *****************************************************************************
//  procedure DispatchDatagramResponse
//
//     Parameters:
//
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure DispatchDatagramResponse(nCode: Word; NextState: Byte);
var
  Response: PQueuedResponse;
  Datagram: PDatagramBuffer;
  i: Integer;
begin
  Response := FindStoredComplexResponse(nCode);                                 // Look for Datagram Responses from Nodes this node sent a Datagram to
  if Response <> nil then
  begin
    i := 0;                                                                     // A node is responding to a Datagram this node sent
    while i < LEN_DATAGRAM_TRANSMIT_ARRAY do
    begin
      Datagram := @DatagramTransmit.List[i];
      if Datagram^.iState = DATAGRAM_BUFFER_IN_PROCESS then                     // Only look for transmit buffers that have Datagram Tranmissions in Process
        if NMRAnetUtilities_CompareAliasIDs(DatagramTransmit.List[i].Alias, Response^.Alias) then
        begin                                                                   // The alias that sent the response (OK/Rejected) is in the list of Nodes that we sent a Datagram to!
          Datagram^.ErrorCode.MTI := Response^.DataBytes[0];                    // Copy over the results that destination node passed in the received Datagram Result message
          Datagram^.ErrorCode.SubType[0] := Response^.DataBytes[2];
          Datagram^.ErrorCode.SubType[1] := Response^.DataBytes[1];
          Datagram^.iState := DATAGRAM_BUFFER_TRANSFER_COMPLETE;
          Response^.nCode := CRC_EMPTY;                                         // Free the response
          Exit;
        end;
      Inc(i)
    end;
    Response^.nCode := CRC_EMPTY;                                               // The response was found but there was no matching transmiting nodes
  end;
  NMRABus.Responses.iState := NextState
end;

// *****************************************************************************
//  procedure DispatchMessageResponse
//
//     Parameters:
//
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure DispatchMessageResponse(nCode: Word; NextState: Byte);
var
  Response: PQueuedResponse;
begin
  Response := FindStoredComplexResponse(nCode);                                 // Look for Datagram Responses from Nodes this node sent a Datagram to
  if Response <> nil then
  begin
    if ComplexResponseCallbackFunc <> nil then
      ComplexResponseCallbackFunc(Response);
    Response^.nCode := CRC_EMPTY;
  end;
  NMRABus.Responses.iState := NextState
end;

// *****************************************************************************
//  procedure Responses_Process
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure Responses_Process(Buffer: PCANBuffer; SourceAliasID: Word);
begin
  if not DuplicateDetected(SRC_DUPLICATE_NODE_ID, STATE_NMRABUS_DUPLICATE_FULL_ID) then  // Highest Priority, if detected the main loop needs to change state
    if not DuplicateDetected(SRC_DUPLICATE_ALIAS, STATE_NMRABUS_INHIBITED) then          // Next Highest Priority, if detected the main loop needs to change state
    begin
      case NMRABus.Responses.iState of
        // These responses needs a response message sent
        STATE_NMRABUS_RESPONSE_SEND_RID                    : HandleCANLayerSimpleResponse(Buffer, FT_RID, SourceAliasID, SRC_SEND_RID, STATE_NMRABUS_RESPONSE_SEND_AMD);
        STATE_NMRABUS_RESPONSE_SEND_AMD                    : HandleCANLayerSimpleResponse(Buffer, FT_AMD, SourceAliasID, SRC_SEND_AMD, STATE_NMRABUS_RESPONSE_SEND_VERIFIED_NODE);
        STATE_NMRABUS_RESPONSE_SEND_VERIFIED_NODE          : HandleNMRAnetLayerSimpleResponse(Buffer, FT_VERIFIED_NODE_ID_NUMBER, SourceAliasID, SRC_SEND_VERIFIED_NODE, STATE_NMRABUS_RESPONSE_SEND_PROTOCOL_SUPPORT);
        STATE_NMRABUS_RESPONSE_SEND_PROTOCOL_SUPPORT       : HandleNMRAnetLayerComplexResponse(Buffer, FT_PROTOCOL_SUPPORT_RESPONSE, SourceAliasID, CRC_SEND_PROTOCOL_SUPPORT, STATE_NMRABUS_RESPONSE_SEND_CONSUMER_IDENTIFIED);                           // Simple Response
        STATE_NMRABUS_RESPONSE_SEND_CONSUMER_IDENTIFIED    : HandleNMRAnetLayerComplexResponse(Buffer, FT_CONSUMER_IDENTIFIED, SourceAliasID, CRC_SEND_CONSUMER_IDENTIFIED, STATE_NMRABUS_RESPONSE_SEND_PRODUCER_IDENTIFIED);
        STATE_NMRABUS_RESPONSE_SEND_PRODUCER_IDENTIFIED    : begin 
                                                               HandleNMRAnetLayerComplexResponse(Buffer, FT_PRODUCER_IDENTIFIED, SourceAliasID, CRC_SEND_PRODUCER_IDENTIFIED, STATE_NMRABUS_RESPONSE_SEND_ALL_CONSUMER_PRODUCERS);
                                                               NMRABus.Responses.Tag := 0;   // Get ready for next state
                                                              end;
        STATE_NMRABUS_RESPONSE_SEND_ALL_CONSUMER_PRODUCERS : HandleNMRALayerSimpleSendAllConsumerProducer(Buffer, SourceAliasID, STATE_NMRABUS_RESPOND_OPTIONAL_INTERACTION_REJECTED);
        STATE_NMRABUS_RESPOND_OPTIONAL_INTERACTION_REJECTED: HandleNMRAnetLayerComplexResponse(Buffer, FT_OPTIONAL_INTERACTION_REJECTED, SourceAliasID, CRC_SEND_OPTIONAL_INTERACTION_REJECTED, STATE_NMRABUS_DATAGRAM_RECEIVED_OK);
        // These responses do NOT need a predefined response message sent
        STATE_NMRABUS_DATAGRAM_RECEIVED_OK                 : DispatchDatagramResponse(CRC_DATAGRAM_RECEIVED_OK, STATE_NMRABUS_DATAGRAM_REJECTED);
        STATE_NMRABUS_DATAGRAM_REJECTED                    : DispatchDatagramResponse(CRC_DATAGRAM_REJECTED, STATE_NMRABUS_RESPONSE_CONSUMER_IDENTIFIED);
        STATE_NMRABUS_RESPONSE_CONSUMER_IDENTIFIED         : DispatchMessageResponse(CRC_CONSUMER_IDENTIFIED, STATE_NMRABUS_RESPONSE_PRODUCER_IDENTIFIED);
        STATE_NMRABUS_RESPONSE_PRODUCER_IDENTIFIED         : DispatchMessageResponse(CRC_PRODUCER_IDENTIFIED, STATE_NMRABUS_RESPONSE_AMR);
        STATE_NMRABUS_RESPONSE_AMR                         : DispatchMessageResponse(CRC_AMR, STATE_NMRABUS_RESPONSE_AMD);
        STATE_NMRABUS_RESPONSE_AMD                         : DispatchMessageResponse(CRC_AMD, STATE_NMRABUS_RESPONSE_PC_EVENT_REPORT);
        STATE_NMRABUS_RESPONSE_PC_EVENT_REPORT             : DispatchMessageResponse(CRC_PC_EVENT_REPORT, STATE_NMRABUS_VERIFIED_NODE_ID);
        STATE_NMRABUS_VERIFIED_NODE_ID                     : DispatchMessageResponse(CRC_VERIFIED_NODE_ID, STATE_NMRABUS_RESPONSE_SEND_RID)
      else
        NMRABus.Responses.iState := STATE_NMRABUS_RESPONSE_SEND_RID;
      end;
    end
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Process
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************

procedure NMRAnetStateMachine_Process;
var
  Buffer: TCANBuffer;     
  VariableField: DWord;
begin
  case NMRABus.iState of
    STATE_NMRABUS_START :
      begin
        NMRABus.State := BS_INHIBITED or BS_UNITIALIZED;
        FlushLists;
        while CAN_Engine.State and CES_TRANSMITTING <> 0 do;                             // Wait for the last transmited packet
        NMRABus.iState := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_GENERATE_NODE_ALIAS :
      begin
        NMRABus.Node.AliasID := NMRAnetUtilities_CreateAliasID(NMRABus.Node.Seed, False);
        NMRABus.Responses.iCID := 0;
        NMRABus.iState := STATE_NMRABUS_TRANSMIT_CID;
      end;
    STATE_RANDOM_NUMBER_GENERATOR :
      begin
        NMRAnetUtilities_PsudoRandomNumberGeneratorOnSeed(NMRABus.Node.Seed);
        NMRABus.iState := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_TRANSMIT_CID :
      begin
        case NMRABus.Responses.iCID of
          0 : VariableField := FT_CID0;   // Queue up
          1 : VariableField := FT_CID1;
          2 : VariableField := FT_CID2;
          3 : VariableField := FT_CID3;
        end;
        if TryTransmitCANLayerMsg(VariableField, NMRABus.Node.AliasID, @Buffer) then
          NMRABus.iState := STATE_NMRABUS_NEXT_CDI;
      end;
    STATE_NMRABUS_NEXT_CDI :
      begin
        if NMRABus.Responses.iCID < 3 then
        begin
          Inc(NMRABus.Responses.iCID);
          NMRABus.iState := STATE_NMRABUS_TRANSMIT_CID
        end else 
        begin
          if CAN_Engine.State and CES_TRANSMITTING = 0 then     // Wait until the transmission is complete before waiting the 200ms
          begin
            NMRABus.iState := STATE_NMRABUS_WAITSTATE;
            NMRABus.LoginTimeCount := 0;
          end
        end
      end;
    STATE_NMRABUS_WAITSTATE :
      begin
        if NMRABus.LoginTimeCount > MAX_BUS_LOGIN_TIMEOUT then
          NMRABus.iState := STATE_NMRABUS_SEND_LOGIN_RID;
      end;
    STATE_NMRABUS_SEND_LOGIN_RID :
      begin
        if not DuplicateDetected(SRC_DUPLICATE_ALIAS, STATE_RANDOM_NUMBER_GENERATOR) then
          if TryTransmitCANLayerMsg(FT_RID, NMRABus.Node.AliasID, @Buffer) then
            NMRABus.iState := STATE_NMRABUS_SEND_LOGIN_AMD;
      end;
    STATE_NMRABUS_SEND_LOGIN_AMD :
      begin
        if not DuplicateDetected(SRC_DUPLICATE_ALIAS, STATE_RANDOM_NUMBER_GENERATOR) then
          if TryTransmitCANLayerMsg(FT_AMD, NMRABus.Node.AliasID, @Buffer) then
          begin
            NMRABus.State := NMRABus.State or BS_PERMITED and not BS_INHIBITED;
            NMRABus.iState := STATE_NMRABUS_INITIALIZED
          end
      end;
    STATE_NMRABUS_INITIALIZED :
      begin
        if not DuplicateDetected(SRC_DUPLICATE_ALIAS, STATE_RANDOM_NUMBER_GENERATOR) then
          if TryTransmitNMRABusLayerMsg(@Buffer, FT_INITIALIZATION_COMPLETE, 0, NMRABus.Node.AliasID, 0, nil) then
          begin
            NMRABus.iState := STATE_NMRABUS_LOGIN_IDENTIFY_EVENTS;
            NMRABus.State := NMRABus.State or BS_INITIALIZED and not BS_UNITIALIZED
          end
      end;
    STATE_NMRABUS_LOGIN_IDENTIFY_EVENTS :
      begin
        LockCANInterrupt;
        NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRC_ALL_CONSUMER_PRODUCER_IDENTIFIED;
        UnLockCANInterrupt;
        NMRABus.iState := STATE_NMRABUS_PERMITTED;
      end;
    STATE_NMRABUS_PERMITTED :
      begin
        Responses_Process(@Buffer, NMRABus.Node.AliasID);                       // Handle auto responses to CAN/NMRAnet messages coming in
        NMRAnetDatagrams_ProcessReceive;                                        // Handle Datagrams coming in
        NMRAnetDatagrams_ProcessTransmit(NMRABus.Node.AliasID);                 // Handle Datagrams going out
        NMRAnetConfigurationProtocol_Process;
      end;
    STATE_NMRABUS_INHIBITED :
      begin
        if TryTransmitCANLayerMsg(FT_AMR, NMRABus.Node.AliasID, @Buffer) then
        begin
          FlushLists;
          FlushResponses;
          NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_RANDOM_NUMBER_GENERATOR;
        end
      end;
    STATE_NMRABUS_DUPLICATE_FULL_ID :
      begin
        if TryTransmitCANLayerMsg(FT_AMR, NMRABus.Node.AliasID, @Buffer) then
        begin
          FlushLists;
          FlushResponses;
          NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_NMRABUS_TAKE_OFFLINE
        end
      end;
    STATE_NMRABUS_TAKE_OFFLINE :
      begin
    //    if TryTransmitNMRABusLayerMsg(PCER_DUPLICATE_ID..., @Buffer) then
    //    begin
    //      NMRABus.State := NMRABus.State or BS_INHIBITED and not BS_PERMITED;
          NMRABus.iState := STATE_NMRABUS_OFFLINE
    //    end
      end;
    STATE_NMRABUS_OFFLINE :
      begin
        // Done until reboot
      end
  else
    NMRABus.iState := STATE_NMRABUS_START;
  end
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_Disconnect;
begin
  NMRABus.iState := STATE_NMRABUS_INHIBITED
end;

end.