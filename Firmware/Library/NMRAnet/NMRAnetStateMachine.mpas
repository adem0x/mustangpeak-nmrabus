unit NMRAnetStateMachine;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRAnet StateMachine for the main loop in a program.
//
// ******************************************************************************

uses
  NMRAnetNodeDefines,
  NMRAnetEventDefines,
  NMRAnetAppDefines,
  NMRAnetDefines,
  NMRAnetUtilities,
  NMRAnetCANReceive,
  CANStorage,
  CANDefines,
  NMRAnetNode,
  NMRAnetDatagrams,
  NMRAnetBufferPools,
  NMRAnetBufferPoolsDefines,
  NMRAnetDatagramDefines,
  NMRAnetMemoryConfigurationDefines;

{$I Options.inc}

{.$DEFINE TRACE_DATAGRAM_SEND}
{.$DEFINE TRACE_BUFFER_ADDRESSES}
{.$DEFINE TRACE_MEM_CONFIG_STATEMACHINE}
{.$DEFINE TRACE_DATAGRAM_REPLY}
{$DEFINE TRACE_CONFIG_MEM_DECODE}
{.$DEFINE TRACE_NODE_STATEMACHINE}


  procedure NMRAnetStateMachine_Process(Node: PNMRAnetNode);
  procedure NMRAnetStateMachine_Disconnect(Node: PNMRAnetNode);
  procedure NMRAnetStateMachine_Initialize(PhysicalNodeID_HI, PhysicalNodeID_Lo: DWord);
  procedure NMRAnetStateMachine_InitializeNode(Node: PNMRAnetNode; NodeID_HI, NodeID_Lo: DWord);
  procedure NMRAnetStateMachine_100ms_Timer(Node: PNMRAnetNode);
  
  procedure NMRAnetStateMachine_InitializeDataBuffer(Buffer: PDataBuffer);
  
  // Receive Callback Helper Functions.  This could be done with separate callbacks for different message
  // types but that would require callback function variables that could get expensive in memory allocation so
  // here just look at the Response nCode and the CRC_xxx constants to decode what message was received for complex
  // and the SRC_xxx constants for the Simple callback
  procedure NMRAnetStateMachine_SetSimpleCallbackFunc(CallBack: PSimpleActionCallbackFunc);
  procedure NMRAnetStateMachine_SetComplexCallbackFunc(CallBack: PComplexActionCallbackFunc);
  
  // Send Helper Functions, send via Statemachine loops
  function NMRAnetStateMachine_TrySendIdentifyProducer(Node: PNMRAnetNode; EventID: PEventID): Boolean;
  function NMRAnetStateMachine_TrySendIdentifyConsumer(Node: PNMRAnetNode; EventID: PEventID): Boolean;
  function NMRAnetStateMachine_TrySendIdentifyEvents(Node: PNMRAnetNode): Boolean;
  function NMRAnetStateMachine_TrySendAliasMapEnquiry(Node: PNMRAnetNode): Boolean;
  function NMRAnetStateMachine_TrySendVerifyNodeID(Node: PNMRAnetNode; DestinationAliasID: Word): Boolean;
  function NMRAnetStateMachine_TrySendAbbreviatedCDI(Node: PNMRAnetNode; DestinationAliasID: Word): Boolean;
  function NMRAnetStateMachine_TrySendDatagram(Node: PNMRAnetNode; Datagram: PDatagramBuffer): Boolean;
  
  // defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure LockCANInterrupt; external;
  procedure UnLockCANInterrupt; external;
  
var
  TX_CANBufferList: TCANBufferList; external;
  TX_NMRAnetBufferList: TCANBufferList; external;
  
 function TryTransmitNMRABusLayerMsg(Node: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes): Boolean;  forward;

implementation

// *****************************************************************************
//  procedure NMRAnetStateMachine_TrySendAbbreviatedCDI
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetStateMachine_TrySendAbbreviatedCDI(Node: PNMRAnetNode; DestinationAliasID: Word): Boolean;
var
  Buffer: TCANBUffer;
  DataBytes: TCAN_DataBytes;
begin
  DataBytes[0] := MTI_EXTENSION_SIMPLENODE_IDENTIFY_INFO_REQUEST;
  Result := TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_PRODUCER_IDENDIFY, DestinationAliasID, 1, @DataBytes);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_TrySendIdentifyProducer
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetStateMachine_TrySendIdentifyProducer(Node: PNMRAnetNode; EventID: PEventID): Boolean;
var
  Buffer: TCANBUffer;
begin
  Result := TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_PRODUCER_IDENDIFY, 0, EVENT_ARRAY_LENGTH, PCAN_DataBytes( EventID));
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_TrySendIdentifyConsumer
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetStateMachine_TrySendIdentifyConsumer(Node: PNMRAnetNode; EventID: PEventID): Boolean;
var
  Buffer: TCANBUffer;
begin
  Result := TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_CONSUMER_IDENTIFY, 0, EVENT_ARRAY_LENGTH,  PCAN_DataBytes( EventID));
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_TrySendIdentifyEvents
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetStateMachine_TrySendIdentifyEvents(Node: PNMRAnetNode): Boolean;
var
  Buffer: TCANBUffer;
begin
  Result := TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_EVENTS_IDENTIFY, 0, 0, nil);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_TrySendAliasMapEnquiry
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetStateMachine_TrySendAliasMapEnquiry(Node: PNMRAnetNode): Boolean;
var
  Buffer: TCANBUffer;
begin
  Result := TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_AME, 0, 0, nil);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_TrySendVerifyNodeID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetStateMachine_TrySendVerifyNodeID(Node: PNMRAnetNode; DestinationAliasID: Word): Boolean;
var
  DataBytes: TCAN_DataBytes;
  Buffer: TCANBUffer;
begin
  if DestinationAliasID <> 0 then
  begin
    DataBytes[0] := MTI_EXTENSION_VERIFY_NODE_ID_NUMBER_DEST;
    Result := TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_VERIFY_NODE_ID_NUMBER_DEST, DestinationAliasID, 1, @DataBytes);
  end else
    Result := TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_VERIFY_NODE_ID_NUMBER, 0, 0, nil);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_TrySendDatagram
//     Parameters:
//     Returns:
//
//     Description:  Returns True when the Datagram is COMPLETLY sent
//                   Expects the iDataCount, DataBytes, Alias (destination) to be valid and Tag to be
//                   initaialized to 0
//
// *****************************************************************************
function NMRAnetStateMachine_TrySendDatagram(Node: PNMRAnetNode; Datagram: PDatagramBuffer): Boolean;
var
  i: Integer;
  DataBytes: TCAN_DataBytes;
  MTI: DWord;
  CANBuffer: TCANBuffer;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    if Datagram^.iByteCount <= 8 then                                           // Single Frame Datagram
    begin
      for i := 0 to Datagram^.iByteCount - 1 do
        DataBytes[i] := Datagram^.DataBytes[i];
      TryTransmitNMRABusLayerMsg(Node, @CANBuffer, MTI_DATAGRAM_ONLY_FRAME, Datagram^.Alias, Datagram^.iByteCount, @DataBytes);
      Result := True;
    end else
    begin                                                                       // Multi Frame Datagram
      if Datagram^.Tag = 0 then
      begin
     {$IFDEF TRACE_DATAGRAM_SEND}   UART1_Write_Text('MTI_DATAGRAM_FRAME_START_SEND'+LF);  {$ENDIF}
        MTI := MTI_DATAGRAM_FRAME_START
      end
      else
      if Datagram^.iByteCount - Datagram^.Tag > 8 then
      begin
        MTI := MTI_DATAGRAM_FRAME
     {$IFDEF TRACE_DATAGRAM_SEND}   ;UART1_Write_Text('MTI_DATAGRAM_FRAME_SEND'+LF); {$ENDIF}
      end
      else begin
     {$IFDEF TRACE_DATAGRAM_SEND}     UART1_Write_Text('MTI_DATAGRAM_FRAME_END_SEND'+LF);  {$ENDIF}
        MTI := MTI_DATAGRAM_FRAME_END;
        Result := True
      end;

      i := 0;
      while (Datagram^.Tag < Datagram^.iByteCount) and (i < 8) do
      begin
        DataBytes[i] := Datagram^.DataBytes[Datagram^.Tag];
        Inc(i);
        Inc(Datagram^.Tag);
      end;
      TryTransmitNMRABusLayerMsg(Node, @CANBuffer, MTI, Datagram^.Alias, i, @DataBytes);
    end;
  end
end;

// *****************************************************************************
//  procedure ReleaseBuffers
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure ReleaseBuffers(Node: PNMRAnetNode);
var
  BaseTemp: PBaseBuffer;
  DataTemp: PDataBuffer;
  DatagramTemp: PDatagramBuffer;
begin
  LockCANInterrupt;
  while Node^.BaseBuffers <> nil do
  begin
    BaseTemp := Node^.BaseBuffers;
    NMRAnetUtilities_BaseBufferUnLink(Node, BaseTemp);
    NMRAnetBufferPools_ReleaseBaseBuffer(BaseTemp);
  end;
  while Node^.DataBuffers <> nil do
  begin
    DataTemp := Node^.DataBuffers;
    NMRAnetUtilities_DataBufferUnLink(Node, DataTemp);
    NMRAnetBufferPools_ReleaseDataBuffer(DataTemp);
  end;
  while Node^.DatagramBuffers <> nil do
  begin
    DatagramTemp := Node^.DatagramBuffers;
    NMRAnetUtilities_DatagramBufferUnLink(Node, DatagramTemp);
    NMRAnetBufferPools_ReleaseDatagramBuffer(DatagramTemp);
  end;
  UnLockCANInterrupt;
end;

// *****************************************************************************
//  procedure FlushLists
//     Parameters:
//     Returns:
//
//     Description: Clears the lists of messages for the passed node
//
// *****************************************************************************
procedure FlushLists(Node: PNMRAnetNode);
begin

 //Need to only remove messages that match the passed Node!!!!!!!
 
  CANStorage_FlushList(@TX_CANBufferList);                                      // Flush any pending packets
  CANStorage_FlushList(@TX_NMRAnetBufferList);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the BufferArray
//              LasterBuffer   : Pointer to the last item in the BufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure NMRAnetStateMachine_InitializeList(ListPtr: PCANBufferList; BufferArrayPtr: PCANBufferArray; ListLength: Byte);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.Size := ListLength;
  ListPtr^.Head := @BufferArrayPtr^[0];
  ListPtr^.Tail := @BufferArrayPtr^[0];
  ListPtr^.Count := 0;
  ListPtr^.MaxCount := 0;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_SetSimpleCallbackFunc
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_SetSimpleCallbackFunc(CallBack: PSimpleActionCallbackFunc);
begin
  SimpleActionCallbackFunc := Callback;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_SetComplexCallbackFunc
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_SetComplexCallbackFunc(CallBack: PComplexActionCallbackFunc);
begin
  ComplexActionCallbackFunc := Callback;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_InitializeDataBuffer;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetStateMachine_InitializeDataBuffer(Buffer: PDataBuffer);
var
  i: Integer;
begin
  Buffer^.State := 0;
  Buffer^.mCode := 0;
  Buffer^.Alias := 0;
  Buffer^.Next := 0;
  Buffer^.Count := 0;
  Buffer^.RefCount := 0;
  Buffer^.StateMachine := 0;
  Buffer^.Tag := 0;
  for i := 0 to CAN_DATA_LEN - 1 do
    Buffer^.DataBytes[i] := 0;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_InitializeNode
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_InitializeNode(Node: PNMRAnetNode; NodeID_HI, NodeID_LO: DWord);
begin
  Node^.BaseBuffers := nil;
  Node^.DataBuffers := nil;
  Node^.DatagramBuffers := nil;
  Node^.State := 0;
  Node^.MsgFlags := 0;
  Node^.EventCounter := 0;
  if (NodeID_HI <> 0) and (NodeID_LO <> 0) then
  begin
    Node^.Node.ID[0] := NodeID_LO;
    Node^.Node.ID[1] := NodeID_HI;
    Node^.Node.Seed := Node^.Node.ID;
  end;
  Node^.iStateMachine := STATE_NMRABUS_START;
end;    

// *****************************************************************************
//  procedure NMRAnetStateMachine_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_Initialize(PhysicalNodeID_HI, PhysicalNodeID_Lo: DWord);
begin
  NMRAnetDatagrams_Initialize;
  NMRAnetCANReceive_Initialize;
  NMRAnetBufferPools_Initialize;
  NMRAnetNode_Initialize(PhysicalNodeID_HI, PhysicalNodeID_Lo);
  SimpleActionCallbackFunc := PSimpleActionCallbackFunc( nil);
  ComplexActionCallbackFunc := PComplexActionCallbackFunc( nil);
  NMRAnetStateMachine_InitializeList(@TX_CANBufferList, @TX_CANBuffer, TX_CAN_BUFFER_LEN);
  NMRAnetStateMachine_InitializeList(@TX_NMRAnetBufferList, @TX_NMRAnet_Buffer, TX_NMRANET_BUFFER_LEN);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_100ms_Timer;
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_100ms_Timer(Node: PNMRAnetNode);
begin
  Inc(Node^.Login.TimeCounter);
  NMRAnetDatagrams_100ms_TimeTick(Node);
end;

// *****************************************************************************
//  procedure TryTransmitCANLayerMsg
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function TryTransmitCANLayerMsg(Node: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_CANBufferList) then
  begin
    NMRAnetUtilities_CreateCANControlFramePacket(Node, Buffer, VariableField);
    if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True
    end
  end ;
end;

// *****************************************************************************
//  procedure TryTransmitNMRABusLayerMsg
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function TryTransmitNMRABusLayerMsg(Node: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    NMRAnetUtilities_CreateNMRABusMessagePacket(Node, Buffer, VariableField, DestinationAlias, DataCount, DataBytes);
    if CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True;
    end
  end
end;

// *****************************************************************************
//  procedure TransmitNMRABusLayerMsg
//     Parameters:
//     Returns:
//
//     Description: This assumes the caller has tested for room in the buffer
//
// *****************************************************************************
procedure TransmitNMRABusLayerMsg(Node: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes);
begin
  NMRAnetUtilities_CreateNMRABusMessagePacket(Node, Buffer, VariableField, DestinationAlias, DataCount, DataBytes);
  CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer);
  StartCANMessageEngine();
end;

// *****************************************************************************
//  procedure NMRABusBufferAvailable
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRABusBufferAvailable: Boolean;
begin
  Result := not CANStorage_ListFull(@TX_NMRAnetBufferList)
end;

// *****************************************************************************
//  procedure DecodeMemoryConfigurationReadWrite
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure DecodeMemoryConfigurationReadWrite(DataBytes: PCAN_DataBytes; var MemorySpace: Byte; var MemorySpaceOffset: DWord; var MemorySpaceCount: Short);
begin
  MemorySpaceCount := DataBytes^[6];
  case DataBytes^[1] and $03 of      // Strip off bottom two bits
    MCP_CDI            : MemorySpace := MSI_CDI;
    MCP_ALL            : MemorySpace := MSI_ALL;
    MCP_CONFIGURATION  : MemorySpace := MSI_CONFIG;
    MCP_NONE           : begin
                           MemorySpace := DataBytes^[6];
                           MemorySpaceCount := DataBytes^[7]       // Should not be larger than 64 bytes
                         end;
   end;
   MemorySpaceOffset := DWord( DataBytes^[2] shl 24) or DWord( DataBytes^[3] shl 16) or DWord( DataBytes^[4] shl 8) or DWord( DataBytes^[5]);
end;

// *****************************************************************************
//  procedure ProcessNode
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
  
procedure ProcessNode(Node: PNMRAnetNode; Buffer: PCANBuffer);
const
  ADDRESSED = True;
  NONADDRESSED = False;
  CRITICAL_MSG_MASK = MF_DUPLICATE_NODE_ID or MF_DUPLICATE_ALIAS or MF_DUPLICATE_ALIAS_RID;
  
type
  TByteArray = array[0..0] of Byte;                                             // Byte array of any length
  PByteArray = ^TByteArray;

var
  LocalMsgFlags: Byte;
  DataBytes: TCAN_DataBytes;
  i, j, MaxIndex: Integer;
  BaseBuffer, AllocatedBuffer: PBaseBuffer;
  DataBuffer: PDataBuffer;
  DatagramBuffer, TxDatagramBuffer: PDatagramBuffer;
  MemorySpace: Byte;
  MemorySpaceCount: Short;
  DatagramOffset: Byte;
  MemorySpaceOffset, MemorySpaceMax : DWord;
  AddressSpace: ^Byte;
  ByteArray: PByteArray;
  ErrorCode: Word;
begin
  LockCANInterrupt;                                                             // Don't let the interrupt change things while we are working on them.....
  
  begin
    LocalMsgFlags := Node^.MsgFlags;

    // The first thing to check is for duplicate Node ID's or Aliases and handle
    // them first and exclusively
    if LocalMsgFlags <> 0 then
    begin
      if LocalMsgFlags and CRITICAL_MSG_MASK <> 0 then                            // Subdivide to Critical vs. Noncritical messages
      begin
        // Critial Fault Messages
        if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_NODE_ID, True) then        // Jump Statemachine here
          Node^.iStateMachine := STATE_NMRABUS_DUPLICATE_FULL_ID
        else
        if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_ALIAS, True) then          // Jump Statemachine here
          Node^.iStateMachine := STATE_NMRABUS_INHIBITED
        else
        if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_ALIAS_RID, False) then
        begin
           if TryTransmitCANLayerMsg(Node, Buffer, MTI_RID) then
             NMRAnetNode_ClearMsgFlag(Node, MF_DUPLICATE_ALIAS_RID);
        end;
        UnLockCANInterrupt;
        Exit;                                                                     // Bad things happening, exit
      end;

      // Non Critical Fault Messages that require a response
      if NMRAnetNode_TestMsgFlags(Node, MF_ALIAS_MAP_ENQUIRY, False) then
      begin
         if TryTransmitCANLayerMsg(Node, Buffer, MTI_AMD) then                   // DataBytes get loaded automatically
           NMRAnetNode_ClearMsgFlag(Node, MF_ALIAS_MAP_ENQUIRY);
      end else
      if NMRAnetNode_TestMsgFlags(Node, MF_VERIFY_NODE_ID, False) then
      begin
        if NMRABusBufferAvailable then
        begin
          NMRAnetUtilities_LoadFramePacketDataWith48BitNodeID(Node, Buffer);
          TransmitNMRABusLayerMsg(Node, Buffer, MTI_VERIFIED_NODE_ID_NUMBER, 0, 6, @DataBytes);
          NMRAnetNode_ClearMsgFlag(Node, MF_VERIFY_NODE_ID);
        end;
      end else
      if NMRAnetNode_TestMsgFlags(Node, MF_IDENTIFY_ALL_EVENTS, False) then
      begin
        if not NMRAnetNode_TestStateFlag(Node, NS_ENUMERATING_EVENTS) then
        begin
          NMRAnetNode_SetStateFlag(Node, NS_ENUMERATING_EVENTS);                // Enumerating is just starting, kick it off
          NMRAnetNode_ClearMsgFlag(Node, MF_IDENTIFY_ALL_EVENTS);               // Allow another node to set the flag
          Node^.EventCounter := 0;
        end
      end
    end else
    begin
      BaseBuffer := NMRAnetUtilities_NextBaseBuffer(Node);
      if BaseBuffer <> nil then
      begin
        {$IFDEF TRACE_BUFFER_ADDRESSES}
        UART1_Write_Text('BaseBuffer Statemachine :');
        WordToHex(BaseBuffer, s1);
        UART1_Write_Text('$'+s1+LF);
        {$ENDIF}
        case BaseBuffer^.mCode of
          BMC_DATAGRAM_OUT_OF_ORDER  :        begin
                                                if NMRABusBufferAvailable then
                                                begin
                                                  DataBytes[0] := MTI_EXTENSION_DATAGRAM_REJECTED;
                                                  DataBytes[1] := DATAGRAM_RESULT_REJECTED_OUT_OF_ORDER[0];
                                                  DataBytes[2] := DATAGRAM_RESULT_REJECTED_OUT_OF_ORDER[1];
                                                  TransmitNMRABusLayerMsg(Node, Buffer, MTI_DATAGRAM_REPLY, BaseBuffer^.Alias, 3, @DataBytes);
                                                  NMRAnetUtilities_BaseBufferUnLink(Node, BaseBuffer);
                                                  NMRAnetBufferPools_ReleaseBaseBuffer(BaseBuffer);
                                                  {$IFDEF TRACE_DATAGRAM_REPLY}  UART1_Write_Text('DATAGRAM_RESULT_REJECTED_OUT_OF_ORDER'+LF); {$ENDIF}
                                                end
                                              end;
          BMC_DATAGRAM_BUFFER_FULL   :        begin
                                                if NMRABusBufferAvailable then
                                                begin
                                                  DataBytes[0] := MTI_EXTENSION_DATAGRAM_REJECTED;
                                                  DataBytes[1] := DATAGRAM_RESULT_REJECTED_BUFFER_FULL[0];
                                                  DataBytes[2] := DATAGRAM_RESULT_REJECTED_BUFFER_FULL[1];
                                                  TransmitNMRABusLayerMsg(Node, Buffer, MTI_DATAGRAM_REPLY, BaseBuffer^.Alias, 3, @DataBytes);
                                                  NMRAnetUtilities_BaseBufferUnLink(Node, BaseBuffer);
                                                  NMRAnetBufferPools_ReleaseBaseBuffer(BaseBuffer);
                                                  {$IFDEF TRACE_DATAGRAM_REPLY}  UART1_Write_Text('DATAGRAM_RESULT_REJECTED_BUFFER_FULL'+LF); {$ENDIF}
                                                end
                                              end;
          BMC_DATAGRAM_NOT_ACCEPTED  :        begin
                                                if NMRABusBufferAvailable then
                                                begin
                                                  DataBytes[0] := MTI_EXTENSION_DATAGRAM_REJECTED;
                                                  DataBytes[1] := DATAGRAM_RESULT_REJECTED_SOURCE_DATAGRAMS_NOT_ACCEPTED[0];
                                                  DataBytes[2] := DATAGRAM_RESULT_REJECTED_SOURCE_DATAGRAMS_NOT_ACCEPTED[1];
                                                  TransmitNMRABusLayerMsg(Node, Buffer, MTI_DATAGRAM_REPLY, BaseBuffer^.Alias, 3, @DataBytes);
                                                  NMRAnetUtilities_BaseBufferUnLink(Node, BaseBuffer);
                                                  NMRAnetBufferPools_ReleaseBaseBuffer(BaseBuffer);
                                                  {$IFDEF TRACE_DATAGRAM_REPLY}  UART1_Write_Text('DATAGRAM_RESULT_REJECTED_SOURCE_DATAGRAMS_NOT_ACCEPTED'+LF); {$ENDIF}
                                                end
                                              end;
          BMC_DATAGRAM_OKAY          :        begin
                                                if NMRABusBufferAvailable then
                                                begin
                                                  DataBytes[0] := MTI_EXTENSION_DATAGRAM_RECIEVED_OK;
                                                  TransmitNMRABusLayerMsg(Node, Buffer, MTI_DATAGRAM_REPLY, BaseBuffer^.Alias, 1, @DataBytes);
                                                  NMRAnetUtilities_BaseBufferUnLink(Node, BaseBuffer);
                                                  NMRAnetBufferPools_ReleaseBaseBuffer(BaseBuffer);
                                                  {$IFDEF TRACE_DATAGRAM_REPLY}  UART1_Write_Text('MTI_EXTENSION_DATAGRAM_RECIEVED_OK'+LF); {$ENDIF}
                                                end
                                              end;
          BMC_PROTOCOL_SUPPORT_QUERY :        begin
                                                if NMRABusBufferAvailable then
                                                begin
                                                  NMRAnetUtilities_ZeroCANData(DataBytes);
                                                  DataBytes[0] := $2F;
                                                  for i := 0 to LEN_PIV_PROTOCOL-1 do
                                                    for j := 0 to PIV_SUPPORTED_PROTOCOL_COUNT - 1 do
                                                      DataBytes[i+1] := DataBytes[i+1] or PIV_SUPPORTED_PROTOCOLS[j][i];
                                                  TransmitNMRABusLayerMsg(Node, Buffer, MTI_PROTOCOL_SUPPORT_REPLY, BaseBuffer^.Alias, 6, @DataBytes);
                                                  NMRAnetUtilities_BaseBufferUnLink(Node, BaseBuffer);
                                                  NMRAnetBufferPools_ReleaseBaseBuffer(BaseBuffer);
                                                end;
                                              end;
          BMC_UNKNOWN_ADDRESSED_MTI :         begin
                                                if NMRABusBufferAvailable then
                                                begin
                                                  DataBytes[0] := MTI_EXTENSION_OPTIONAL_INTERACTION_REJECTED;
                                                  TransmitNMRABusLayerMsg(Node, Buffer, MTI_OPTIONAL_INTERACTION_REJECTED, BaseBuffer^.Alias, 1, @DataBytes);
                                                  NMRAnetUtilities_BaseBufferUnLink(Node, BaseBuffer);
                                                  NMRAnetBufferPools_ReleaseBaseBuffer(BaseBuffer);
                                                end;
                                              end;
          BMC_SIMPLE_NODE_INFO_REQEUST :      begin
                                                if NMRABusBufferAvailable then
                                                begin
                                                  i := 0;
                                                  DataBytes[i] := MTI_EXTENSION_SIMPLENODE_IDENTIFY_INFO_REPLY;
                                                  Inc(i);

                                                  while (BaseBuffer^.StateMachine <> STATE_ACDI_DONE) and (i < 8) do
                                                  begin
                                                    case BaseBuffer^.StateMachine of
                                                      STATE_ACDI_MFG_VERSION  : begin
                                                                                 if Node^.State and NS_VIRTUAL <> 0 then
                                                                                   DataBytes[i] := ACDI_MFG_VERSION_VNODE
                                                                                 else
                                                                                   DataBytes[i] := ACDI_MFG_VERSION;
                                                                                 Inc(i);
                                                                                 BaseBuffer^.Tag := 0;
                                                                                 BaseBuffer^.StateMachine := STATE_ACDI_MFG_INFO;
                                                                                end;
                                                      STATE_ACDI_MFG_INFO    :  begin
                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                  begin   
                                                                                    if BaseBuffer^.Tag < MAX_ACDI_MFG_ARRAY_VNODE then                  STILL SEEMS TO BE ISSUE HERE>>>>
                                                                                    begin
                                                                                      DataBytes[i] := ACDI_MFG_STRINGS_VNODE[BaseBuffer^.Tag];
                                                                                      Inc(BaseBuffer^.Tag);
                                                                                      Inc(i);
                                                                                    end else
                                                                                      BaseBuffer^.StateMachine := STATE_ACDI_USER_VERSION;
                                                                                  end else
                                                                                  begin
                                                                                    if BaseBuffer^.Tag < MAX_ACDI_MFG_ARRAY then
                                                                                    begin
                                                                                      DataBytes[i] := ACDI_MFG_STRINGS[BaseBuffer^.Tag];
                                                                                      Inc(BaseBuffer^.Tag);
                                                                                      Inc(i);
                                                                                    end else
                                                                                      BaseBuffer^.StateMachine := STATE_ACDI_USER_VERSION;
                                                                                  end;
                                                                                end;
                                                      STATE_ACDI_USER_VERSION : begin
                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                   DataBytes[i] := ACDI_USER_VERSION_VNODE
                                                                                 else
                                                                                   DataBytes[i] := ACDI_USER_VERSION;
                                                                                  Inc(i);
                                                                                  BaseBuffer^.StateMachine := STATE_ACDI_USER_NAME;
                                                                                  BaseBuffer^.Tag := 0;
                                                                                end;
                                                      STATE_ACDI_USER_NAME    : begin
                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                  begin
                                                                                    if BaseBuffer^.Tag < MAX_USER_NAME then
                                                                                    begin
                                                                                      DataBytes[i] :=  CONFIG_DATA_VNODE[BaseBuffer^.Tag];
                                                                                      if CONFIG_DATA_VNODE[BaseBuffer^.Tag] = #0 then
                                                                                        BaseBuffer^.StateMachine := STATE_ACDI_START_DESC;
                                                                                    end else
                                                                                      BaseBuffer^.StateMachine := STATE_ACDI_START_DESC;
                                                                                  end else
                                                                                  begin
                                                                                    if BaseBuffer^.Tag < MAX_USER_NAME then
                                                                                    begin
                                                                                      DataBytes[i] := CONFIG_DATA[BaseBuffer^.Tag];
                                                                                      if CONFIG_DATA[BaseBuffer^.Tag] = #0 then
                                                                                        BaseBuffer^.StateMachine := STATE_ACDI_START_DESC;
                                                                                    end else
                                                                                      BaseBuffer^.StateMachine := STATE_ACDI_START_DESC;
                                                                                  end;
                                                                                  Inc(BaseBuffer^.Tag);
                                                                                  Inc(i);
                                                                                end;
                                                      STATE_ACDI_START_DESC   : begin
                                                                                  BaseBuffer^.Tag := MAX_USER_NAME;
                                                                                  BaseBuffer^.StateMachine := STATE_ACDI_USER_DESC;
                                                                                end;
                                                      STATE_ACDI_USER_DESC    : begin
                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                  begin
                                                                                    if BaseBuffer^.Tag < MAX_USER_DESC then
                                                                                    begin
                                                                                      DataBytes[i] :=  CONFIG_DATA_VNODE[BaseBuffer^.Tag];
                                                                                      if CONFIG_DATA_VNODE[BaseBuffer^.Tag] = #0 then
                                                                                        BaseBuffer^.StateMachine := STATE_ACDI_DONE;
                                                                                    end else
                                                                                      BaseBuffer^.StateMachine := STATE_ACDI_DONE;
                                                                                  end else
                                                                                  begin
                                                                                    if BaseBuffer^.Tag < MAX_USER_DESC - 1 then
                                                                                    begin
                                                                                      DataBytes[i] := CONFIG_DATA[BaseBuffer^.Tag];
                                                                                      if CONFIG_DATA[BaseBuffer^.Tag] = #0 then
                                                                                        BaseBuffer^.StateMachine := STATE_ACDI_DONE;
                                                                                    end else
                                                                                      BaseBuffer^.StateMachine := STATE_ACDI_DONE;
                                                                                  end;
                                                                                  Inc(BaseBuffer^.Tag);
                                                                                  Inc(i);
                                                                                end;
                                                      STATE_ACDI_DONE         : begin
                                                                                end;
                                                    end;
                                                  end;
                                                  TransmitNMRABusLayerMsg(Node, Buffer, MTI_SIMPLE_NODE_IDENTIFY_INFO, BaseBuffer^.Alias, i, @DataBytes);

                                                  if BaseBuffer^.StateMachine >= STATE_ACDI_DONE then
                                                  begin
                                                    NMRAnetUtilities_BaseBufferUnLink(Node, BaseBuffer);
                                                    NMRAnetBufferPools_ReleaseBaseBuffer(BaseBuffer);
                                                  end;
                                                end
                                              end;
        end;
      end;
      
      DataBuffer := NMRAnetUtilities_NextDataBuffer(Node);
      if DataBuffer <> nil then
      begin   
        {$IFDEF TRACE_BUFFER_ADDRESSES}
        UART1_Write_Text('DataBuffer Statemachine :');
        WordToHex(DataBuffer, s1);
        UART1_Write_Text('$'+s1+LF);
        {$ENDIF}
        
        case DataBuffer^.mCode of
          BMC_PRODUCER_IDENTIFY :             begin   // Tested to ensure we need to send this when the message came in
                                                if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_PRODUCER_IDENTIFIED_UNKNOWN, 0, DataBuffer^.Count, @DataBuffer^.DataBytes) then
                                                begin
                                                  NMRAnetUtilities_DataBufferUnLink(Node, DataBuffer);
                                                  NMRAnetBufferPools_ReleaseDataBuffer(DataBuffer);
                                                end;
                                              end;
          BMC_CONSUMER_IDENTIFY :             begin   // Tested to ensure we need to send this when the message came in
                                                if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_CONSUMER_IDENTIFIED_UNKNOWN, 0, DataBuffer^.Count, @DataBuffer^.DataBytes) then
                                                begin
                                                  NMRAnetUtilities_DataBufferUnLink(Node, DataBuffer);
                                                  NMRAnetBufferPools_ReleaseDataBuffer(DataBuffer);
                                                end;
                                              end;
          BMC_EVENT_LEARN :                   begin
                                              end;
        end; // case
      end;
      
      DatagramBuffer := NMRAnetUtilities_NextDatagramBuffer(Node);
      if DatagramBuffer <> nil then
      begin
        {$IFDEF TRACE_BUFFER_ADDRESSES}
        UART1_Write_Text('DatagramBuffer Statemachine :');
        WordToHex(DatagramBuffer, s1);
        UART1_Write_Text('$'+s1+LF);
        {$ENDIF}
        case DatagramBuffer^.mCode of
          BMC_DATAGRAM :  begin
                            case DatagramBuffer^.DataBytes[0] of
                              DATAGRAM_TYPE_MEMORY_CONFIGURATION : begin
                                                                     case DatagramBuffer^.StateMachine of
                                                                       STATE_MEM_CONFIG_SEND_REPLY    : begin  {$IFDEF TRACE_MEM_CONFIG_STATEMACHINE}  UART1_Write_Text('STATE_MEM_CONFIG_SEND_REPLY'+LF); {$ENDIF}
                                                                                                           if DatagramBuffer^.DataBytes[1] and $C0 = MCP_WRITE then
                                                                                                             DatagramBuffer^.Statemachine := STATE_MEM_CONFIG_WRITE
                                                                                                           else begin
                                                                                                             DataBytes[0] := MTI_EXTENSION_DATAGRAM_RECIEVED_OK;
                                                                                                             if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_DATAGRAM_REPLY, DatagramBuffer^.Alias, 1, @DataBytes) then
                                                                                                               DatagramBuffer^.Statemachine := STATE_MEM_CONFIG_LOAD_DATAGRAM
                                                                                                           end
                                                                                                         end;
                                                                       STATE_MEM_CONFIG_LOAD_DATAGRAM : begin  {$IFDEF TRACE_MEM_CONFIG_STATEMACHINE}  UART1_Write_Text('STATE_MEM_CONFIG_LOAD_DATAGRAM'+LF);  {$ENDIF}
                                                                                                          if DatagramBuffer^.DataBytes[1] and $C0 = MCP_OPERATION then
                                                                                                          begin
                                                                                                            case DatagramBuffer^.DataBytes[1] of      // Mask off the upper 2 bits
                                                                                                              MCP_OP_GET_CONFIG         : begin
                                                                                                                                            DatagramBuffer^.DataBytes[0] := DATAGRAM_TYPE_MEMORY_CONFIGURATION;
                                                                                                                                            DatagramBuffer^.DataBytes[1] := MCP_OP_GET_CONFIG_REPLY;
                                                                                                                                            DatagramBuffer^.DataBytes[2] := Hi( MEMORY_CONFIG_OPTIONS.MemoryConfigOptions);
                                                                                                                                            DatagramBuffer^.DataBytes[3] := Lo( MEMORY_CONFIG_OPTIONS.MemoryConfigOptions);
                                                                                                                                            DatagramBuffer^.DataBytes[4] := MEMORY_CONFIG_OPTIONS.MemoryConfigWriteLength;
                                                                                                                                            DatagramBuffer^.DataBytes[5] := MEMORY_CONFIG_OPTIONS.MemoryConfigHighestSpace;
                                                                                                                                            DatagramBuffer^.DataBytes[6] := MEMORY_CONFIG_OPTIONS.MemoryConfigLowestSpace;
                                                                                                                                            DatagramBuffer^.iByteCount := 7;
                                                                                                                                          end;
                                                                                                              MCP_OP_GET_ADD_SPACE_INFO : begin
                                                                                                                                            DatagramBuffer^.DataBytes[0] := DATAGRAM_TYPE_MEMORY_CONFIGURATION;
                                                                                                                                            DatagramBuffer^.DataBytes[1] := MCP_OP_GET_ADD_SPACE_INFO_REPLY or MCP_OP_GET_ADD_SPACE_INFO_REPLY_PRESENT;  // assumption is we support ALL Address Spaces
                                                                                                                                            DatagramBuffer^.DataBytes[2] := DatagramBuffer^.DataBytes[2];
                                                                                                                                             // I am not supporting the ability to return anything but a $0 for the lower address so we only deal with offsets from zero in these calls
                                                                                                                                            case DatagramBuffer^.DataBytes[2] of
                                                                                                                                              MSI_CDI       : MemorySpaceOffset := MAX_CDI_ARRAY;
                                                                                                                                              MSI_ALL       : MemorySpaceOffset := ALL_MAP.HighMem;
                                                                                                                                              MSI_CONFIG    : MemorySpaceOffset := MAX_USER_NAME+MAX_USER_DESC;
                                                                                                                                              MSI_ACDI_MFG  : MemorySpaceOffset := 1 + CDI_MAP.Manufacturer.Length+CDI_MAP.ManufacturerModel.Length+CDI_MAP.ManufacturerHWVersion.Length+CDI_MAP.ManufacturerSWVersion.Length;
                                                                                                                                              MSI_ACDI_USER : MemorySpaceOffset := 1 + MAX_USER_NAME+MAX_USER_DESC;  // PLUS 1 HERE???????????????????????????
                                                                                                                                            end;
                                                                                                                                            DatagramBuffer^.DataBytes[3] := (DWord(MemorySpaceOffset) shr 24) and $000000FF;
                                                                                                                                            DatagramBuffer^.DataBytes[4] := (DWord(MemorySpaceOffset) shr 16) and $000000FF;
                                                                                                                                            DatagramBuffer^.DataBytes[5] := (DWord(MemorySpaceOffset) shr 8) and $000000FF;
                                                                                                                                            DatagramBuffer^.DataBytes[6] := DWord(MemorySpaceOffset) and $000000FF;
                                                                                                                                            case DatagramBuffer^.DataBytes[2] of
                                                                                                                                              MSI_CONFIG, MSI_ACDI_MFG, MSI_ACDI_USER : DatagramBuffer^.DataBytes[7] := $00        // Read/Write Only
                                                                                                                                            else
                                                                                                                                              DatagramBuffer^.DataBytes[7] := $01;                                                 // Read Only
                                                                                                                                            end;
                                                                                                                                           DatagramBuffer^.iByteCount := 8;
                                                                                                                                          end;
                                                                                                              MCP_OP_LOCK               : begin
                                                                                                                                            DatagramBuffer^.Statemachine := STATE_MEM_CONFIG_WAITFOR_REPLY
                                                                                                                                           end;
                                                                                                              MCP_OP_GET_UNIQUEID       : begin
                                                                                                                                            DatagramBuffer^.Statemachine := STATE_MEM_CONFIG_WAITFOR_REPLY
                                                                                                                                          end;
                                                                                                              MCP_OP_FREEZE             : begin
                                                                                                                                            DatagramBuffer^.Statemachine := STATE_MEM_CONFIG_WAITFOR_REPLY
                                                                                                                                          end;
                                                                                                              MCP_OP_INDICATE           : begin
                                                                                                                                            DatagramBuffer^.Statemachine := STATE_MEM_CONFIG_WAITFOR_REPLY
                                                                                                                                          end;
                                                                                                              MCP_OP_RESETS             : begin
                                                                                                                                             DatagramBuffer^.Statemachine := STATE_MEM_CONFIG_WAITFOR_REPLY
                                                                                                                                          end;
                                                                                                            end // case [Operation Type]
                                                                                                          end else
                                                                                                          begin    // Is a Read or Write
                                                                                                            DecodeMemoryConfigurationReadWrite(@DatagramBuffer^.DataBytes, MemorySpace, MemorySpaceOffset, MemorySpaceCount);

                                                                                                            {$IFDEF TRACE_CONFIG_MEM_DECODE}
                                                                                                            IntToStr(MemorySpace, s1);
                                                                                                            UART1_Write_Text('MemorySpace= '+s1+LF);
                                                                                                            IntToStr(MemorySpaceOffset, s1);
                                                                                                            UART1_Write_Text('MemorySpaceOffset= '+s1+LF);
                                                                                                            IntToStr(MemorySpaceCount, s1);
                                                                                                            UART1_Write_Text('MemorySpaceCount= '+s1+LF);
                                                                                                            {$ENDIF}
                                                                                                            
                                                                                                            case MemorySpace of
                                                                                                              MSI_CDI         : begin
                                                                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                                                                    MemorySpaceMax := MAX_CDI_ARRAY_VNODE
                                                                                                                                  else
                                                                                                                                    MemorySpaceMax := MAX_CDI_ARRAY
                                                                                                                                end;
                                                                                                              MSI_ALL         : MemorySpaceMax := ALL_MAP.HighMem;
                                                                                                              MSI_CONFIG      : begin
                                                                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                                                                    MemorySpaceMax := MAX_CONFIG_DATA_VNODE
                                                                                                                                  else
                                                                                                                                    MemorySpaceMax := MAX_CONFIG_DATA
                                                                                                                                end;
                                                                                                              MSI_ACDI_MFG    : begin
                                                                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                                                                    MemorySpaceMax := MAX_ACDI_MFG_ARRAY_VNODE + 1 // for the Version ID Byte
                                                                                                                                  else
                                                                                                                                    MemorySpaceMax := MAX_ACDI_MFG_ARRAY + 1 // for the Version ID Byte
                                                                                                                                end;
                                                                                                              MSI_ACDI_USER   : begin
                                                                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                                                                    MemorySpaceMax := MAX_CONFIG_DATA_VNODE + 1 // for the Version ID Byte
                                                                                                                                  else
                                                                                                                                    MemorySpaceMax := MAX_CONFIG_DATA + 1 // for the Version ID Byte
                                                                                                                                end
                                                                                                            else
                                                                                                              MemorySpaceMax := 0;
                                                                                                            end;
                                                                                                            if MemorySpaceOffset >= MemorySpaceMax then
                                                                                                            begin
                                                                                                               MemorySpaceOffset := 0;
                                                                                                               MemorySpaceCount := 0;
                                                                                                            end else
                                                                                                            begin
                                                                                                              if MemorySpaceOffset + MemorySpaceCount > MemorySpaceMax then
                                                                                                                MemorySpaceCount := MemorySpaceMax - MemorySpaceOffset
                                                                                                            end;
                                                                                                            // Now we have all we need:
                                                                                                            //    MemorySpaceOffset = Offset from start of Memory Space use as the starting position for copying/writing memory
                                                                                                            //    MemorySpaceCount = Number of bytes to copy, corrected for possible overrunning the end of valid Memory Space

                                                                                                            if DatagramBuffer^.DataBytes[1] and $C0 = MCP_WRITE then         // It is a Write
                                                                                                            begin


                                                                                                            end else
                                                                                                            if DatagramBuffer^.DataBytes[1] and $C0 = MCP_READ then          // It is a Read
                                                                                                            begin
                                                                                                              // Reuse the Datagram and the first 6 Bytes.  The beauty here is is the defines for this allow it to be a reply and still correctly enter this statemachine!  Thanks Bob!
                                                                                                              DatagramBuffer^.DataBytes[1] := MCP_READ_DATAGRAM_REPLY or DatagramBuffer^.DataBytes[1];
                                                                                                              DatagramOffset := 6;
                                                                                                              case MemorySpace of
                                                                                                                MSI_CDI       : begin
                                                                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                                                                  begin
                                                                                                                                    for i := 0 to MemorySpaceCount - 1 do
                                                                                                                                      DatagramBuffer^.DataBytes[i+DatagramOffset] := CDI_ARRAY_VNODE[i+MemorySpaceOffset]
                                                                                                                                  end else
                                                                                                                                  begin
                                                                                                                                    for i := 0 to MemorySpaceCount - 1 do
                                                                                                                                      DatagramBuffer^.DataBytes[i+DatagramOffset] := CDI_ARRAY[i+MemorySpaceOffset]
                                                                                                                                  end
                                                                                                                                end;
                                                                                                                MSI_ALL       : begin
                                                                                                                                  ByteArray := PByteArray( ALL_MAP.LowMem);
                                                                                                                                  for i := 0 to MemorySpaceCount - 1 do
                                                                                                                                    DatagramBuffer^.DataBytes[i+DatagramOffset] := ByteArray^[i+MemorySpaceOffset]
                                                                                                                                end;
                                                                                                                MSI_CONFIG    : begin
                                                                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                                                                  begin
                                                                                                                                    for i := 0 to MemorySpaceCount - 1 do
                                                                                                                                      DatagramBuffer^.DataBytes[i+DatagramOffset] := CONFIG_DATA_VNODE[i+MemorySpaceOffset]
                                                                                                                                  end else
                                                                                                                                  begin
                                                                                                                                    for i := 0 to MemorySpaceCount - 1 do
                                                                                                                                      DatagramBuffer^.DataBytes[i+DatagramOffset] := CONFIG_DATA[i+MemorySpaceOffset]
                                                                                                                                  end
                                                                                                                                end;
                                                                                                                MSI_ACDI_MFG  : begin
                                                                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                                                                  begin
                                                                                                                                    if MemorySpaceOffset = 0 then
                                                                                                                                    begin
                                                                                                                                      DatagramBuffer^.DataBytes[DatagramOffset] := ACDI_MFG_VERSION_VNODE;
                                                                                                                                      Inc(DatagramOffset);
                                                                                                                                      Dec(MemorySpaceCount);
                                                                                                                                      MemorySpaceOffset := 0;
                                                                                                                                    end;
                                                                                                                                    for i := 0 to MemorySpaceCount - 1 do
                                                                                                                                      DatagramBuffer^.DataBytes[i+DatagramOffset] := ACDI_MFG_STRINGS_VNODE[i+MemorySpaceOffset-1]
                                                                                                                                  end else
                                                                                                                                  begin
                                                                                                                                    if MemorySpaceOffset = 0 then
                                                                                                                                    begin
                                                                                                                                      DatagramBuffer^.DataBytes[DatagramOffset] := ACDI_MFG_VERSION;
                                                                                                                                      Inc(DatagramOffset);
                                                                                                                                      Dec(MemorySpaceCount);
                                                                                                                                      MemorySpaceOffset := 0;
                                                                                                                                    end;
                                                                                                                                    for i := 0 to MemorySpaceCount - 1 do
                                                                                                                                      DatagramBuffer^.DataBytes[i+DatagramOffset] := ACDI_MFG_STRINGS[i+MemorySpaceOffset-1]
                                                                                                                                  end;
                                                                                                                                end;
                                                                                                                MSI_ACDI_USER : begin
                                                                                                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                                                                                                  begin
                                                                                                                                    if MemorySpaceOffset = 0 then
                                                                                                                                    begin
                                                                                                                                      DatagramBuffer^.DataBytes[DatagramOffset] := ACDI_USER_VERSION_VNODE;
                                                                                                                                      Inc(DatagramOffset);
                                                                                                                                      Dec(MemorySpaceCount);
                                                                                                                                      MemorySpaceOffset := 0;
                                                                                                                                    end;
                                                                                                                                    for i := 0 to MemorySpaceCount - 1 do
                                                                                                                                      DatagramBuffer^.DataBytes[i+DatagramOffset] := CONFIG_DATA_VNODE[i+MemorySpaceOffset-1] // -1 is for the Version ID offset
                                                                                                                                  end else
                                                                                                                                  begin
                                                                                                                                    if MemorySpaceOffset = 0 then
                                                                                                                                    begin
                                                                                                                                      DatagramBuffer^.DataBytes[DatagramOffset] := ACDI_USER_VERSION;
                                                                                                                                      Inc(DatagramOffset);
                                                                                                                                      Dec(MemorySpaceCount);
                                                                                                                                      MemorySpaceOffset := 0;
                                                                                                                                    end;
                                                                                                                                    for i := 0 to MemorySpaceCount - 1 do
                                                                                                                                      DatagramBuffer^.DataBytes[i+DatagramOffset] := CONFIG_DATA[i+MemorySpaceOffset-1]       // -1 is for the Version ID offset
                                                                                                                                  end
                                                                                                                                end;
                                                                                                              end
                                                                                                            end;
                                                                                                            DatagramBuffer^.iByteCount := MemorySpaceCount + DatagramOffset;
                                                                                                          end;
                                                                                                          // This is safe because this will not be called until CBS_PROCESSSING is cleared simulating a "WaitForSendComplete"
                                                                                                          DatagramBuffer^.State := (DatagramBuffer^.State or CBS_OUTGOING or CBS_PROCESSING) and not CBS_TRANSFER_COMPLETE;  // Turn it into an outgoing Datagram
                                                                                                          DatagramBuffer^.Tag := 0;                                                          // Reset for the Transmit side
                                                                                                          DatagramBuffer^.SourceNodePtr := Node;                                             // So the Transmit Engine knows what source Node and Alias to associate the Datagram to
                                                                                                          DatagramBuffer^.Statemachine := STATE_MEM_CONFIG_WAITFOR_REPLY;
                                                                                                        end;
                                                                       STATE_MEM_CONFIG_WRITE         : begin   {$IFDEF TRACE_MEM_CONFIG_STATEMACHINE} UART1_Write_Text('STATE_MEM_CONFIG_WRITE'+LF);    {$ENDIF}
                                                                                                        end;
                                                                       STATE_MEM_CONFIG_WAITFOR_REPLY : begin   {$IFDEF TRACE_MEM_CONFIG_STATEMACHINE} UART1_Write_Text('STATE_MEM_CONFIG_WAITFOR_REPLY'+LF);   {$ENDIF}
                                                                                                          // This is updated within the CAN Interrupt
                                                                                                        end;
                                                                     end
                                                                   end;
                              DATAGRAM_TYPE_TRAIN_CONTROL        : begin
                                                                     if DatagramTrainControlCallbackFunc <> PDatagramTaskCallbackFunc( nil) then
                                                                       DatagramTrainControlCallbackFunc(Node, DatagramBuffer);
                                                                     NMRAnetUtilities_DatagramBufferUnLink(Node, DatagramBuffer);
                                                                     NMRAnetBufferPools_ReleaseDatagramBuffer(DatagramBuffer)
                                                                   end
                            else begin  // Unknown Datagram Type
                               if NMRAnetBufferPools_AllocateBaseBuffer(AllocatedBuffer) then      // Assume we always can allocate a BaseBuffer
                                begin
                                  NMRAnetUtilities_BaseBufferLink(Node, AllocatedBuffer);
                                  AllocatedBuffer^.mCode := BMC_DATAGRAM_NOT_ACCEPTED;
                                  AllocatedBuffer^.Alias := DatagramBuffer^.Alias;
                                  NMRAnetUtilities_DatagramBufferUnLink(Node, DatagramBuffer);
                                  NMRAnetBufferPools_ReleaseDatagramBuffer(DatagramBuffer);
                                end
                              end;
                            end;  // case [Datagram Type]

                          end;
        end; // case
      end
    end;
  end;
  UnLockCANInterrupt;
end;


// *****************************************************************************
//  procedure ProcessOutgoingNode
//     Parameters:
//     Returns:
//
//     Description: If outgoing messages need to be queued up then this function
//                  ensures all needed messages are sent
//
// *****************************************************************************
procedure ProcessOutgoingNode(Node: PNMRAnetNode; Buffer: PCANBuffer);
var
  DatagramBuffer: PDatagramBuffer;
begin
  // Chug through the All Event Enumeration
  if NMRAnetNode_TestStateFlag(Node, NS_ENUMERATING_EVENTS) then                // Last in priority to send the Event Lists
  begin
    if Node^.State and NS_VIRTUAL <> 0 then
    begin
       {$IFDEF SUPPORT_AT_LEAST_ONE_VNODE_PRODUCED_EVENT}
      if Node^.EventCounter < MAX_VNODE_SUPPORTED_EVENTS_PRODUCED then
      begin
        if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_PRODUCER_IDENTIFIED_UNKNOWN, 0, 8, @SUPPORTED_VNODE_EVENTS_PRODUCED[Node^.EventCounter]) then
          Inc(Node^.EventCounter);
      end else
      {$ENDIF}
      {$IFDEF SUPPORT_AT_LEAST_ONE_VNODE_CONSUMED_EVENT}
      if Node^.EventCounter < MAX_VNODE_SUPPORTED_EVENTS then
      begin
        if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_CONSUMER_IDENTIFIED_UNKNOWN, 0, 8, @SUPPORTED_VNODE_EVENTS_CONSUMED[Node^.EventCounter-MAX_VNODE_SUPPORTED_EVENTS_PRODUCED]) then
          Inc(Node^.EventCounter);
      end else
      {$ENDIF}
        NMRAnetNode_ClearStateFlag(Node, NS_ENUMERATING_EVENTS);
    end else
    begin
      {$IFDEF SUPPORT_AT_LEAST_ONE_PRODUCED_EVENT}
      if Node^.EventCounter < MAX_SUPPORTED_EVENTS_PRODUCED then
      begin
        if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_PRODUCER_IDENTIFIED_UNKNOWN, 0, 8, @SUPPORTED_EVENTS_PRODUCED[Node^.EventCounter]) then
          Inc(Node^.EventCounter);
      end else
      {$ENDIF}
      {$IFDEF SUPPORT_AT_LEAST_ONE_CONSUMED_EVENT}
      if Node^.EventCounter < MAX_SUPPORTED_EVENTS then
      begin
        if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_CONSUMER_IDENTIFIED_UNKNOWN, 0, 8, @SUPPORTED_EVENTS_CONSUMED[Node^.EventCounter-MAX_SUPPORTED_EVENTS_PRODUCED]) then
          Inc(Node^.EventCounter);
      end else
      {$ENDIF}
        NMRAnetNode_ClearStateFlag(Node, NS_ENUMERATING_EVENTS);
    end;
  end;

  // Look for outgoing Datagrams
  LockCANInterrupt;
  if NMRAnetUtilities_FindOutgoingDatagram(Node, DatagramBuffer, True) then
  begin
    if NMRAnetStateMachine_TrySendDatagram(PNMRAnetNode( DatagramBuffer^.SourceNodePtr), DatagramBuffer) then
      DatagramBuffer^.State := (DatagramBuffer^.State and not CBS_PROCESSING) or CBS_TRANSFER_COMPLETE;    // Flag as complete so the caller and unlink and free
  end;
  UnLockCANInterrupt
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Process
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************

procedure NMRAnetStateMachine_Process(Node: PNMRAnetNode);
var
  Buffer: TCANBuffer;     
  VariableField: DWord;
begin
  case Node^.iStateMachine of
    STATE_NMRABUS_START :
      begin  {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_START'+LF); {$ENDIF}
        FlushLists(Node);
        while CAN_Engine.State and CES_TRANSMITTING <> 0 do;                             // Wait for the last transmited packet
        Node^.iStateMachine := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_GENERATE_NODE_ALIAS :
      begin  {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_GENERATE_NODE_ALIAS'+LF); {$ENDIF}
        LockCANInterrupt;
        Node^.Node.AliasID := NMRAnetUtilities_CreateAliasID(Node^.Node.Seed, False);
        NMRAnetNode_SortNodeList(Nodes);
        UnLockCANInterrupt;
        Node^.Login.iCID := 0;
        Node^.iStateMachine := STATE_NMRABUS_TRANSMIT_CID;
      end;
    STATE_RANDOM_NUMBER_GENERATOR :
      begin   {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_RANDOM_NUMBER_GENERATOR'+LF); {$ENDIF}
        NMRAnetUtilities_PsudoRandomNumberGeneratorOnSeed(Node^.Node.Seed);
        Node^.iStateMachine := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_TRANSMIT_CID :
      begin   {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_TRANSMIT_CID'+LF); {$ENDIF}
        case Node^.Login.iCID of
          0 : VariableField := MTI_CID0;                                         // Queue up
          1 : VariableField := MTI_CID1;
          2 : VariableField := MTI_CID2;
          3 : VariableField := MTI_CID3;
        end;
        if TryTransmitCANLayerMsg(Node, @Buffer, VariableField) then
          Node^.iStateMachine := STATE_NMRABUS_NEXT_CDI;
      end;
    STATE_NMRABUS_NEXT_CDI :
      begin   {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_NEXT_CDI'+LF); {$ENDIF}
        if Node^.Login.iCID < 3 then
        begin
          Inc(Node^.Login.iCID);
          Node^.iStateMachine := STATE_NMRABUS_TRANSMIT_CID
        end else 
        begin
          if CAN_Engine.State and CES_TRANSMITTING = 0 then                     // Wait until the transmission is complete before waiting the 200ms
          begin
            Node^.iStateMachine := STATE_NMRABUS_WAITSTATE;
            Node^.Login.TimeCounter := 0;
          end
        end
      end;
    STATE_NMRABUS_WAITSTATE :
      begin  {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_WAITSTATE'+LF); {$ENDIF}
        if Node^.Login.TimeCounter > MAX_BUS_LOGIN_TIMEOUT then
          Node^.iStateMachine := STATE_NMRABUS_SEND_LOGIN_RID;
      end;
    STATE_NMRABUS_SEND_LOGIN_RID :
      begin  {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_SEND_LOGIN_RID'+LF); {$ENDIF}
        if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_ALIAS, True) then    
          Node^.iStateMachine := STATE_RANDOM_NUMBER_GENERATOR
        else begin
          if TryTransmitCANLayerMsg(Node, @Buffer, MTI_RID) then
            Node^.iStateMachine := STATE_NMRABUS_SEND_LOGIN_AMD;
        end
      end;
    STATE_NMRABUS_SEND_LOGIN_AMD :
      begin  {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_SEND_LOGIN_AMD'+LF); {$ENDIF}
        if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_ALIAS, True) then
          Node^.iStateMachine := STATE_RANDOM_NUMBER_GENERATOR
        else begin
          if TryTransmitCANLayerMsg(Node, @Buffer, MTI_AMD) then
          begin
            NMRAnetNode_SetStateFlag(Node, NS_PERMITTED);
            Node^.iStateMachine := STATE_NMRABUS_INITIALIZED
          end
        end
      end;
    STATE_NMRABUS_INITIALIZED :
      begin  {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_INITIALIZED'+LF); {$ENDIF}
        if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_ALIAS, True) then
          Node^.iStateMachine := STATE_RANDOM_NUMBER_GENERATOR
        else begin
          if TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_INITIALIZATION_COMPLETE, 0, 0, nil) then
          begin
            Node^.iStateMachine := STATE_NMRABUS_LOGIN_IDENTIFY_EVENTS;
            NMRAnetNode_SetStateFlag(Node, NS_INITIALIZED);
          end
        end
      end;
    STATE_NMRABUS_LOGIN_IDENTIFY_EVENTS :
      begin   {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_LOGIN_IDENTIFY_EVENTS'+LF); {$ENDIF}
        NMRAnetNode_SetMsgFlag(Node, MF_IDENTIFY_ALL_EVENTS);
        Node^.iStateMachine := STATE_NMRABUS_PERMITTED;
      end;
    STATE_NMRABUS_PERMITTED :
      begin  //    {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_PERMITTED'+LF); {$ENDIF}
        ProcessNode(Node, @Buffer);                                             // Handle auto Actions to CAN/NMRAnet messages coming in
        ProcessOutgoingNode(Node, @Buffer);
      end;
    STATE_NMRABUS_INHIBITED :
      begin  {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_INHIBITED'+LF); {$ENDIF}
        if TryTransmitCANLayerMsg(Node, @Buffer, MTI_AMR) then
        begin
      //    FlushLists(Node);
          ReleaseBuffers(Node);
          NMRAnetNode_ClearStateFlag(Node, NS_PERMITTED);
          NMRAnetNode_ClearMsgFlags(Node);

          // NEED TO CLEAR PENDING MESSAGES TO.................................
          
          Node^.iStateMachine := STATE_RANDOM_NUMBER_GENERATOR;
        end
      end;
    STATE_NMRABUS_DUPLICATE_FULL_ID :
      begin  {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_DUPLICATE_FULL_ID'+LF); {$ENDIF}
        if TryTransmitCANLayerMsg(Node, @Buffer, MTI_AMR) then
        begin
          FlushLists(Node);
          ReleaseBuffers(Node);
          NMRAnetNode_ClearStateFlag(Node, NS_PERMITTED);
          NMRAnetNode_ClearMsgFlags(Node);
          
          // NEED TO CLEAR PENDING MESSAGES TO.................................
          
          Node^.iStateMachine := STATE_NMRABUS_TAKE_OFFLINE
        end
      end;
    STATE_NMRABUS_TAKE_OFFLINE :
      begin  {$IFDEF TRACE_NODE_STATEMACHINE} UART1_Write_Text('STATE_NMRABUS_TAKE_OFFLINE'+LF); {$ENDIF}
        if TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_PC_EVENT_REPORT, 0, 8, @EVENT_DUPLICATE_ID_DETECTED) then
          Node^.iStateMachine := STATE_NMRABUS_OFFLINE
      end;
    STATE_NMRABUS_OFFLINE :
      begin
        // Done until reboot
      end
  else
    Node^.iStateMachine := STATE_NMRABUS_START;
  end
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_Disconnect(Node: PNMRAnetNode);
begin
  Node^.iStateMachine := STATE_NMRABUS_INHIBITED
end;

end.