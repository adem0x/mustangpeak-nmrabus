unit NMRAnetStateMachine;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRAnet StateMachine for the main loop in a program.
//
// ******************************************************************************

uses
  NMRAnetNodeDefines,
  NMRAnetEventDefines,
  NMRAnetAppDefines,
  NMRAnetDefines,
  NMRAnetUtilities,
  NMRAnetCANReceive,
  CANStorage,
  CANDefines,
  NMRAnetNode,
  NMRAnetDatagrams,
  NMRAnetBufferPools,
  NMRAnetBufferPoolsDefines,
  NMRAnetDatagramDefines,
  NMRAnetConfigurationProtocol,
  NMRAnetConfigurationProtocolDefines;

{$I Options.inc}


  procedure NMRAnetStateMachine_Process(Node: PNMRAnetNode);
  procedure NMRAnetStateMachine_Disconnect(Node: PNMRAnetNode);
  procedure NMRAnetStateMachine_Initialize(PhysicalNodeID_HI, PhysicalNodeID_Lo: DWord);
  procedure NMRAnetStateMachine_InitializeNode(Node: PNMRAnetNode; NodeID_HI, NodeID_Lo: DWord);
  procedure NMRAnetStateMachine_100ms_Timer(Node: PNMRAnetNode);
  
  procedure NMRAnetStateMachine_InitializeDataBuffer(Buffer: PDataBuffer);
  
  // Receive Callback Helper Functions.  This could be done with separate callbacks for different message
  // types but that would require callback function variables that could get expensive in memory allocation so
  // here just look at the Response nCode and the CRC_xxx constants to decode what message was received for complex
  // and the SRC_xxx constants for the Simple callback
  procedure NMRAnetStateMachine_SetSimpleCallbackFunc(CallBack: PSimpleActionCallbackFunc);
  procedure NMRAnetStateMachine_SetComplexCallbackFunc(CallBack: PComplexActionCallbackFunc);
  
  // Send Helper Functions
  function NMRAnetStateMachine_TrySendIdentifyProducer(Node: PNMRAnetNode; Buffer: PCANBuffer; EventID: PEventID): Boolean;
  function NMRAnetStateMachine_TrySendIdentifyConsumer(Node: PNMRAnetNode; Buffer: PCANBuffer; EventID: PEventID): Boolean;
  function NMRAnetStateMachine_TrySendIdentifyEvents(Node: PNMRAnetNode; Buffer: PCANBuffer): Boolean;
  function NMRAnetStateMachine_TrySendAliasMapEnquiry(Node: PNMRAnetNode; Buffer: PCANBuffer): Boolean;
  function NMRAnetStateMachine_TrySendVerifyNodeID(Node: PNMRAnetNode; Buffer: PCANBuffer; DestinationAliasID: Word): Boolean;
  function NMRAnetStateMachine_TrySendAbbreviatedCDI(Node: PNMRAnetNode; Buffer: PCANBuffer; DestinationAliasID: Word): Boolean;
  
  // Exported Functions
  function TryTransmitNMRABusLayerMsg(Node: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes): Boolean;

  // defined in the dsPICxx_CAN_Interrupt.mpas file
  procedure StartCANMessageEngine; external;
  procedure LockCANInterrupt; external;
  procedure UnLockCANInterrupt; external;
  
var
  TX_CANBufferList: TCANBufferList; external;
  TX_NMRAnetBufferList: TCANBufferList; external;

implementation

 var
   s1: array[0..32] of char;

function NMRAnetStateMachine_TrySendAbbreviatedCDI(Node: PNMRAnetNode; Buffer: PCANBuffer; DestinationAliasID: Word): Boolean;
var
//  BrokenBuffer: TCANBUffer;   BUG IN VERSION 5.60 with this
  DataBytes: TCAN_DataBytes;
begin
  DataBytes[0] := MTI_EXTENSION_SIMPLENODE_IDENTIFY_INFO_REQUEST;
  Result := TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_PRODUCER_IDENDIFY, DestinationAliasID, 1, @DataBytes);
end;

function NMRAnetStateMachine_TrySendIdentifyProducer(Node: PNMRAnetNode; Buffer: PCANBuffer; EventID: PEventID): Boolean;
//var
//  BrokenBuffer: TCANBUffer;   BUG IN VERSION 5.60 with this
begin
  Result := TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_PRODUCER_IDENDIFY, 0, EVENT_ARRAY_LENGTH, PCAN_DataBytes( EventID));
end;

function NMRAnetStateMachine_TrySendIdentifyConsumer(Node: PNMRAnetNode; Buffer: PCANBuffer; EventID: PEventID): Boolean;
//var
//  Buffer: TCANBUffer;   BUG IN VERSION 5.60 with this
begin
  Result := TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_CONSUMER_IDENTIFY, 0, EVENT_ARRAY_LENGTH,  PCAN_DataBytes( EventID));
end;

function NMRAnetStateMachine_TrySendIdentifyEvents(Node: PNMRAnetNode; Buffer: PCANBuffer): Boolean;
//var
//  Buffer: TCANBUffer;   BUG IN VERSION 5.60 with this
begin
  Result := TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_EVENTS_IDENTIFY, 0, 0, nil);
end;

function NMRAnetStateMachine_TrySendAliasMapEnquiry(Node: PNMRAnetNode; Buffer: PCANBuffer): Boolean;
begin
  Result := TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_AME, 0, 0, nil);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_TrySendVerifyNodeID
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetStateMachine_TrySendVerifyNodeID(Node: PNMRAnetNode; Buffer: PCANBuffer; DestinationAliasID: Word): Boolean;
var
  DataBytes: TCAN_DataBytes;
begin
  if DestinationAliasID <> 0 then
  begin
    DataBytes[0] := MTI_EXTENSION_VERIFY_NODE_ID_NUMBER_DEST;
    Result := TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_VERIFY_NODE_ID_NUMBER_DEST, DestinationAliasID, 1, @DataBytes);
  end else
    Result := TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_VERIFY_NODE_ID_NUMBER, 0, 0, nil);
end;

// *****************************************************************************
//  procedure FlushActionList
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure ReleaseActions(Node: PNMRAnetNode);
begin
{  if Node^.Actions <> nil then
  begin
    Node^.Actions^.State := QAS_EMPTY;
    Node^.Actions := PQueuedActions( nil);
  end  }
end;

// *****************************************************************************
//  procedure FlushLists
//     Parameters:
//     Returns:
//
//     Description: Clears the lists of messages for the passed node
//
// *****************************************************************************
procedure FlushLists(Node: PNMRAnetNode);
begin

 //Need to only remove messages that match the passed Node!!!!!!!
 
  CANStorage_FlushList(@TX_CANBufferList);                                      // Flush any pending packets
  CANStorage_FlushList(@TX_NMRAnetBufferList);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the BufferArray
//              LasterBuffer   : Pointer to the last item in the BufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure NMRAnetStateMachine_InitializeList(ListPtr: PCANBufferList; BufferArrayPtr: PCANBufferArray; ListLength: Byte);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.Size := ListLength;
  ListPtr^.Head := @BufferArrayPtr^[0];
  ListPtr^.Tail := @BufferArrayPtr^[0];
  ListPtr^.Count := 0;
  ListPtr^.MaxCount := 0;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_SetSimpleCallbackFunc
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_SetSimpleCallbackFunc(CallBack: PSimpleActionCallbackFunc);
begin
  SimpleActionCallbackFunc := Callback;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_SetComplexCallbackFunc
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_SetComplexCallbackFunc(CallBack: PComplexActionCallbackFunc);
begin
  ComplexActionCallbackFunc := Callback;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_InitializeDataBuffer;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure NMRAnetStateMachine_InitializeDataBuffer(Buffer: PDataBuffer);
var
  i: Integer;
begin
  Buffer^.State := CBS_EMPTY;
  Buffer^.mCode := 0;
  Buffer^.Alias := 0;
  Buffer^.Next := 0;
  Buffer^.Count := 0;
  Buffer^.RefCount := 0;
  Buffer^.Tag := 0;
  for i := 0 to CAN_DATA_LEN - 1 do
    Buffer^.DataBytes[i] := 0;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_InitializeNode
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_InitializeNode(Node: PNMRAnetNode; NodeID_HI, NodeID_LO: DWord);
begin
  Node^.MsgBuffer := PBaseBuffer( nil);
  Node^.State := 0;
  Node^.MsgFlags := 0;
  Node^.EventCounter := 0;
  if (NodeID_HI <> 0) and (NodeID_LO <> 0) then
  begin
    Node^.Node.ID[0] := NodeID_LO;
    Node^.Node.ID[1] := NodeID_HI;
    Node^.Node.Seed := Node^.Node.ID;
  end;
  Node^.iStateMachine := STATE_NMRABUS_START;
end;    

// *****************************************************************************
//  procedure NMRAnetStateMachine_Initialize
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_Initialize(PhysicalNodeID_HI, PhysicalNodeID_Lo: DWord);
begin
  NMRAnetDatagrams_Initialize;
  NMRAnetCANReceive_Initialize;
  NMRAnetConfigurationProtocol_Initialize;
  NMRAnetBufferPools_Initialize;
  NMRAnetNode_Initialize(PhysicalNodeID_HI, PhysicalNodeID_Lo);
  SimpleActionCallbackFunc := PSimpleActionCallbackFunc( nil);
  ComplexActionCallbackFunc := PComplexActionCallbackFunc( nil);
  NMRAnetStateMachine_InitializeList(@TX_CANBufferList, @TX_CANBuffer, TX_CAN_BUFFER_LEN);
  NMRAnetStateMachine_InitializeList(@TX_NMRAnetBufferList, @TX_NMRAnet_Buffer, TX_NMRANET_BUFFER_LEN);
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_100ms_Timer;
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_100ms_Timer(Node: PNMRAnetNode);
begin
  Inc(Node^.Login.TimeCounter);
  NMRAnetDatagrams_100ms_TimeTick(Node);
end;

// *****************************************************************************
//  procedure TryTransmitCANLayerMsg
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function TryTransmitCANLayerMsg(Node: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_CANBufferList) then
  begin
    NMRAnetUtilities_CreateCANControlFramePacket(Node, Buffer, VariableField);
    if CANStorage_AddToList(@TX_CANBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True
    end
  end ;
end;

// *****************************************************************************
//  procedure TryTransmitNMRABusLayerMsg
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function TryTransmitNMRABusLayerMsg(Node: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes): Boolean;
begin
  Result := False;
  if not CANStorage_ListFull(@TX_NMRAnetBufferList) then
  begin
    NMRAnetUtilities_CreateNMRABusMessagePacket(Node, Buffer, VariableField, DestinationAlias, DataCount, DataBytes);
    if CANStorage_AddToList(@TX_NMRAnetBufferList, Buffer) then
    begin
      StartCANMessageEngine();
      Result := True;
    end
  end
end;

// *****************************************************************************
//  procedure DispatchDatagramAction
//
//     Parameters:
//
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure DispatchDatagramAction(Node: PNMRAnetNode; nCode: Word; NextState: Byte);
//var
//  Action: PQueuedAction;
//  Datagram: PDatagramBuffer;
begin
 { if Node^.Actions <> nil then
  begin
    Action := FindStoredComplexAction(Node, nCode);                                 // Look for Datagram Actions from Nodes this node sent a Datagram to
    if Action <> nil then
    begin
      if Node^.DatagramTransmit <> nil then
      begin                                                             // A node is responding to a Datagram this node sent
        Datagram := Node^.DatagramTransmit;
        if Datagram^.State = DATAGRAM_BUFFER_IN_PROCESS then                     // Only look for transmit buffers that have Datagram Tranmissions in Process
          if NMRAnetUtilities_CompareAliasIDs(Datagram^.Alias, Action^.FromAlias) then
          begin                                                                   // The alias that sent the Action (OK/Rejected) is in the list of Nodes that we sent a Datagram to!
            Datagram^.ErrorCode.MTI := Action^.DataBytes[0];                    // Copy over the results that destination node passed in the received Datagram Result message
            Datagram^.ErrorCode.SubType[0] := Action^.DataBytes[2];
            Datagram^.ErrorCode.SubType[1] := Action^.DataBytes[1];
            Datagram^.State := DATAGRAM_BUFFER_TRANSFER_COMPLETE;
            Action^.nCode := CRC_EMPTY;                                         // Free the Action
            Exit;
          end;
      end;                                          // TODO THIS WILL BE RECURSIVE INTO THE LINKED LIST!!!@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
      Action^.nCode := CRC_EMPTY;                                               // The Action was found but there was no matching transmiting nodes
    end;
    Node^.Actions^.iState := NextState
  end                                           }
end;

// *****************************************************************************
//  procedure DispatchMessageAction
//
//     Parameters:
//
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure DispatchMessageAction(Node: PNMRAnetNode; nCode: Word; NextState: Byte);
//var
 // Action: PQueuedAction;
begin
 { if Node^.Actions <> nil then
  begin
    Action := FindStoredComplexAction(Node, nCode);                                 // Look for Complex Actions from Nodes this node sent a Datagram to
    if Action <> nil then
    begin
      if ComplexActionCallbackFunc <> nil then
        ComplexActionCallbackFunc(Node, Action);
      Action^.nCode := CRC_EMPTY;
    end;
    Node^.Actions^.iState := NextState
  end }
end;

// *****************************************************************************
//  procedure ProcessNode
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure ProcessNode(Node: PNMRAnetNode; Buffer: PCANBuffer);
const
  ADDRESSED = True;
  NONADDRESSED = False;
  CRITICAL_MSG_MASK = MF_DUPLICATE_NODE_ID or MF_DUPLICATE_ALIAS or MF_DUPLICATE_ALIAS_RID;

var
  LocalMsgFlags: Byte;
  DataBytes: TCAN_DataBytes;
  i, j, MaxIndex: Integer;
  BaseBuffer: PBaseBuffer;
  DataBuffer: PDataBuffer;
  DatagramBuffer: PDatagramBuffer;
  ACDIArray: ^array[0..0] of Byte;
begin
  LocalMsgFlags := Node^.MsgFlags;
  
  // The first thing to check is for duplicate Node ID's or Aliases and handle
  // them first and exclusively
  if LocalMsgFlags <> 0 then
  begin
    if LocalMsgFlags and CRITICAL_MSG_MASK <> 0 then                            // Subdivide to Critical vs. Noncritical messages
    begin
      // Critial Fault Messages
      if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_NODE_ID, True) then        // Jump Statemachine here
        Node^.iStateMachine := STATE_NMRABUS_DUPLICATE_FULL_ID
      else
      if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_ALIAS, True) then          // Jump Statemachine here
        Node^.iStateMachine := STATE_NMRABUS_INHIBITED
      else
      if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_ALIAS_RID, False) then
      begin
         if TryTransmitCANLayerMsg(Node, Buffer, MTI_RID) then
           NMRAnetNode_ClearMsgFlag(Node, MF_DUPLICATE_ALIAS_RID);
      end;
      Exit;                                                                     // Bad things happening, exit
    end;

    // Non Critical Fault Messages that require a response
    if NMRAnetNode_TestMsgFlags(Node, MF_ALIAS_MAP_ENQUIRY, False) then
    begin
       if TryTransmitCANLayerMsg(Node, Buffer, MTI_AMD) then                   // DataBytes get loaded automatically
         NMRAnetNode_ClearMsgFlag(Node, MF_ALIAS_MAP_ENQUIRY);
    end else
    if NMRAnetNode_TestMsgFlags(Node, MF_VERIFY_NODE_ID, False) then
    begin
      NMRAnetUtilities_LoadFramePacketDataWith48BitNodeID(Node, @DataBytes);
      if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_VERIFIED_NODE_ID_NUMBER, 0, 6, @DataBytes) then
        NMRAnetNode_ClearMsgFlag(Node, MF_VERIFY_NODE_ID);
    end else
    if NMRAnetNode_TestMsgFlags(Node, MF_IDENTIFY_ALL_EVENTS, False) then
    begin
      if not NMRAnetNode_TestStateFlag(Node, NS_ENUMERATING_EVENTS) then
      begin
        NMRAnetNode_SetStateFlag(Node, NS_ENUMERATING_EVENTS);                // Enumerating is just starting, kick it off
        NMRAnetNode_ClearMsgFlag(Node, MF_IDENTIFY_ALL_EVENTS);               // Allow another node to set the flag
        Node^.EventCounter := 0;
      end   
    end
  end else
  begin
    if Node^.MsgBuffer <> 0 then
    begin
      if Node^.MsgBuffer^.State and CBS_BUFFER_BASE <> 0 then                   // QUESTION ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      begin                                                                     // WHAT IS THE POINT OF CHECKING STATE NOW?  IT MAY HELP WITH EXECUTION TIME
        case Node^.MsgBuffer^.mCode of                                          // BY NOT RUNNING A BIG CASE STATEMENT..... NEED TO BURN SOME BRAIN CELLS ON IT
          BMC_PROTOCOL_SUPPORT_QUERY :        begin
                                                NMRAnetUtilities_ZeroCANData(DataBytes);
                                                DataBytes[0] := $2F;
                                                for i := 0 to LEN_PIV_PROTOCOL-1 do
                                                  for j := 0 to PIV_SUPPORTED_PROTOCOL_COUNT - 1 do
                                                    DataBytes[i+1] := DataBytes[i+1] or PIV_SUPPORTED_PROTOCOLS[j][i];
                                                if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_PROTOCOL_SUPPORT_REPLY, Node^.MsgBuffer^.Alias, 6, @DataBytes) then
                                                begin
                                                  NMRAnetUtilities_MsgBufferUnLink(Node, BaseBuffer);
                                                  NMRAnetBufferPools_ReleaseBaseBuffer(BaseBuffer);
                                                end;
                                              end;
          BMC_UNKNOWN_ADDRESSED_MTI :         begin
                                                DataBytes[0] := MTI_EXTENSION_OPTIONAL_INTERACTION_REJECTED;
                                                if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_OPTIONAL_INTERACTION_REJECTED, Node^.MsgBuffer^.Alias, 1, @DataBytes) then
                                                begin
                                                  NMRAnetUtilities_MsgBufferUnLink(Node, BaseBuffer);
                                                  NMRAnetBufferPools_ReleaseBaseBuffer(BaseBuffer);
                                                end;
                                              end;
          BMC_SIMPLE_NODE_INFO_REQEUST :      begin
                                                if not CANStorage_ListFull(@TX_NMRAnetBufferList) then      // This has gotta go after updating everything
                                                begin

                                                  BaseBuffer := Node^.MsgBuffer;
                                                  
                                                  
                                         {         WordToHex(Word(BaseBuffer), s1);
                                                  UART1_Write_Text('0x'+s1+LF);
                                                  WordToHex(Word(BaseBuffer^.Alias), s1);
                                                  UART1_Write_Text('   Alias: '+s1+LF);
                                                  WordToHex(Word(BaseBuffer^.Next), s1);
                                                  UART1_Write_Text('   Next: '+s1+LF);
                                                  WordToHex(Word(BaseBuffer^.RefCount), s1);
                                                  UART1_Write_Text('   RefCount: '+s1+LF);
                                                  WordToHex(Word(BaseBuffer^.mCode), s1);
                                                  UART1_Write_Text('   mCode: '+s1+LF);
                                                  WordToHex(Word(BaseBuffer^.Tag), s1);
                                                  UART1_Write_Text('   Tag: '+s1+LF);   }
                                                  

                                                  if Node^.State and NS_VIRTUAL <> 0 then
                                                  begin
                                                    ACDIArray := @TACDI_VNODE_STRINGS;
                                                    MaxIndex := MAX_VNODE_ACDI_ARRAY
                                                  end else
                                                  begin
                                                    ACDIArray := @TACDI_NODE_STRINGS;
                                                    MaxIndex := MAX_ACDI_ARRAY
                                                  end;

                                                  i := 0;
                                                  DataBytes[i] := MTI_EXTENSION_SIMPLENODE_IDENTIFY_INFO_REPLY;
                                                  Inc(i);
                                                  while (i < 7) and (BaseBuffer^.Tag < MaxIndex) do
                                                  begin
                                                    DataBytes[i] := ACDIArray^[BaseBuffer^.Tag];
                                                    Inc(BaseBuffer^.Tag);
                                                    Inc(i);
                                                  end;
                                                  TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_PROTOCOL_SUPPORT_REPLY, BaseBuffer^.Alias, i, @DataBytes);  // Has to go, already checked for a free buffer
                                                  if BaseBuffer^.Tag = MaxIndex then
                                                  begin
                                                    NMRAnetUtilities_MsgBufferUnLink(Node, BaseBuffer);
                                                    NMRAnetBufferPools_ReleaseBaseBuffer(BaseBuffer);
                                                  end;
                                                end
                                              end;
        end;
      end else
      if Node^.MsgBuffer^.State and CBS_BUFFER_DATABUFFER <> 0 then
      begin
        case Node^.MsgBuffer^.mCode of
          BMC_PRODUCER_IDENTIFY :             begin
                                                DataBuffer := PDataBuffer( Word( Node^.MsgBuffer));
                                                if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_PRODUCER_IDENTIFIED_UNKNOWN, Node^.MsgBuffer^.Alias, DataBuffer^.Count, @DataBuffer^.DataBytes) then
                                                begin
                                                  NMRAnetUtilities_MsgBufferUnLink(Node, DataBuffer);
                                                  NMRAnetBufferPools_ReleaseDataBuffer(DataBuffer);
                                                end;
                                              end;
          BMC_CONSUMER_IDENTIFY :             begin
                                                DataBuffer := Node^.MsgBuffer);
                                                if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_CONSUMER_IDENTIFIED_UNKNOWN, Node^.MsgBuffer^.Alias, DataBuffer^.Count, @DataBuffer^.DataBytes) then
                                                begin
                                                  NMRAnetUtilities_MsgBufferUnLink(Node, DataBuffer);
                                                  NMRAnetBufferPools_ReleaseDataBuffer(DataBuffer);
                                                end;
                                              end;
          BMC_EVENT_LEARN :                   begin
                                              end;
        end; // case
      end else
      if Node^.MsgBuffer^.State and CBS_BUFFER_DATAGRAM <> 0 then
      begin
        case Node^.MsgBuffer^.mCode of
          BMC_DATAGRAM :                      begin
                                                DatagramBuffer := PDatagramBuffer( Pointer( Node^.MsgBuffer));
                                                if DatagramBuffer^.State and CBS_PROCESSING = 0 then
                                                begin
                                                  DataBytes[0] := DatagramBuffer^.ErrorCode.MTI;                // All the Errors and return codes where handled in the interrupt during reception
                                                  DataBytes[1] := DatagramBuffer^.ErrorCode.SubType[0];
                                                  DataBytes[2] := DatagramBuffer^.ErrorCode.SubType[1];
                                                  
                                                  // Hook in here to respond to Datagram........
                                                  
                                                  if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_DATAGRAM_REPLY, Node^.MsgBuffer^.Alias, DatagramBuffer^.ErrorCode.Count, @DataBytes) then
                                                  begin
                                                    NMRAnetUtilities_MsgBufferUnLink(Node, DatagramBuffer);
                                                    NMRAnetBufferPools_ReleaseDataBuffer(DatagramBuffer);
                                                  end;
                                                end;
                                              end;
        end; // case
      end else
    end;
  end;
  
  for i := 0 to LEN_DATAGRAM_BUFFER_OVERFLOW_LIST - 1 do
  begin
    if Node^.DatagramOverflowList[i] <> 0 then
    begin
      DataBytes[0] := MTI_EXTENSION_DATAGRAM_REJECTED;                          // All the Errors and return codes where handled in the interrupt during reception
      DataBytes[1] := DATAGRAM_RESULT_REJECTED_BUFFER_FULL[0];
      DataBytes[2] := DATAGRAM_RESULT_REJECTED_BUFFER_FULL[1];
      if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_DATAGRAM_REPLY, Node^.DatagramOverflowList[i], 3, @DataBytes) then
        Node^.DatagramOverflowList[i] := 0
      else
        Break
    end
  end;
  
  
  //  NEED TO DEAL WITH THE NODES DatagramOverflowList  ......bit%^^&&%%^^&^%&^%&#$&%#&^%^#^%R%^%^%#^%^%$^$^%$%^$^%#$%^$^#$%^




  // Chugging through the Event Enumeration is lowest on the list of priorites so it
  // gets the last crack at succeeding at the end of the statemachine
  
  if NMRAnetNode_TestStateFlag(Node, NS_ENUMERATING_EVENTS) then                // Last in priority to send the Event Lists
  begin
    if Node^.State and NS_VIRTUAL <> nil then
    begin
       {$IFDEF SUPPORT_AT_LEAST_ONE_PRODUCED_EVENT}
      if Node^.EventCounter < MAX_VNODE_SUPPORTED_EVENTS_PRODUCED then
      begin
        if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_PRODUCER_IDENTIFIED_UNKNOWN, 0, 8, @SUPPORTED_VNODE_EVENTS_PRODUCED[Node^.EventCounter]) then
          Inc(Node^.EventCounter);
      end else
      {$ENDIF}
      {$IFDEF SUPPORT_AT_LEAST_ONE_CONSUMED_EVENT}
      if Node^.EventCounter < MAX_VNODE_SUPPORTED_EVENTS then
      begin
        if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_CONSUMER_IDENTIFIED_UNKNOWN, 0, 8, @SUPPORTED_VNODE_EVENTS_CONSUMED[Node^.EventCounter-MAX_VNODE_SUPPORTED_EVENTS_PRODUCED]) then
          Inc(Node^.EventCounter);
      end else
      {$ENDIF}
        NMRAnetNode_ClearStateFlag(Node, NS_ENUMERATING_EVENTS);
      Inc(Node^.EventCounter);
    end else
    begin
      {$IFDEF SUPPORT_AT_LEAST_ONE_PRODUCED_EVENT}
      if Node^.EventCounter < MAX_SUPPORTED_EVENTS_PRODUCED then
      begin
        if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_PRODUCER_IDENTIFIED_UNKNOWN, 0, 8, @SUPPORTED_EVENTS_PRODUCED[Node^.EventCounter]) then
          Inc(Node^.EventCounter);
      end else
      {$ENDIF}
      {$IFDEF SUPPORT_AT_LEAST_ONE_CONSUMED_EVENT}
      if Node^.EventCounter < MAX_SUPPORTED_EVENTS then
      begin
        if TryTransmitNMRABusLayerMsg(Node, Buffer, MTI_CONSUMER_IDENTIFIED_UNKNOWN, 0, 8, @SUPPORTED_EVENTS_CONSUMED[Node^.EventCounter-MAX_SUPPORTED_EVENTS_PRODUCED]) then
          Inc(Node^.EventCounter);
      end else
      {$ENDIF}
        NMRAnetNode_ClearStateFlag(Node, NS_ENUMERATING_EVENTS);
      Inc(Node^.EventCounter);
    end;
  end;
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Process
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************

procedure NMRAnetStateMachine_Process(Node: PNMRAnetNode);
var
  Buffer: TCANBuffer;     
  VariableField: DWord;
begin
  case Node^.iStateMachine of
    STATE_NMRABUS_START :
      begin
        FlushLists(Node);
        while CAN_Engine.State and CES_TRANSMITTING <> 0 do;                             // Wait for the last transmited packet
        Node^.iStateMachine := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_GENERATE_NODE_ALIAS :
      begin
        LockCANInterrupt;
        Node^.Node.AliasID := NMRAnetUtilities_CreateAliasID(Node^.Node.Seed, False);
        NMRAnetNode_SortNodeList(Nodes);
        UnLockCANInterrupt;
        Node^.Login.iCID := 0;
        Node^.iStateMachine := STATE_NMRABUS_TRANSMIT_CID;
      end;
    STATE_RANDOM_NUMBER_GENERATOR :
      begin
        NMRAnetUtilities_PsudoRandomNumberGeneratorOnSeed(Node^.Node.Seed);
        Node^.iStateMachine := STATE_NMRABUS_GENERATE_NODE_ALIAS;
      end;
    STATE_NMRABUS_TRANSMIT_CID :
      begin
        case Node^.Login.iCID of
          0 : VariableField := MTI_CID0;                                         // Queue up
          1 : VariableField := MTI_CID1;
          2 : VariableField := MTI_CID2;
          3 : VariableField := MTI_CID3;
        end;
        if TryTransmitCANLayerMsg(Node, @Buffer, VariableField) then
          Node^.iStateMachine := STATE_NMRABUS_NEXT_CDI;
      end;
    STATE_NMRABUS_NEXT_CDI :
      begin
        if Node^.Login.iCID < 3 then
        begin
          Inc(Node^.Login.iCID);
          Node^.iStateMachine := STATE_NMRABUS_TRANSMIT_CID
        end else 
        begin
          if CAN_Engine.State and CES_TRANSMITTING = 0 then                     // Wait until the transmission is complete before waiting the 200ms
          begin
            Node^.iStateMachine := STATE_NMRABUS_WAITSTATE;
            Node^.Login.TimeCounter := 0;
          end
        end
      end;
    STATE_NMRABUS_WAITSTATE :
      begin
        if Node^.Login.TimeCounter > MAX_BUS_LOGIN_TIMEOUT then
          Node^.iStateMachine := STATE_NMRABUS_SEND_LOGIN_RID;
      end;
    STATE_NMRABUS_SEND_LOGIN_RID :
      begin
        if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_ALIAS, True) then    
          Node^.iStateMachine := STATE_RANDOM_NUMBER_GENERATOR
        else begin
          if TryTransmitCANLayerMsg(Node, @Buffer, MTI_RID) then
            Node^.iStateMachine := STATE_NMRABUS_SEND_LOGIN_AMD;
        end
      end;
    STATE_NMRABUS_SEND_LOGIN_AMD :
      begin
        if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_ALIAS, True) then
          Node^.iStateMachine := STATE_RANDOM_NUMBER_GENERATOR
        else begin
          if TryTransmitCANLayerMsg(Node, @Buffer, MTI_AMD) then
          begin
            NMRAnetNode_SetStateFlag(Node, NS_PERMITTED);
            Node^.iStateMachine := STATE_NMRABUS_INITIALIZED
          end
        end
      end;
    STATE_NMRABUS_INITIALIZED :
      begin
        if NMRAnetNode_TestMsgFlags(Node, MF_DUPLICATE_ALIAS, True) then
          Node^.iStateMachine := STATE_RANDOM_NUMBER_GENERATOR
        else begin
          if TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_INITIALIZATION_COMPLETE, 0, 0, nil) then
          begin
            Node^.iStateMachine := STATE_NMRABUS_LOGIN_IDENTIFY_EVENTS;
            NMRAnetNode_SetStateFlag(Node, NS_INITIALIZED);
          end
        end
      end;
    STATE_NMRABUS_LOGIN_IDENTIFY_EVENTS :
      begin
        NMRAnetNode_SetMsgFlag(Node, MF_IDENTIFY_ALL_EVENTS);
        Node^.iStateMachine := STATE_NMRABUS_PERMITTED;
      end;
    STATE_NMRABUS_PERMITTED :
      begin
        ProcessNode(Node, @Buffer);                                             // Handle auto Actions to CAN/NMRAnet messages coming in
     //   NMRAnetDatagrams_ProcessReceive(Node);                                  // Handle Datagrams coming in
     //   NMRAnetDatagrams_ProcessTransmit(Node);                                 // Handle Datagrams going out
     //   NMRAnetConfigurationProtocol_Process(Node);
      end;
    STATE_NMRABUS_INHIBITED :
      begin
        if TryTransmitCANLayerMsg(Node, @Buffer, MTI_AMR) then
        begin
          FlushLists(Node);
          ReleaseActions(Node);
          NMRAnetNode_ClearStateFlag(Node, NS_PERMITTED);
          NMRAnetNode_ClearMsgFlags(Node);
          
          // NEED TO CLEAR PENDING MESSAGES TO.................................
          
          Node^.iStateMachine := STATE_RANDOM_NUMBER_GENERATOR;
        end
      end;
    STATE_NMRABUS_DUPLICATE_FULL_ID :
      begin
        if TryTransmitCANLayerMsg(Node, @Buffer, MTI_AMR) then
        begin
          FlushLists(Node);
          ReleaseActions(Node);
          NMRAnetNode_ClearStateFlag(Node, NS_PERMITTED);
          NMRAnetNode_ClearMsgFlags(Node);
          
          // NEED TO CLEAR PENDING MESSAGES TO.................................
          
          Node^.iStateMachine := STATE_NMRABUS_TAKE_OFFLINE
        end
      end;
    STATE_NMRABUS_TAKE_OFFLINE :
      begin
        if TryTransmitNMRABusLayerMsg(Node, @Buffer, MTI_PC_EVENT_REPORT, 0, 8, @EVENT_DUPLICATE_ID_DETECTED) then
          Node^.iStateMachine := STATE_NMRABUS_OFFLINE
      end;
    STATE_NMRABUS_OFFLINE :
      begin
        // Done until reboot
      end
  else
    Node^.iStateMachine := STATE_NMRABUS_START;
  end
end;

// *****************************************************************************
//  procedure NMRAnetStateMachine_Disconnect
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
procedure NMRAnetStateMachine_Disconnect(Node: PNMRAnetNode);
begin
  Node^.iStateMachine := STATE_NMRABUS_INHIBITED
end;

end.