unit NMRAnetCANReceive;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRAnet CAN Receive StateMachine.  The user program does not need
//    to interact with this statemachine unless it needs to hook in for special purposes
//
// ******************************************************************************

uses
  NMRAnetDefines,
  NMRAnetUtilities,
  NMRAnetBufferPools,
  NMRAnetBufferPoolsDefines,
  NMRAnetNode,
  NMRAnetDatagrams,
  NMRAnetDatagramDefines,
  NMRAnetAppDefines,
  CANDefines;
  
type
  TPacketHandlerFunc = procedure(CAN3Buffer: PCANBuffer; var DoDefault: Boolean);
  PPacketHandlerFunc = ^TPacketHandlerFunc;
  
  procedure NMRAnetCANReceive_Initialize;
  procedure NMRAnetCANReceive_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);       // WARNING:  The Hook is called from within the Interrupt Handler.....
  procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);   // WARNING:  The Hook is called from within the Interrupt Handler.....

  // callbacks from the CAN interrupts used in the xxxxx_CAN_Interrupt.mpas units
  procedure ReceivedOnFilter0(Buffer: PCANBuffer);
  procedure ReceivedOnFilter1(Buffer: PCANBuffer);
  procedure ReceivedOnFilter2(Buffer: PCANBuffer);
  procedure ReceivedOnFilter3(Buffer: PCANBuffer);
  procedure ReceivedOnFilter4(Buffer: PCANBuffer);
  procedure ReceivedOnFilter5(Buffer: PCANBuffer);
  procedure ReceivedOnFilter6(Buffer: PCANBuffer);
   
implementation

var
  CANLayerReceiveHook: PPacketHandlerFunc;
  NMRAnetLayerReceiveHook: PPacketHandlerFunc;
  
// ****************************************************************************
// procedure NMRAnetCANReceive_Initialize
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_Initialize;
begin
  CANLayerReceiveHook := PPacketHandlerFunc( nil);
  NMRAnetLayerReceiveHook := PPacketHandlerFunc( nil);
  MaxTime_RX := 0;
end;
  
// ****************************************************************************
// procedure NMRAnetCANReceive_SetCANLayerReceiveHook
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  CANLayerReceiveHook := HookFunc
end;

// ****************************************************************************
// procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  NMRAnetLayerReceiveHook := HookFunc
end;

// *****************************************************************************
//  procedure ReceivedOnFilter0
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 0 which is defined
//                  as any CAN level message (bit 26 = 0)
//
// *****************************************************************************
procedure ReceivedOnFilter0(CANBuffer: PCANBuffer);                             // CAN Layer Message
var
  DoDefault: Boolean;
  Node: PNMRAnetNode;
  NodeID: TNodeID;
begin

 //UART1_Write_Text('CAN'+LF);
 
  DoDefault := True;
  if CANLayerReceiveHook <> nil then
    CANLayerReceiveHook(CANBuffer, DoDefault);
    
  if DoDefault then
  begin
    // First thing is the extract the Source Alias and make sure it is not a duplicate of one of our Node or vNode Aliases
    Node := NMRAnetNode_FindByAlias(NMRAnetUtilities_ExtractSourceAlias(CANBuffer));
    if Node <> nil then                                                         // Check for a Duplicate Alias
    begin
      if (CANBuffer^.ID and MTI_CID_MASK = MTI_CID0) or (CANBuffer^.ID and MTI_CID_MASK = MTI_CID1) or (CANBuffer^.ID and MTI_CID_MASK = MTI_CID2) or (CANBuffer^.ID and MTI_CID_MASK = MTI_CID3) then
        Node^.MsgFlags := Node^.MsgFlags or MF_DUPLICATE_ALIAS_RID              // A "good" duplicate Alias
      else
        Node^.MsgFlags := Node^.MsgFlags or MF_DUPLICATE_ALIAS;                 // A "bad" duplicate Alias
    end else
    begin
      // The message does not contain a duplicate Source Alias so handle it
      case CANBuffer^.ID and MTI_UNADDRESSED_MASK of                             // CAN layer messages are not Addressed in the MTI bits
        MTI_AME  : begin
                    if CANBuffer^.DataCount = 6 then                            // Does the data contain the correct number of bytes for a Node ID?
                    begin                                                       // The message is for a specific Node
                      NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 0);
                      Node := NMRAnetNode_FindByNodeID(NodeID);                 // *************** Need to characterize how much time this may take with a large number of nodes
                      if Node <> nil then
                      begin
                        if NMRAnetNode_TestStateFlag(Node, NS_PERMITTED) then                // Only reply if node is in Permitted state
                          Node^.MsgFlags := Node^.MsgFlags or MF_ALIAS_MAP_ENQUIRY;
                      end
                    end else
                    begin
                      if CANBuffer^.DataCount = 0 then                            // Is the message for all Nodes?
                        NMRAnetNode_SetMsgFlagsOnAllNodesOnPermittedNodes(MF_ALIAS_MAP_ENQUIRY);    // Need to characterize how much time this may take with a large number of nodes
                    end
                  end;
        MTI_AMD  : begin
                    if CANBuffer^.DataCount = 6 then                            // Does the data contain the correct number of bytes for a Node ID?
                    begin
                      NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 0);
                      Node := NMRAnetNode_FindByNodeID(NodeID);                 // *************** Need to characterize how much time this may take with a large number of nodes
                      if Node <> nil then
                        Node^.MsgFlags := Node^.MsgFlags or MF_DUPLICATE_NODE_ID;
                    end
                  end;
        MTI_AMR  : begin
                  end;
      end;
    end
  end
end;

// *****************************************************************************
//  procedure ReceivedOnFilter1
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 1 which is defined
//                  as any NMRABus level message (bit 26 = 1)
//
// *****************************************************************************
procedure ReceivedOnFilter1(CANBuffer: PCANBuffer);                             // NMRAnet Layer Message
var
  DoDefault: Boolean;
  Node: PNMRAnetNode;
  NodeID: TNodeID;
  DataBuffer: PDataBuffer;
  BaseBuffer: PBaseBuffer;
  DatagramBuffer: PDatagramBuffer;
  SourceAlias: Word;
  VNodeSupports, PhysicalNodeSupports: Boolean;
  i: Integer;
  Offset: Byte;
  
//  s1: array[0..32] of char;
  
  
begin

  //UART1_Write_Text('NMRAnet'+LF);
  TMR4 := 0;
  
  DoDefault := True;
  if NMRAnetLayerReceiveHook <> nil then
    NMRAnetLayerReceiveHook(CANBuffer, DoDefault);                              // Allow the program to have a crack at the message handler
    
  if DoDefault then
  begin
    SourceAlias := NMRAnetUtilities_ExtractSourceAlias(CANBuffer);
    Node := NMRAnetNode_FindByAlias(SourceAlias);
    if Node <> nil then
    begin
      Node^.MsgFlags := Node^.MsgFlags or MF_DUPLICATE_ALIAS                    // A "bad" duplicate Alias
    end else 
    begin
      case CANBuffer^.ID and MTI_TYPE_MASK of                                   // First subdivide between Unaddressed and Addressed Messages
        MTI_UNADDRESSED        : begin                                          // Unaddressed Messages
                                   case CANBuffer^.ID and MTI_UNADDRESSED_MASK of
                                     MTI_VERIFY_NODE_ID_NUMBER         : begin
                                                                           if (CANBuffer^.DataCount = 0) then                                      // THIS IS NOT CLEAR IN THE SPEC
                                                                             NMRAnetNode_SetMsgFlagsOnAllNodesOnPermittedNodes(MF_VERIFY_NODE_ID)  // Need to characterize how much time this may take with a large number of nodes
                                                                           else
                                                                           if (CANBuffer^.DataCount = 6) then                                      // THIS IS NOT CLEAR IN THE SPEC
                                                                           begin
                                                                             NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 0);
                                                                             Node := NMRAnetNode_FindByNodeID(NodeID);
                                                                             if Node <> nil then
                                                                               NMRAnetNode_SetMsgFlagsOnAllNodesOnPermittedNodes(MF_VERIFY_NODE_ID)  // Need to characterize how much time this may take with a large number of nodes
                                                                           end
                                                                        end;
                                     MTI_CONSUMER_IDENTIFY             : begin
                                                                          if Nodes.Count > 1 then    // First node is the Physical Node, do we have any vNodes Allocated?
                                                                            VNodeSupports := NMRAnetUtilities_SupportsVNodeEventAsConsumer(@CANBuffer^.DataBytes)
                                                                          else
                                                                            VNodeSupports := False;
                                                                          PhysicalNodeSupports := NMRAnetUtilities_SupportsEventAsConsumer(@CANBuffer^.DataBytes);
                                                                          if VNodeSupports or PhysicalNodeSupports then
                                                                          begin
                                                                            if NMRAnetBufferPools_AllocateDataBuffer(DataBuffer) then
                                                                            begin
                                                                              DataBuffer^.mCode := BMC_CONSUMER_IDENTIFY;
                                                                              DataBuffer^.Alias := SourceAlias;
                                                                              DataBuffer^.Count := CANBuffer^.DataCount;
                                                                              DataBuffer^.DataBytes := CANBuffer^.DataBytes;
                                                                              DataBuffer^.RefCount := 0;                         // We manipulate this manually

                                                                              if VNodeSupports then
                                                                              begin
                                                                                DataBuffer^.RefCount := Nodes.Count - 1;
                                                                                for i := 1 to Nodes.Count - 1 do
                                                                                  NMRAnetUtilities_MsgBufferLink(@Nodes.RawList[i], PBaseBuffer( GenericPointerAdapter(DataBuffer)));
                                                                              end;

                                                                              if PhysicalNodeSupports then
                                                                              begin
                                                                                NMRAnetUtilities_MsgBufferLink(@Nodes.RawList[0], PBaseBuffer( GenericPointerAdapter(DataBuffer)));    //  Store it in the Nodes structure to distribute later
                                                                                Inc(DataBuffer^.RefCount);
                                                                              end
                                                                            end
                                                                          end
                                                                        end;
                                     MTI_CONSUMER_IDENTIFY_RANGE       : begin
                                                                          // TODO
                                                                        end;
                                     MTI_PRODUCER_IDENDIFY             : begin
                                                                          if Nodes.Count > 1 then     // First node is the Physical Node, do we have any vNodes Allocated?
                                                                            VNodeSupports := NMRAnetUtilities_SupportsVNodeEventAsProducer(@CANBuffer^.DataBytes)
                                                                          else
                                                                            VNodeSupports := False;
                                                                          PhysicalNodeSupports := NMRAnetUtilities_SupportsEventAsProducer(@CANBuffer^.DataBytes);

                                                                          if VNodeSupports or PhysicalNodeSupports then
                                                                          begin
                                                                            if NMRAnetBufferPools_AllocateDataBuffer(DataBuffer) then
                                                                            begin
                                                                              DataBuffer^.mCode := BMC_PRODUCER_IDENTIFY;
                                                                              DataBuffer^.Alias := SourceAlias;
                                                                              DataBuffer^.Count := CANBuffer^.DataCount;
                                                                              DataBuffer^.DataBytes := CANBuffer^.DataBytes;
                                                                              DataBuffer^.RefCount := 0;                         // We manipulate this manually

                                                                              if VNodeSupports then
                                                                              begin
                                                                                DataBuffer^.RefCount := Nodes.Count - 1;
                                                                                for i := 1 to Nodes.Count - 1 do
                                                                                  NMRAnetUtilities_MsgBufferLink(@Nodes.RawList[i], PBaseBuffer( GenericPointerAdapter(DataBuffer)));
                                                                              end;

                                                                              if PhysicalNodeSupports then
                                                                              begin
                                                                                NMRAnetUtilities_MsgBufferLink(@Nodes.RawList[0], PBaseBuffer( GenericPointerAdapter(DataBuffer)));    //  Store it in the Nodes structure to distribute later
                                                                                Inc(DataBuffer^.RefCount);
                                                                              end
                                                                            end
                                                                          end
                                                                        end;
                                     MTI_PRODUCER_IDENTIFY_RANGE       : begin
                                                                          // TODO
                                                                        end;
                                     MTI_EVENT_LEARN                   : begin
                                                                        { if NMRAnetBufferPools_AllocateDataBuffer(DataBuffer) then
                                                                          begin
                                                                            NMRAnetUtilities_MsgBufferLink(@Nodes, DataBuffer);
                                                                            DataBuffer^.RefCount := Nodes.Count;  // Assume they all will be getting the buffer for now
                                                                            DataBuffer^.mCode := BMC_EVENT_LEARN;
                                                                            DataBuffer^.Alias := SourceAlias;
                                                                            DataBuffer^.Count := CANBuffer^.DataCount;
                                                                            DataBuffer^.DataBytes := CANBuffer^.DataBytes;
                                                                          end     }
                                                                        end;
                                     MTI_EVENTS_IDENTIFY               : begin
                                                                          NMRAnetNode_SetMsgFlagsOnAllNodesOnPermittedNodes(MF_IDENTIFY_ALL_EVENTS);
                                                                        end;
                                   end
                                 end;
        MTI_RESERVED           : begin                                          // Unused as of June 2012
                                 end
      else begin                                                                // Addressed Messages
          Node := NMRAnetNode_FindByAlias(NMRAnetUtilities_ExtractDestinationAlias(CANBuffer));   // Extract the Node that the message is addressed to
          if Node <> nil then
          begin
            if NMRAnetNode_TestStateFlag(Node, NS_PERMITTED) then
            begin
              case CANBuffer^.ID and MTI_TYPE_MASK of                           // Now subdivide the Addressed down to Datagrams, Streams, Other Addressed
                MTI_ADDRESSED            : begin
                                             case CANBuffer^.Databytes[0] of                  // Generic Addressed message, need to look at the databytes[0] to find the reset of the MTI bits
                                               MTI_EXTENSION_VERIFY_NODE_ID_NUMBER_DEST       : begin 
                                                                                                  if CANBuffer^.DataCount = 1 then                                 // THIS IS NOT CLEAR IN THE SPEC, , with the $0A in Index 0
                                                                                                     NMRAnetNode_SetMsgFlag(Node, MF_VERIFY_NODE_ID)
                                                                                                  else
                                                                                                  if CANBuffer^.DataCount = 7 then                                 // THIS IS NOT CLEAR IN THE SPEC
                                                                                                  begin
                                                                                                    NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 1); // Extract the 48 Bit ID, with the $0A in Index 0
                                                                                                    Node := NMRAnetNode_FindByNodeID(NodeID);
                                                                                                    if Node <> nil then                                                 // If addressed to us then respond
                                                                                                      NMRAnetNode_SetMsgFlag(Node, MF_VERIFY_NODE_ID)
                                                                                                  end
                                                                                                end;
                                               MTI_EXTENSION_PROTOCOL_SUPPORT_QUERY           : begin 
                                                                                                  if NMRAnetBufferPools_AllocateBaseBuffer(BaseBuffer) then
                                                                                                  begin
                                                                                                    NMRAnetUtilities_MsgBufferLink(Node, BaseBuffer);
                                                                                                    BaseBuffer^.mCode := BMC_PROTOCOL_SUPPORT_QUERY;
                                                                                                    BaseBuffer^.Alias := SourceAlias
                                                                                                  end
                                                                                                end;
                                               MTI_EXTENSION_IDENTIFY_EVENTS                  : begin
                                                                                                  NMRAnetNode_SetMsgFlag(Node, MF_IDENTIFY_ALL_EVENTS);
                                                                                                end;
                                               MTI_EXTENSION_DATAGRAM_RECIEVED_OK             : begin end;  // DispatchDatagramReceivedOk(NodeBuffer, CANBuffer);
                                               MTI_EXTENSION_DATAGRAM_REJECTED                : begin end;  // DispatchDatagramRejected(NodeBuffer, CANBuffer)
                                               MTI_EXTENSION_SIMPLENODE_IDENTIFY_INFO_REQUEST : begin
                                                                                                  if NMRAnetBufferPools_AllocateBaseBuffer(BaseBuffer) then
                                                                                                  begin
                                                                                                    NMRAnetUtilities_MsgBufferLink(Node, BaseBuffer);
                                                                                                    BaseBuffer^.mCode := BMC_SIMPLE_NODE_INFO_REQEUST;
                                                                                                    BaseBuffer^.Alias := SourceAlias
                                                                                                  end;
                                                                                                end
                                              else
                                                if NMRAnetBufferPools_AllocateBaseBuffer(BaseBuffer) then
                                                begin
                                                  NMRAnetUtilities_MsgBufferLink(Node, BaseBuffer);
                                                  BaseBuffer^.mCode := BMC_UNKNOWN_ADDRESSED_MTI;
                                                  BaseBuffer^.Alias := SourceAlias
                                                end;
                                              end;
                                           end;
                MTI_DATAGRAM_ONLY_FRAME :  begin
                                             if NMRAnetBufferPools_AllocateDatagramBuffer(DatagramBuffer, False) then
                                             begin 
                                                NMRAnetUtilities_MsgBufferLink(Node, PBaseBuffer( GenericPointerAdapter(DatagramBuffer)));
                                                DatagramBuffer^.mCode := BMC_DATAGRAM;
                                                DatagramBuffer^.Alias := SourceAlias;
                                                DatagramBuffer^.iByteCount := CANBuffer^.DataCount;
                                                for i := 0 to DatagramBuffer^.iByteCount - 1 do
                                                  DatagramBuffer^.DataBytes[i] := CANBuffer^.DataBytes[i];
                                             end else
                                             begin
                                               if NMRAnetBufferPools_AllocateBaseBuffer(BaseBuffer) then    // We assume we will always allocate a BaseBuffer
                                               begin
                                                 NMRAnetUtilities_MsgBufferLink(Node, BaseBuffer);
                                                 BaseBuffer^.mCode := BMC_DATAGRAM_BUFFER_FULL;
                                                 BaseBuffer^.Alias := SourceAlias;
                                               end;
                                             end
                                           end;
                MTI_DATAGRAM_FRAME_START : begin
                                             if NMRAnetBufferPools_AllocateDatagramBuffer(DatagramBuffer, False) then
                                             begin
                                               NMRAnetUtilities_MsgBufferLink(Node, PBaseBuffer( GenericPointerAdapter(DatagramBuffer)));
                                               DatagramBuffer^.State := DatagramBuffer^.State or CBS_PROCESSING;          // Not ready for the main loop to work it yet.
                                               DatagramBuffer^.mCode := BMC_DATAGRAM;
                                               DatagramBuffer^.Alias := SourceAlias;
                                               DatagramBuffer^.iByteCount := CANBuffer^.DataCount;
                                               for i := 0 to DatagramBuffer^.iByteCount - 1 do
                                                 DatagramBuffer^.DataBytes[i] := CANBuffer^.DataBytes[i];
                                             end else
                                             begin
                                               if NMRAnetBufferPools_AllocateBaseBuffer(BaseBuffer) then    // We assume we will always allocate a BaseBuffer
                                               begin
                                                 NMRAnetUtilities_MsgBufferLink(Node, BaseBuffer);
                                                 BaseBuffer^.mCode := BMC_DATAGRAM_BUFFER_FULL;
                                                 BaseBuffer^.Alias := SourceAlias;
                                                 BaseBuffer^.State := BaseBuffer^.State or CBS_PROCESSING;                   // Hold off until the End Frame is found
                                               end;
                                             end
                                           end;
                MTI_DATAGRAM_FRAME       : begin
                                             if NMRAnetUtilities_MsgBufferFindDatagram(Node, SourceAlias, DatagramBuffer) then
                                             begin     // Normal Operation, going well so far we assume the sender will not send more than 72 bytes....
                                               Offset := DatagramBuffer^.iByteCount;
                                               for i := 0 to  CANBuffer^.DataCount - 1 do
                                                 DatagramBuffer^.DataBytes[Offset + i] := CANBuffer^.DataBytes[i];
                                               DatagramBuffer^.iByteCount := CANBuffer^.DataCount + Offset;
                                             end else
                                             if NMRAnetUtilities_MsgBufferFindDatagramErrorReply(Node, SourceAlias, BaseBuffer) then
                                             begin      // Don't do anything, let it run its course
                                             end else
                                             begin     // Sender sent an intermediate frame without a start frame
                                               if NMRAnetBufferPools_AllocateBaseBuffer(BaseBuffer) then
                                               begin
                                                 NMRAnetUtilities_MsgBufferLink(Node, BaseBuffer);
                                                 BaseBuffer^.mCode := BMC_DATAGRAM_OUT_OF_ORDER;
                                                 BaseBuffer^.Alias := SourceAlias;
                                                 BaseBuffer^.State := BaseBuffer^.State or CBS_PROCESSING;                   // Hold off until the End Frame is found
                                               end
                                             end
                                           end;
                MTI_DATAGRAM_FRAME_END   : begin
                                             if NMRAnetUtilities_MsgBufferFindDatagram(Node, SourceAlias, DatagramBuffer) then
                                             begin
                                               Offset := DatagramBuffer^.iByteCount;
                                               for i := 0 to  CANBuffer^.DataCount - 1 do
                                                 DatagramBuffer^.DataBytes[Offset + i] := CANBuffer^.DataBytes[i];
                                               DatagramBuffer^.iByteCount := CANBuffer^.DataCount + Offset;
                                               DatagramBuffer^.State := DatagramBuffer^.State and not CBS_PROCESSING;          // Signed Sealed so Deliver.
                                             end else
                                             if NMRAnetUtilities_MsgBufferFindDatagramErrorReply(Node, SourceAlias, BaseBuffer) then
                                             begin      // Don't do anything, let it run its course
                                               BaseBuffer^.State := BaseBuffer^.State and not CBS_PROCESSING;                 // Deliver the Error.
                                             end else
                                             begin     // Sender sent an intermediate frame without a start frame
                                               if NMRAnetBufferPools_AllocateBaseBuffer(BaseBuffer) then
                                               begin
                                                 NMRAnetUtilities_MsgBufferLink(Node, BaseBuffer);
                                                 BaseBuffer^.mCode := BMC_DATAGRAM_OUT_OF_ORDER;
                                                 BaseBuffer^.Alias := SourceAlias;
                                               end
                                             end
                                           end;
                MTI_STREAM_DATA_SEND     : begin
                                           end;
               end
            end
          end
        end;  // case, else
      end
    end;
  end;

  if TMR4 > MaxTime_RX then MaxTime_RX := TMR4;
end;

procedure ReceivedOnFilter2(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

procedure ReceivedOnFilter3(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

procedure ReceivedOnFilter4(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

procedure ReceivedOnFilter5(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

procedure ReceivedOnFilter6(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

end.