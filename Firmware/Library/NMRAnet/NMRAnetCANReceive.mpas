unit NMRAnetCANReceive;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRAnet CAN Receive StateMachine.  The user program does not need
//    to interact with this statemachine unless it needs to hook in for special purposes
//
// ******************************************************************************

uses
  NMRAnetDefines,
  NMRAnetUtilities,
  NMRAnetDatagrams,
  NMRAnetDatagramDefines,
  NMRAnetAppDefines,
  CANDefines;
  
type
  TPacketHandlerFunc = procedure(CANBuffer: PCANBuffer; var DoDefault: Boolean);
  PPacketHandlerFunc = ^TPacketHandlerFunc;
  
  procedure NMRAnetCANReceive_Initialize;
  function NMRAnetCANReceive_Permited: Boolean;
  procedure NMRAnetCANReceive_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);       // WARNING:  The Hook is called from within the Interrupt Handler.....
  procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);   // WARNING:  The Hook is called from within the Interrupt Handler.....

  // callbacks from the CAN interrupts used in the xxxxx_CAN_Interrupt.mpas units
  procedure ReceivedOnFilter0(Buffer: PCANBuffer);
  procedure ReceivedOnFilter1(Buffer: PCANBuffer);
  procedure ReceivedOnFilter2(Buffer: PCANBuffer);
  procedure ReceivedOnFilter3(Buffer: PCANBuffer);
  procedure ReceivedOnFilter4(Buffer: PCANBuffer);
  procedure ReceivedOnFilter5(Buffer: PCANBuffer);
  procedure ReceivedOnFilter6(Buffer: PCANBuffer);

implementation

var
  CANLayerReceiveHook: PPacketHandlerFunc;
  NMRAnetLayerReceiveHook: PPacketHandlerFunc;
  
// ****************************************************************************
// procedure NMRAnetCANReceive_Initialize
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_Initialize;
begin
  CANLayerReceiveHook := PPacketHandlerFunc( nil);
  NMRAnetLayerReceiveHook := PPacketHandlerFunc( nil);
end;
  
// ****************************************************************************
// procedure NMRAnetCANReceive_SetCANLayerReceiveHook
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  CANLayerReceiveHook := HookFunc
end;

// ****************************************************************************
// procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  NMRAnetLayerReceiveHook := HookFunc
end;

// *****************************************************************************
//  function NMRAnetCANReceive_Permited
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetCANReceive_Permited: Boolean;
begin
  Result := NMRABus.State and BS_PERMITED = BS_PERMITED
end;

// ****************************************************************************
// procedure GetComplexResponseBuffer
//
//  Description:   Returns first available ComplexResponseBuffer
//
// ****************************************************************************
function GetComplexResponseBuffer: PQueuedResponse;
var
  i, Count: Integer;
begin
  Result := nil; 
  i := 0;
  while i < LEN_QUEUED_RESPONSE_LIST do
  begin
    if NMRABus.Responses.List[i].nCode = CRC_EMPTY then
    begin
      Result := @NMRABus.Responses.List[i];
      Exit
    end;
    Inc(i);
  end;
end;

// ****************************************************************************
// procedure StoreComplexResponse
//
//  Description:   Called when the CAN receiver detects a duplicate Alias.
//
//
// ****************************************************************************
procedure StoreComplexResponse(CANBuffer: PCANBuffer; nCode, NodeAlias: Word; DataBytes: PCAN_DataBytes; DataCount: Byte);
var
  Buffer: PQueuedResponse;
begin
  // SHOULD WE CHECK FOR DUPLICATED RESPONSES IN THE LIST HERE??????????????????????????????????????????????
  // &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
  Buffer := GetComplexResponseBuffer;
  if Buffer <> nil then
  begin
    Buffer^.nCode := nCode;
    Buffer^.NodeAlias := NodeAlias;
    if DataBytes <> nil then                                                    // Sender has handled the Bytes already
    begin
      Buffer^.DataCount := DataCount;
      Buffer^.DataBytes := DataBytes^;
    end
  end else
    Inc(NMRABus.Responses.BufferOverrunCount)
end;

// *****************************************************************************
//  procedure CheckForUnKnownMTI
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function CheckForUnKnownMTI(Buffer: PCANBuffer): Boolean;
var
  DataBytes: TCAN_DataBytes;
begin
  Result := NMRAnetUtilities_UnknownMTI(Buffer^.DataBytes[0]);
  if Result then
  begin
    DataBytes[0] := MTI_OPTIONAL_INTERACTION_REJECTED;
    StoreComplexResponse(Buffer, CRC_OPTIONAL_INTERACTION_REJECTED, Buffer^.ID and MASK_SOURCE_ALIAS, @DataBytes, 1);
  end
end;

// *****************************************************************************
//  procedure CheckForUnKnownDatagramType
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function CheckForUnKnownDatagramType(Buffer: PCANBuffer): Boolean;
var
  DataBytes: TCAN_DataBytes;
begin
  Result := NMRAnetUtilities_UnknownDatagramType(Buffer^.DataBytes[0]);
  if Result then
  begin
    DataBytes[0] := MTI_DATAGRAM_REJECTED;
    DataBytes[1] := DATAGRAM_REJECTED_SOURCE_DATAGRAMS_NOT_ACCEPTED[0];
    DataBytes[2] := DATAGRAM_REJECTED_SOURCE_DATAGRAMS_NOT_ACCEPTED[1];
    StoreComplexResponse(Buffer, CRC_OPTIONAL_INTERACTION_REJECTED, Buffer^.ID and MASK_SOURCE_ALIAS, @DataBytes, 3);
  end;
end;

// ****************************************************************************
// procedure DispatchEqualAliasID
//
//  Description:   Called when the CAN receiver detects a duplicate Alias.
//
//  Response Layer:
//                 CAN Layer
//
//  Response Type:
//                 Simple Response
//
// ****************************************************************************
procedure DispatchEqualAliasID(CANBuffer: PCANBuffer);
begin
  if (CANBuffer^.ID and FT_CID_MASK <= FT_CID0) and (CANBuffer^.ID and FT_CID_MASK >= FT_CID4) then // If it is a CID message then force calling node to try again for an Alias this one is ours
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRC_SEND_RID
  else
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRC_DUPLICATE_ALIAS
end;

// ****************************************************************************
// procedure DispatchAliasMappingDefinition
//
//  Response Layer:
//                 CAN Layer
//
//  Response Type:
//                 Simple Response
//
// ****************************************************************************
procedure DispatchAliasMappingDefinition(CANBuffer: PCANBuffer);
var
  NodeID: TNodeID;
begin
  NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^, NodeID, 0);                    // Extract the 48 Bit ID
  if NMRAnetUtilities_EqualNodeID(NodeID) then                                  // If addressed to us then respond
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRC_DUPLICATE_NODE_ID;
end;

// ****************************************************************************
// procedure DispatchAliasMappingEnquiry
//
//  Response Layer:
//                 CAN Layer
//
//  Response Type:
//                 Simple Response
//
// ****************************************************************************
procedure DispatchAliasMappingEnquiry(CANBuffer: PCANBuffer);
var
  NodeID: TNodeID;
begin
  if CANBuffer^.DataCount = 6 then
  begin
    NMRAnetUtilities_PacketBytesToNodeID(CANBuffer, NodeID, 0);              // Extract the 48 Bit ID
    if NMRAnetUtilities_EqualNodeID(NodeID) then                          // If addressed to us then respond
      NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRC_SEND_AMD;
  end else
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRC_SEND_AMD;
end;

// ****************************************************************************
// procedure DispatchEventProducerIdenitify
//
//  Response Layer:
//                 NMRAnet Layer
//
//  Response Type:
//                 Complex Response
//
// ****************************************************************************
procedure DispatchEventProducerIdenitify(CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_SupportsEventAsProducer(@CANBuffer^.DataBytes) then
    StoreComplexResponse(CANBuffer, CRC_PRODUCER_IDENTIFIED, 0, @CANBuffer^.DataBytes, 7);
end;

// ****************************************************************************
// procedure DispatchEventConsumerIdenitify
//
//  Response Layer:
//                 NMRAnet Layer
//
//  Response Type:
//                 Complex Response
//
// ****************************************************************************
procedure DispatchEventConsumerIdenitify(CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_SupportsEventAsConsumer(@CANBuffer^.DataBytes) then
    StoreComplexResponse(CANBuffer, CRC_CONSUMER_IDENTIFIED, 0, @CANBuffer^.DataBytes, 7);
end;

// ****************************************************************************
// procedure DispatchVerifyNodeID
//
//  Response Layer:
//                 NMRAnet Layer
//
//  Response Type:
//                 Simple Response
//
// ****************************************************************************
procedure DispatchVerifyNodeID(CANBuffer: PCANBuffer);
var
  NodeID: TNodeID;
begin
  if (CANBuffer^.DataCount = 0) or (CANBuffer^.DataCount = 1)  then       // THIS IS NOT CLEAR IN THE SPEC
    NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRC_SEND_VERIFIED_NODE
  else
  if (CANBuffer^.DataCount = 6) or (CANBuffer^.DataCount = 7) then       // THIS IS NOT CLEAR IN THE SPEC
  begin
    if CANBuffer^.DataCount = 6 then
      NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^, NodeID, 0)              // Extract the 48 Bit ID
    else
      NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^, NodeID, 1);             // Extract the 48 Bit ID, with the $0A in Index 0
    if NMRAnetUtilities_EqualNodeID(NodeID) then                                  // If addressed to us then respond
     NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRC_SEND_VERIFIED_NODE
  end;
end;

// ****************************************************************************
// procedure DispatchIdentifyEvents
//
//  Response Layer:
//                 NMRAnet Layer
//
//  Response Type:
//                 Simple Response
//
// ****************************************************************************
procedure DispatchIdentifyEvents(CANBuffer: PCANBuffer);
begin
   NMRABus.Responses.SimpleResponseFlags := NMRABus.Responses.SimpleResponseFlags or SRC_ALL_CONSUMER_PRODUCER_IDENTIFIED;
end;

// ****************************************************************************
// procedure DispatchProtocolSupportInquiry
//
//  Response Layer:
//                 NMRAnet Layer
//
//  Response Type:
//                 Complex Response
//
// ****************************************************************************
procedure DispatchProtocolSupportInquiry(CANBuffer: PCANBuffer);
var
  DataBytes: TCAN_DataBytes;
  i, j: Integer;
begin
  NMRAnetUtilities_ZeroCANData(DataBytes);
  DataBytes[0] := $2F;
  for i := 0 to LEN_PIV_PROTOCOL-1 do
    for j := 0 to PIV_SUPPORTED_PROTOCOL_COUNT - 1 do
      DataBytes[i+1] := DataBytes[i+1] or PIV_SUPPORTED_PROTOCOLS[j][i];
  StoreComplexResponse(CANBuffer, CRC_SEND_PROTOCOL_SUPPORT, CANBuffer^.ID and MASK_SOURCE_ALIAS, @DataBytes, 7);
end;

// ****************************************************************************
// procedure ReceivedUnAddressedMessage
//
//  Response Layer:
//                 NMRAnet Layer
//
//  Response Type:
//                 Simple/Complex Response
//
// ****************************************************************************
procedure ReceivedUnAddressedMessage(CANBuffer: PCANBuffer);
begin
  case CANBuffer^.ID and FT_UNADDRESSED_MASK of
    FT_VERIFY_NODE_ID_NUMBER         : DispatchVerifyNodeID(CANBuffer);
    FT_CONSUMER_IDENTIFY             : DispatchEventConsumerIdenitify(CANBuffer);
//    FT_CONSUMER_IDENTIFIED           : begin end; // TODO
 //   FT_CONSUMER_IDENTIFY_RANGE       : begin end; // TODO
    FT_PRODUCER_IDENDIFY             : DispatchEventProducerIdenitify(CANBuffer);
 //   FT_PRODUCER_IDENTIFIED           : begin end; // TODO
 //   FT_PRODUCER_IDENTIFY_RANGE       : begin end; // TODO
    FT_EVENT_LEARN                   : begin end; // TODO
    FT_EVENTS_IDENTIFY               : DispatchIdentifyEvents(CANBuffer);
    FT_PC_EVENT_REPORT               : begin end; // TODO
  end
end;



// ****************************************************************************
// procedure ReceivedAddressedMessage
//
//  Response Layer:
//                 NMRAnet Layer
//
//  Response Type:
//                 Simple/Complex Response on an addressed message that is NOT a Datagram or Stream
//
// ****************************************************************************
procedure ReceivedAddressedMessage(CANBuffer: PCANBuffer);
var
  Buffer: PQueuedResponse;
begin

 // UART1_Write_Text('Addressed'+LF);
  
  if NMRAnetUtilities_IsAddressedMessageToNode(CANBuffer) then
  begin
    if not CheckForUnKnownMTI(CANBuffer) then
    begin
      case CANBuffer^.Databytes[0] of
        MTI_VERIFY_NODE_ID_NUMBER_DEST       : DispatchVerifyNodeID(CANBuffer);
        MTI_PROTOCOL_SUPPORT_QUERY           : DispatchProtocolSupportInquiry(CANBuffer);
  //      MTI_PROTOCOL_SUPPORT_REPLY           : begin end;  // TODO
  //      MTI_OPTIONAL_INTERACTION_REJECTED    : begin end;  // TODO
  //      MTI_TERMINATE_DUE_TO_ERROR           : begin end;  // TODO
        MTI_IDENTIFY_EVENTS                  : DispatchIdentifyEvents(CANBuffer);
        MTI_SIMPLENODE_IDENTIFY_INFO_REQUEST : begin end;  // TODO
        MTI_SIMPLENODE_IDENTIFY_INFO_REPLY   : begin end;   // TODO
   //   else
        // TODO SEND A Optional Rejected to sender, in draft spec but not in "offical S"
      end
    end
  end
end;

// ****************************************************************************
// procedure ReceivedDatagramMessage
//
//  Response Layer:
//                 NMRAnet Layer
//
//  Response Type:
//                 Simple/Complex Response
//
// ****************************************************************************
procedure ReceivedDatagramMessage(CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_IsAddressedMessageToNode(CANBuffer) then
    NMRAnetDatagrams_ProcessReceive(CANBuffer)
end;

// ****************************************************************************
// procedure ReceivedDatagramMessage
//
//  Response Layer:
//                 NMRAnet Layer
//
//  Response Type:
//                 Simple/Complex Response
//
// ****************************************************************************
procedure ReceivedStartingDatagramMessage(CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_IsAddressedMessageToNode(CANBuffer) then
    if not CheckForUnKnownDatagramType(CANBuffer) then
      NMRAnetDatagrams_ProcessReceive(CANBuffer)
end;

// ****************************************************************************
// procedure ReceivedStreamMessage
//
//  Response Layer:
//                 NMRAnet Layer
//
//  Response Type:
//                 Simple/Complex Response
//
// ****************************************************************************
procedure ReceivedStreamMessage(CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_IsAddressedMessageToNode(CANBuffer) then
  begin
  end
end;

// *****************************************************************************
//  procedure ReceivedOnFilter0
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 0 which is defined
//                  as any CAN level message (bit 26 = 0)
//
// *****************************************************************************
procedure ReceivedOnFilter0(CANBuffer: PCANBuffer);                             // CAN Layer Message
var
  DoDefault: Boolean;
begin

// UART1_Write_Text('CAN'+LF);

  DoDefault := True;
  if CANLayerReceiveHook <> nil then
    CANLayerReceiveHook(CANBuffer, DoDefault);
  if DoDefault then
  begin
    if NMRAnetUtilities_EqualAliasID(CANBuffer^.ID and MASK_SOURCE_ALIAS) then  // This is ALWAYS checked regardless of permitted state
      DispatchEqualAliasID(CANBuffer);

    if NMRAnetCANReceive_Permited then
    begin
      case CANBuffer^.ID and FT_UNADDRESSED_MASK of
        FT_AME : DispatchAliasMappingEnquiry(CANBuffer);
        FT_AMD : DispatchAliasMappingDefinition(CANBuffer);
      end
    end;
  end;
end;

// *****************************************************************************
//  procedure ReceivedOnFilter1
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 1 which is defined
//                  as any NMRABus level message (bit 26 = 1)
//
// *****************************************************************************
procedure ReceivedOnFilter1(CANBuffer: PCANBuffer);                             // NMRAnet Layer Message
var
  DoDefault: Boolean;
begin

 // UART1_Write_Text('NMRAnet'+LF);
 
  TMR4 := 0;

  DoDefault := True;
  if NMRAnetLayerReceiveHook <> nil then
    NMRAnetLayerReceiveHook(CANBuffer, DoDefault);                              // Allow the program to have a crack at the message handler

  if DoDefault then
  begin
    if NMRAnetUtilities_EqualAliasID(CANBuffer^.ID and MASK_SOURCE_ALIAS) then  // This is ALWAYS checked regardless of permitted state
      DispatchEqualAliasID(CANBuffer);

    if NMRAnetCANReceive_Permited then
    begin
      case CANBuffer^.ID and MTI_TYPE_MASK of
        MTI_UNADDRESSED              : ReceivedUnAddressedMessage(CANBuffer);
        MTI_RESERVED                 : begin end;
        MTI_DATAGRAM_ONLY_FRAME,
        MTI_DATAGRAM_FRAME_START     : ReceivedStartingDatagramMessage(CANBuffer);
        MTI_DATAGRAM_FRAME,
        MTI_DATAGRAM_FRAME_END       : ReceivedDatagramMessage(CANBuffer);
        MTI_ADDRESSED                : ReceivedAddressedMessage(CANBuffer);
        MTI_STREAM_DATA_SEND         : ReceivedStreamMessage(CANBuffer);
      end;
    end;
  end;
  
  if TMR4 > MaxTime_RX then
  begin
    MaxTime_RX := TMR4;
  end;
end;

// *****************************************************************************
//  procedure ReceivedOnFilter2
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 2
//
// *****************************************************************************
procedure ReceivedOnFilter2(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter3
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 3
//
// *****************************************************************************
procedure ReceivedOnFilter3(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter4
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 4
//
// *****************************************************************************
procedure ReceivedOnFilter4(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter5
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 5
//
// *****************************************************************************
procedure ReceivedOnFilter5(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter6
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 6
//
// *****************************************************************************
procedure ReceivedOnFilter6(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

end.