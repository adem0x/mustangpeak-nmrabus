unit NMRAnetCANReceive;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRAnet CAN Receive StateMachine.  The user program does not need
//    to interact with this statemachine unless it needs to hook in for special purposes
//
// ******************************************************************************

uses
  NMRAnetAbbreviatedConfigurationProtocol,
  NMRAnetAbbreviatedConfigurationProtocolDefines,
  NMRAnetDefines,
  NMRAnetUtilities,
  NMRAnetDatagrams,
  NMRAnetDatagramDefines,
  NMRAnetAppDefines,
  CANDefines;
  
type
  TPacketHandlerFunc = procedure(CANBuffer: PCANBuffer; var DoDefault: Boolean);
  PPacketHandlerFunc = ^TPacketHandlerFunc;
  
  procedure NMRAnetCANReceive_Initialize;
  function NMRAnetCANReceive_Permited(NodeBuffer: PNMRAnetNode): Boolean;
  procedure NMRAnetCANReceive_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);       // WARNING:  The Hook is called from within the Interrupt Handler.....
  procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);   // WARNING:  The Hook is called from within the Interrupt Handler.....
  function NMRAnetCANReceive_AllocateActions(NodeBuffer: PNMRAnetNode): Boolean;

  // callbacks from the CAN interrupts used in the xxxxx_CAN_Interrupt.mpas units
  procedure ReceivedOnFilter0(Buffer: PCANBuffer);
  procedure ReceivedOnFilter1(Buffer: PCANBuffer);
  procedure ReceivedOnFilter2(Buffer: PCANBuffer);
  procedure ReceivedOnFilter3(Buffer: PCANBuffer);
  procedure ReceivedOnFilter4(Buffer: PCANBuffer);
  procedure ReceivedOnFilter5(Buffer: PCANBuffer);
  procedure ReceivedOnFilter6(Buffer: PCANBuffer);

implementation

var
  CANLayerReceiveHook: PPacketHandlerFunc;
  NMRAnetLayerReceiveHook: PPacketHandlerFunc;
  
// ****************************************************************************
// procedure NMRAnetCANReceive_Initialize
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_Initialize;
begin
  CANLayerReceiveHook := PPacketHandlerFunc( nil);
  NMRAnetLayerReceiveHook := PPacketHandlerFunc( nil);
end;
  
// ****************************************************************************
// procedure NMRAnetCANReceive_SetCANLayerReceiveHook
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  CANLayerReceiveHook := HookFunc
end;

// ****************************************************************************
// procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  NMRAnetLayerReceiveHook := HookFunc
end;

// *****************************************************************************
//  function NMRAnetCANReceive_Permited
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetCANReceive_Permited(NodeBuffer: PNMRAnetNode): Boolean;
begin
  Result := NodeBuffer^.State and BS_PERMITED = BS_PERMITED
end;

// *****************************************************************************
//  function NMRAnetCANReceive_AllocateActions
//     Parameters:
//     Returns:
//
//     Description:
//
// *****************************************************************************
function NMRAnetCANReceive_AllocateActions(NodeBuffer: PNMRAnetNode): Boolean;
begin
//  Get a TQueuedAction from the pool here
  if NodeBuffer^.Actions = nil then
    NodeBuffer^.Actions := @QueuedActions;
  Result := True;
end;

// ****************************************************************************
// procedure GetComplexActionBuffer
//
//  Description:   Returns first available ComplexActionBuffer
//
// ****************************************************************************
function GetComplexActionBuffer(NodeBuffer: PNMRAnetNode): PQueuedAction;
var
  i: Integer;
begin
  Result := nil; 
  if NodeBuffer^.Actions <> nil then
  begin
    i := 0;
    while i < LEN_QUEUED_ACTION_LIST do
    begin
      if NodeBuffer^.Actions^.List[i].nCode = CRC_EMPTY then
      begin
        Result := @NodeBuffer^.Actions^.List[i];
        Exit
      end;
      Inc(i);
    end;
  end
end;

// ****************************************************************************
// procedure StoreComplexAction
//
//  Description:   Called when the CAN receiver detects a duplicate Alias.
//
//
// ****************************************************************************
procedure StoreComplexAction(NodeBuffer: PNMRAnetNode; nCode, NodeAlias: Word; DataBytes: PCAN_DataBytes; DataCount: Byte);
var
  Buffer: PQueuedAction;
begin
  // SHOULD WE CHECK FOR DUPLICATED ActionS IN THE LIST HERE??????????????????????????????????????????????
  // &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
  
  Buffer := GetComplexActionBuffer(NodeBuffer);                                // Get a free Action Buffer
  if Buffer <> nil then
  begin
    Buffer^.nCode := nCode;                                                     // Store the Code of the Action
    Buffer^.FromAlias := NodeAlias;                                             // Store the Node that sent the message that requires a Action (if applicable for the Action)
    if DataBytes <> nil then
    begin
      Buffer^.DataCount := DataCount;                                           // Store the DataCount for the DataBytes sent in the CAN message (if applicable for the Action)
      Buffer^.DataBytes := DataBytes^;                                          // Store the actual DataBytes sent in the CAN message (if applicable for the Action)
    end
  end else
  begin
    if NMRAnetCANReceive_AllocateActions(NodeBuffer) then
      Inc(NodeBuffer^.Actions^.BufferOverrunCount)
  end
end;

// ****************************************************************************
// procedure DispatchEqualAliasID
//
//  Description:   Called when the CAN receiver detects a duplicate Alias.
//
//  Action Layer:
//                 CAN Layer
//
//  Action Type:
//                 Simple Action
//
// ****************************************************************************
procedure DispatchEqualAliasID(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  if NMRAnetCANReceive_AllocateActions(NodeBuffer) then
  begin
    if (CANBuffer^.ID and FT_CID_MASK <= FT_CID0) and (CANBuffer^.ID and FT_CID_MASK >= FT_CID4) then // If it is a CID message then force calling node to try again for an Alias this one is ours
      NodeBuffer^.Actions^.SimpleActionFlags := NodeBuffer^.Actions^.SimpleActionFlags or SRC_SEND_RID
    else
      NodeBuffer^.Actions^.SimpleActionFlags := NodeBuffer^.Actions^.SimpleActionFlags or SRC_DUPLICATE_ALIAS
  end
end;

// ****************************************************************************
// procedure DispatchAliasMappingDefinition
//
//  Action Layer:
//                 CAN Layer
//
//  Action Type:
//                 Simple Action
//
// ****************************************************************************
procedure DispatchAliasMappingDefinition(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
var
  NodeID: TNodeID;
begin
  if NMRAnetCANReceive_AllocateActions(NodeBuffer) then
  begin
    NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 0);       // Extract the 48 Bit ID
    if NMRAnetUtilities_EqualNodeID(NodeBuffer, NodeID) then                                  // If address is duplicate then we need to respond with critical error
      NodeBuffer^.Actions^.SimpleActionFlags := NodeBuffer^.Actions^.SimpleActionFlags or SRC_DUPLICATE_NODE_ID
    else
      StoreComplexAction(NodeBuffer, CRC_AMD, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 6);
  end
end;

// ****************************************************************************
// procedure DispatchAliasMappingReset
//
//  Action Layer:
//                 CAN Layer
//
//  Action Type:
//                 Simple Action
//
// ****************************************************************************
procedure DispatchAliasMappingReset(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  StoreComplexAction(NodeBuffer, CRC_AMR, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 6);
end;



// ****************************************************************************
// procedure DispatchAliasMappingEnquiry
//
//  Action Layer:
//                 CAN Layer
//
//  Action Type:
//                 Simple Action
//
// ****************************************************************************
procedure DispatchAliasMappingEnquiry(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
var
  NodeID: TNodeID;
begin
  if NMRAnetCANReceive_AllocateActions(NodeBuffer) then
  begin
    if CANBuffer^.DataCount = 6 then
    begin
      NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 0);     // Extract the 48 Bit ID
      if NMRAnetUtilities_EqualNodeID(NodeBuffer, NodeID) then                                // If addressed to us then respond
        NodeBuffer^.Actions^.SimpleActionFlags := NodeBuffer^.Actions^.SimpleActionFlags or SRC_SEND_AMD;
    end else
      NodeBuffer^.Actions^.SimpleActionFlags := NodeBuffer^.Actions^.SimpleActionFlags or SRC_SEND_AMD;
  end
end;

// ****************************************************************************
// procedure DispatchEventProducerIdenitify
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Complex Action
//
// ****************************************************************************
procedure DispatchEventProducerIdenitify(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_SupportsEventAsProducer(@CANBuffer^.DataBytes) then
    StoreComplexAction(NodeBuffer, CRC_SEND_PRODUCER_IDENTIFIED, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 8);
end;

// ****************************************************************************
// procedure DispatchEventProducerIdenitified
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Complex Action
//
// ****************************************************************************
procedure DispatchEventProducerIdenitified(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  StoreComplexAction(NodeBuffer, CRC_PRODUCER_IDENTIFIED, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 8);
end;

// ****************************************************************************
// procedure DispatchEventConsumerIdenitify
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Complex Action
//
// ****************************************************************************
procedure DispatchEventConsumerIdenitify(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_SupportsEventAsConsumer(@CANBuffer^.DataBytes) then
    StoreComplexAction(NodeBuffer, CRC_SEND_CONSUMER_IDENTIFIED, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 8);
end;

// ****************************************************************************
// procedure DispatchEventConsumerIdenitified
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Complex Action
//
// ****************************************************************************
procedure DispatchEventConsumerIdenitified(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  StoreComplexAction(NodeBuffer, CRC_CONSUMER_IDENTIFIED, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 8);
end;

// ****************************************************************************
// procedure DispatchPCEventReportIdenitified
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Complex Action
//
// ****************************************************************************
procedure DispatchPCEventReportIdenitified(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  StoreComplexAction(NodeBuffer, CRC_PC_EVENT_REPORT, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 8);
end;

// ****************************************************************************
// procedure DispatchVerifyNodeID
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple Action
//
// ****************************************************************************
procedure DispatchVerifyNodeID(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
var
  NodeID: TNodeID;
begin
  if NMRAnetCANReceive_AllocateActions(NodeBuffer) then
  begin
    if (CANBuffer^.DataCount = 0) or (CANBuffer^.DataCount = 1)  then       // THIS IS NOT CLEAR IN THE SPEC
    begin
      NodeBuffer^.Actions^.SimpleActionFlags := NodeBuffer^.Actions^.SimpleActionFlags or SRC_SEND_VERIFIED_NODE
    end else
    if (CANBuffer^.DataCount = 6) or (CANBuffer^.DataCount = 7) then       // THIS IS NOT CLEAR IN THE SPEC
    begin
      if CANBuffer^.DataCount = 6 then
        NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 0)              // Extract the 48 Bit ID
      else
        NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 1);             // Extract the 48 Bit ID, with the $0A in Index 0

      if NMRAnetUtilities_EqualNodeID(NodeBuffer, NodeID) then                                  // If addressed to us then respond
       NodeBuffer^.Actions^.SimpleActionFlags := NodeBuffer^.Actions^.SimpleActionFlags or SRC_SEND_VERIFIED_NODE
    end;
  end
end;

// ****************************************************************************
// procedure DispatchVerifiedNodeID
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple Action
//
// ****************************************************************************
procedure DispatchVerifiedNodeID(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  StoreComplexAction(NodeBuffer, CRC_VERIFIED_NODE_ID, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 8);
end;

// ****************************************************************************
// procedure DispatchIdentifyEvents
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple Action
//
// ****************************************************************************
procedure DispatchIdentifyEvents(NodeBuffer: PNMRAnetNode);
begin
  if NMRAnetCANReceive_AllocateActions(NodeBuffer) then
    NodeBuffer^.Actions^.SimpleActionFlags := NodeBuffer^.Actions^.SimpleActionFlags or SRC_SEND_ALL_CONSUMER_PRODUCER_IDENTIFIED;
end;

// ****************************************************************************
// procedure DispatchDatagramReceivedOk
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple Action
//
// ****************************************************************************
procedure DispatchDatagramReceivedOk(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  StoreComplexAction(NodeBuffer, CRC_DATAGRAM_RECEIVED_OK, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 1);
end;

// ****************************************************************************
// procedure DispatchDatagramRejected
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple Action
//
// ****************************************************************************
procedure DispatchDatagramRejected(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  StoreComplexAction(NodeBuffer, CRC_DATAGRAM_REJECTED, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 3);
end;

// ****************************************************************************
// procedure DispatchAbbreviatedCDIRequest
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Complex Action only because the Sender Alias is needed
//
// ****************************************************************************
procedure DispatchAbbreviatedCDIRequest(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  StoreComplexAction(NodeBuffer, CRC_ACDI_REQUEST, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 0);
end;

// ****************************************************************************
// procedure DispatchAbbreviatedCDIReply
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Complex Action
//
// ****************************************************************************
procedure DispatchAbbreviatedCDIReply(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
var
  ActiveBuffer: PACDI_ReceiveBuffer;
  DataBytes: TCAN_DataBytes;
begin
  ActiveBuffer := PACDI_ReceiveBuffer( nil);
  if NMRAnetAbbreviatedConfigurationProtocol_ProcessReceiveFromInterruptContext(NodeBuffer, ActiveBuffer, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes) then
  begin
    DataBytes[0] := Lo( ActiveBuffer);                                         // Slip the buffer address in through the DataBytes
    DataBytes[1] := Hi( ActiveBuffer);
    StoreComplexAction(NodeBuffer, CRC_ACDI_REPLY, ActiveBuffer^.SourceAlias, @DataBytes, 2);
  end
end;



// ****************************************************************************
// procedure DispatchProtocolSupportInquiry
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Complex Action
//
// ****************************************************************************
procedure DispatchProtocolSupportInquiry(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
var
  DataBytes: TCAN_DataBytes;
  i, j: Integer;
begin
  NMRAnetUtilities_ZeroCANData(DataBytes);
  DataBytes[0] := $2F;
  for i := 0 to LEN_PIV_PROTOCOL-1 do
    for j := 0 to PIV_SUPPORTED_PROTOCOL_COUNT - 1 do
      DataBytes[i+1] := DataBytes[i+1] or PIV_SUPPORTED_PROTOCOLS[j][i];
  StoreComplexAction(NodeBuffer, CRC_SEND_PROTOCOL_SUPPORT, CANBuffer^.ID and MASK_SOURCE_ALIAS, @DataBytes, 7);
end;

// ****************************************************************************
// procedure ReceivedUnAddressedMessage
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple/Complex Action
//
// ****************************************************************************
procedure ReceivedUnAddressedMessage(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  case CANBuffer^.ID and FT_UNADDRESSED_MASK of
    FT_VERIFY_NODE_ID_NUMBER         : DispatchVerifyNodeID(NodeBuffer, CANBuffer);
    FT_VERIFIED_NODE_ID_NUMBER       : DispatchVerifiedNodeID(NodeBuffer, CANBuffer);
    FT_CONSUMER_IDENTIFY             : DispatchEventConsumerIdenitify(NodeBuffer, CANBuffer);
    FT_CONSUMER_IDENTIFIED           : DispatchEventConsumerIdenitified(NodeBuffer, CANBuffer);
 //   FT_CONSUMER_IDENTIFY_RANGE       : begin end; // TODO
    FT_PRODUCER_IDENDIFY             : DispatchEventProducerIdenitify(NodeBuffer, CANBuffer);
    FT_PRODUCER_IDENTIFIED           : DispatchEventProducerIdenitified(NodeBuffer, CANBuffer);
 //   FT_PRODUCER_IDENTIFY_RANGE       : begin end; // TODO
    FT_EVENT_LEARN                   : begin end; // TODO
    FT_EVENTS_IDENTIFY               : DispatchIdentifyEvents(NodeBuffer);
    FT_PC_EVENT_REPORT               : DispatchPCEventReportIdenitified(NodeBuffer, CANBuffer);
  end
end;



// ****************************************************************************
// procedure ReceivedAddressedMessage
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple/Complex Action on an addressed message that is NOT a Datagram or Stream
//
// ****************************************************************************
procedure ReceivedAddressedMessage(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
var
  DataBytes: TCAN_DataBytes;
begin

 // UART1_Write_Text('Addressed'+LF);
  
  if NMRAnetUtilities_IsAddressedMessageToNode(NodeBuffer, CANBuffer) then
  begin
  //  UART1_Write_Text('To Us'+LF);
    
    case CANBuffer^.Databytes[0] of
      MTI_TYPE_VERIFY_NODE_ID_NUMBER_DEST       : DispatchVerifyNodeID(NodeBuffer, CANBuffer);
      MTI_TYPE_PROTOCOL_SUPPORT_QUERY           : DispatchProtocolSupportInquiry(NodeBuffer, CANBuffer);
//      MTI_PROTOCOL_SUPPORT_REPLY           : begin end;  // TODO
//      MTI_OPTIONAL_INTERACTION_REJECTED    : begin end;  // TODO
//      MTI_TERMINATE_DUE_TO_ERROR           : begin end;  // TODO
      MTI_TYPE_IDENTIFY_EVENTS                  : DispatchIdentifyEvents(NodeBuffer);
      MTI_TYPE_SIMPLENODE_IDENTIFY_INFO_REQUEST : DispatchAbbreviatedCDIRequest(NodeBuffer, CANBuffer);
      MTI_TYPE_SIMPLENODE_IDENTIFY_INFO_REPLY   : DispatchAbbreviatedCDIReply(NodeBuffer, CANBuffer);
      MTI_TYPE_DATAGRAM_RECIEVED_OK             : DispatchDatagramReceivedOk(NodeBuffer, CANBuffer);
      MTI_TYPE_DATAGRAM_REJECTED                : DispatchDatagramRejected(NodeBuffer, CANBuffer)
    else begin
        DataBytes[0] := MTI_TYPE_OPTIONAL_INTERACTION_REJECTED;
        StoreComplexAction(NodeBuffer, CRC_SEND_OPTIONAL_INTERACTION_REJECTED, CANBuffer^.ID and MASK_SOURCE_ALIAS, @DataBytes, 1);
      end;
    end
  end
end;

// ****************************************************************************
// procedure ReceivedDatagramMessage
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple/Complex Action
//
// ****************************************************************************
procedure ReceivedDatagramMessage(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_IsAddressedMessageToNode(NodeBuffer, CANBuffer) then
    NMRAnetDatagrams_ProcessReceiveFromInterruptContext(Nodebuffer, CANBuffer)
end;

// ****************************************************************************
// procedure ReceivedDatagramMessage
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple/Complex Action
//
// ****************************************************************************
procedure ReceivedStartingDatagramMessage(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_IsAddressedMessageToNode(NodeBuffer, CANBuffer) then
    NMRAnetDatagrams_ProcessReceiveFromInterruptContext(NodeBuffer, CANBuffer)
end;

// ****************************************************************************
// procedure ReceivedStreamMessage
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple/Complex Action
//
// ****************************************************************************
procedure ReceivedStreamMessage(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_IsAddressedMessageToNode(NodeBuffer, CANBuffer) then
  begin
  end
end;

function FindMatchingNodeBuffer(CANBuffer: PCANBuffer): PNMRAnetNode;
begin
  Result := @NMRAnetNode;  // TODO vNode Buffers
end;

// *****************************************************************************
//  procedure ReceivedOnFilter0
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 0 which is defined
//                  as any CAN level message (bit 26 = 0)
//
// *****************************************************************************
procedure ReceivedOnFilter0(CANBuffer: PCANBuffer);                             // CAN Layer Message
var
  DoDefault: Boolean;
  NodeBuffer: PNMRAnetNode;
begin

 //UART1_Write_Text('CAN'+LF);

  DoDefault := True;
  NodeBuffer := FindMatchingNodeBuffer(CANBuffer);
  if NodeBuffer <> nil then
  begin
    if CANLayerReceiveHook <> nil then
      CANLayerReceiveHook(CANBuffer, DoDefault);
    if DoDefault then
    begin
      if NMRAnetUtilities_EqualAliasID(NodeBuffer, CANBuffer^.ID and MASK_SOURCE_ALIAS) then  // This is ALWAYS checked regardless of permitted state
        DispatchEqualAliasID(NodeBuffer, CANBuffer)
      else begin
        if NMRAnetCANReceive_Permited(NodeBuffer) then
        begin
          case CANBuffer^.ID and FT_UNADDRESSED_MASK of
            FT_AME : DispatchAliasMappingEnquiry(NodeBuffer, CANBuffer);
            FT_AMD : DispatchAliasMappingDefinition(NodeBuffer, CANBuffer);
            FT_AMR : DispatchAliasMappingReset(NodeBuffer, CANBuffer);
          end
        end
      end;
    end;
  end
end;

// *****************************************************************************
//  procedure ReceivedOnFilter1
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 1 which is defined
//                  as any NMRABus level message (bit 26 = 1)
//
// *****************************************************************************
procedure ReceivedOnFilter1(CANBuffer: PCANBuffer);                             // NMRAnet Layer Message
var
  DoDefault: Boolean;
  NodeBuffer: PNMRAnetNode;
begin

  //UART1_Write_Text('NMRAnet'+LF);
 
  TMR4 := 0;

  DoDefault := True;
  NodeBuffer := FindMatchingNodeBuffer(CANBuffer);
  
  if NodeBuffer <> nil then
  begin
    if NMRAnetLayerReceiveHook <> nil then
      NMRAnetLayerReceiveHook(CANBuffer, DoDefault);                              // Allow the program to have a crack at the message handler

    if DoDefault then
    begin
      if NMRAnetUtilities_EqualAliasID(NodeBuffer, CANBuffer^.ID and MASK_SOURCE_ALIAS) then  // This is ALWAYS checked regardless of permitted state
        DispatchEqualAliasID(NodeBuffer, CANBuffer)
      else begin
        if NMRAnetCANReceive_Permited(NodeBuffer) then
        begin
          case CANBuffer^.ID and MTI_TYPE_MASK of
            MTI_UNADDRESSED              : ReceivedUnAddressedMessage(NodeBuffer, CANBuffer);
            MTI_RESERVED                 : begin end;
            MTI_DATAGRAM_ONLY_FRAME,
            MTI_DATAGRAM_FRAME_START     : ReceivedStartingDatagramMessage(NodeBuffer, CANBuffer);
            MTI_DATAGRAM_FRAME,
            MTI_DATAGRAM_FRAME_END       : ReceivedDatagramMessage(NodeBuffer, CANBuffer);
            MTI_ADDRESSED                : ReceivedAddressedMessage(NodeBuffer, CANBuffer);
            MTI_STREAM_DATA_SEND         : ReceivedStreamMessage(NodeBuffer, CANBuffer);
          end;
        end;
      end
    end;
  end;
  
  if TMR4 > MaxTime_RX then
  begin
    MaxTime_RX := TMR4;
  end;
end;

// *****************************************************************************
//  procedure ReceivedOnFilter2
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 2
//
// *****************************************************************************
procedure ReceivedOnFilter2(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter3
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 3
//
// *****************************************************************************
procedure ReceivedOnFilter3(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter4
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 4
//
// *****************************************************************************
procedure ReceivedOnFilter4(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter5
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 5
//
// *****************************************************************************
procedure ReceivedOnFilter5(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

// *****************************************************************************
//  procedure ReceivedOnFilter6
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 6
//
// *****************************************************************************
procedure ReceivedOnFilter6(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

end.