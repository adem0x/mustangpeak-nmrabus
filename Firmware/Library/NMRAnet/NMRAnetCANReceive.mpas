unit NMRAnetCANReceive;

// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-02-01:   Created
//
// * Description:
//    Implements NMRAnet CAN Receive StateMachine.  The user program does not need
//    to interact with this statemachine unless it needs to hook in for special purposes
//
// ******************************************************************************

uses
  NMRAnetAbbreviatedConfigurationProtocol,
  NMRAnetAbbreviatedConfigurationProtocolDefines,
  NMRAnetDefines,
  NMRAnetUtilities,
  NMRAnetBufferPools,
  NMRAnetBufferPoolsDefines,
  NMRAnetNode,
  NMRAnetDatagrams,
  NMRAnetDatagramDefines,
  NMRAnetAppDefines,
  CANDefines;
  
type
  TPacketHandlerFunc = procedure(CANBuffer: PCANBuffer; var DoDefault: Boolean);
  PPacketHandlerFunc = ^TPacketHandlerFunc;
  
  procedure NMRAnetCANReceive_Initialize;
  procedure NMRAnetCANReceive_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);       // WARNING:  The Hook is called from within the Interrupt Handler.....
  procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);   // WARNING:  The Hook is called from within the Interrupt Handler.....

  // callbacks from the CAN interrupts used in the xxxxx_CAN_Interrupt.mpas units
  procedure ReceivedOnFilter0(Buffer: PCANBuffer);
  procedure ReceivedOnFilter1(Buffer: PCANBuffer);
  procedure ReceivedOnFilter2(Buffer: PCANBuffer);
  procedure ReceivedOnFilter3(Buffer: PCANBuffer);
  procedure ReceivedOnFilter4(Buffer: PCANBuffer);
  procedure ReceivedOnFilter5(Buffer: PCANBuffer);
  procedure ReceivedOnFilter6(Buffer: PCANBuffer);

implementation

var
  CANLayerReceiveHook: PPacketHandlerFunc;
  NMRAnetLayerReceiveHook: PPacketHandlerFunc;
  
// ****************************************************************************
// procedure NMRAnetCANReceive_Initialize
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_Initialize;
begin
  CANLayerReceiveHook := PPacketHandlerFunc( nil);
  NMRAnetLayerReceiveHook := PPacketHandlerFunc( nil);
end;
  
// ****************************************************************************
// procedure NMRAnetCANReceive_SetCANLayerReceiveHook
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_SetCANLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  CANLayerReceiveHook := HookFunc
end;

// ****************************************************************************
// procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook
//
//  Description:
//
// ****************************************************************************
procedure NMRAnetCANReceive_SetNMRANetLayerReceiveHook(HookFunc: PPacketHandlerFunc);
begin
  NMRAnetLayerReceiveHook := HookFunc
end;

// ****************************************************************************
// procedure DispatchAbbreviatedCDIRequest
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Complex Action only because the Sender Alias is needed
//
// ****************************************************************************
procedure DispatchAbbreviatedCDIRequest(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
 // StoreComplexAction(NodeBuffer, CRC_ACDI_REQUEST, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes, 0);
end;

// ****************************************************************************
// procedure DispatchAbbreviatedCDIReply
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Complex Action
//
// ****************************************************************************
procedure DispatchAbbreviatedCDIReply(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
var
  ActiveBuffer: PACDI_ReceiveBuffer;
  DataBytes: TCAN_DataBytes;
begin
  ActiveBuffer := PACDI_ReceiveBuffer( nil);
  if NMRAnetAbbreviatedConfigurationProtocol_ProcessReceiveFromInterruptContext(NodeBuffer, ActiveBuffer, CANBuffer^.ID and MASK_SOURCE_ALIAS, @CANBuffer^.DataBytes) then
  begin
    DataBytes[0] := Lo( ActiveBuffer);                                         // Slip the buffer address in through the DataBytes
    DataBytes[1] := Hi( ActiveBuffer);
  //  StoreComplexAction(NodeBuffer, CRC_ACDI_REPLY, ActiveBuffer^.SourceAlias, @DataBytes, 2);
  end
end;

// ****************************************************************************
// procedure ReceivedDatagramMessage
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple/Complex Action
//
// ****************************************************************************
procedure ReceivedDatagramMessage(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_IsAddressedMessageToNode(NodeBuffer, CANBuffer) then
    NMRAnetDatagrams_ProcessReceiveFromInterruptContext(Nodebuffer, CANBuffer)
end;

// ****************************************************************************
// procedure ReceivedDatagramMessage
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple/Complex Action
//
// ****************************************************************************
procedure ReceivedStartingDatagramMessage(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_IsAddressedMessageToNode(NodeBuffer, CANBuffer) then
    NMRAnetDatagrams_ProcessReceiveFromInterruptContext(NodeBuffer, CANBuffer)
end;

// ****************************************************************************
// procedure ReceivedStreamMessage
//
//  Action Layer:
//                 NMRAnet Layer
//
//  Action Type:
//                 Simple/Complex Action
//
// ****************************************************************************
procedure ReceivedStreamMessage(NodeBuffer: PNMRAnetNode; CANBuffer: PCANBuffer);
begin
  if NMRAnetUtilities_IsAddressedMessageToNode(NodeBuffer, CANBuffer) then
  begin
  end
end;

// *****************************************************************************
//  procedure ReceivedOnFilter0
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 0 which is defined
//                  as any CAN level message (bit 26 = 0)
//
// *****************************************************************************
procedure ReceivedOnFilter0(CANBuffer: PCANBuffer);                             // CAN Layer Message
var
  DoDefault: Boolean;
  Node: PNMRAnetNode;
  NodeID: TNodeID;
begin

 //UART1_Write_Text('CAN'+LF);
 
  DoDefault := True;
  if CANLayerReceiveHook <> nil then
    CANLayerReceiveHook(CANBuffer, DoDefault);
    
  if DoDefault then
  begin
    // First thing is the extract the Source Alias and make sure it is not a duplicate of one of our Node or vNode Aliases
    Node := NMRAnetNode_FindByAlias(NMRAnetUtilities_ExtractSourceAlias(CANBuffer));
    if Node <> nil then                                                         // Check for a Duplicate Alias
    begin
      if (CANBuffer^.ID and FT_CID_MASK = FT_CID0) or (CANBuffer^.ID and FT_CID_MASK = FT_CID1) or (CANBuffer^.ID and FT_CID_MASK = FT_CID2) or (CANBuffer^.ID and FT_CID_MASK = FT_CID3) then
        Node^.MsgFlags := Node^.MsgFlags or MF_DUPLICATE_ALIAS_RID              // A "good" duplicate Alias
      else
        Node^.MsgFlags := Node^.MsgFlags or MF_DUPLICATE_ALIAS;                 // A "bad" duplicate Alias
    end else
    begin
      // The message does not contain a duplicate Source Alias so handle it
      case CANBuffer^.ID and FT_UNADDRESSED_MASK of                             // CAN layer messages are not Addressed in the MTI bits
        FT_AME  : begin
                    if CANBuffer^.DataCount = 6 then                            // Does the data contain the correct number of bytes for a Node ID?
                    begin                                                       // The message is for a specific Node
                      NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 0);
                      Node := NMRAnetNode_FindByNodeID(NodeID);                 // *************** Need to characterize how much time this may take with a large number of nodes
                      if Node <> nil then
                      begin
                        if NMRAnetNode_TestStateFlag(Node, NS_PERMITTED) then                // Only reply if node is in Permitted state
                          Node^.MsgFlags := Node^.MsgFlags or MF_ALIAS_MAP_ENQUIRY;
                      end
                    end else
                    begin
                      if CANBuffer^.DataCount = 0 then                            // Is the message for all Nodes?
                        NMRAnetNode_SetMsgFlagsOnAllNodesOnPermittedNodes(MF_ALIAS_MAP_ENQUIRY);    // Need to characterize how much time this may take with a large number of nodes
                    end
                  end;
        FT_AMD  : begin
                    if CANBuffer^.DataCount = 6 then                            // Does the data contain the correct number of bytes for a Node ID?
                    begin
                      NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 0);
                      Node := NMRAnetNode_FindByNodeID(NodeID);                 // *************** Need to characterize how much time this may take with a large number of nodes
                      if Node <> nil then
                        Node^.MsgFlags := Node^.MsgFlags or MF_DUPLICATE_NODE_ID;
                    end
                  end;
        FT_AMR  : begin
                  end;
      end;
    end
  end
end;

// *****************************************************************************
//  procedure ReceivedOnFilter1
//     Parameters:
//     Returns:
//
//     Description: WARNING: CALLED FROM RX COMPLETE INTERRUPT
//                  Called when a message passes Filter 1 which is defined
//                  as any NMRABus level message (bit 26 = 1)
//
// *****************************************************************************
procedure ReceivedOnFilter1(CANBuffer: PCANBuffer);                             // NMRAnet Layer Message
var
  DoDefault: Boolean;
  Node: PNMRAnetNode;
  NodeID: TNodeID;
  DataBuffer: PDataBuffer;
  BaseBuffer: PBaseBuffer;
  SourceAlias: Word;
begin

  //UART1_Write_Text('NMRAnet'+LF);
 
  TMR4 := 0;
  
  DoDefault := True;
  if NMRAnetLayerReceiveHook <> nil then
    NMRAnetLayerReceiveHook(CANBuffer, DoDefault);                              // Allow the program to have a crack at the message handler
    
  if DoDefault then
  begin
    SourceAlias := NMRAnetUtilities_ExtractSourceAlias(CANBuffer);
    Node := NMRAnetNode_FindByAlias(SourceAlias);
    if Node <> nil then
    begin
      Node^.MsgFlags := Node^.MsgFlags or MF_DUPLICATE_ALIAS                    // A "bad" duplicate Alias
    end else 
    begin
      case CANBuffer^.ID and MTI_TYPE_MASK of                                   // First subdivide between Unaddressed and Addressed Messages
        MTI_UNADDRESSED        : begin                                          // Unaddressed Messages
                                   case CANBuffer^.ID and FT_UNADDRESSED_MASK of
                                     FT_VERIFY_NODE_ID_NUMBER         : begin
                                                                           if (CANBuffer^.DataCount = 0) then                                      // THIS IS NOT CLEAR IN THE SPEC
                                                                             NMRAnetNode_SetMsgFlagsOnAllNodesOnPermittedNodes(MF_VERIFY_NODE_ID)  // Need to characterize how much time this may take with a large number of nodes
                                                                           else
                                                                           if (CANBuffer^.DataCount = 6) then                                      // THIS IS NOT CLEAR IN THE SPEC
                                                                           begin
                                                                             NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 0);
                                                                             Node := NMRAnetNode_FindByNodeID(NodeID);
                                                                             if Node <> nil then
                                                                               NMRAnetNode_SetMsgFlagsOnAllNodesOnPermittedNodes(MF_VERIFY_NODE_ID)  // Need to characterize how much time this may take with a large number of nodes
                                                                           end
                                                                        end;
                                     FT_CONSUMER_IDENTIFY             : begin 
                                                                          if NMRAnetUtilities_SupportsEventAsConsumer(@CANBuffer^.DataBytes) then
                                                                          begin
                                                                            if NMRAnetBufferPools_AllocateDataBuffer(DataBuffer) then
                                                                            begin
                                                                              NMRAnetUtilities_MsgBufferLink(Node, PBaseBuffer( Pointer( DataBuffer)));
                                                                              DataBuffer^.mCode := BMC_CONSUMER_IDENTIFY;
                                                                              DataBuffer^.Alias := SourceAlias;
                                                                              DataBuffer^.Count := CANBuffer^.DataCount;
                                                                              DataBuffer^.DataBytes := CANBuffer^.DataBytes;
                                                                            end
                                                                          end
                                                                        end;
                                     FT_CONSUMER_IDENTIFY_RANGE       : begin 
                                                                          // TODO
                                                                        end;
                                     FT_PRODUCER_IDENDIFY             : begin  
                                                                          if NMRAnetUtilities_SupportsEventAsProducer(@CANBuffer^.DataBytes) then
                                                                          begin
                                                                            if NMRAnetBufferPools_AllocateDataBuffer(DataBuffer) then
                                                                            begin
                                                                              NMRAnetUtilities_MsgBufferLink(Node, PBaseBuffer( Pointer( DataBuffer)));
                                                                              DataBuffer^.mCode := BMC_PRODUCER_IDENTIFY;
                                                                              DataBuffer^.Alias := SourceAlias;
                                                                              DataBuffer^.Count := CANBuffer^.DataCount;
                                                                              DataBuffer^.DataBytes := CANBuffer^.DataBytes;
                                                                            end
                                                                          end
                                                                        end;
                                     FT_PRODUCER_IDENTIFY_RANGE       : begin
                                                                          // TODO
                                                                        end;
                                     FT_EVENT_LEARN                   : begin 
                                                                        { if NMRAnetBufferPools_AllocateDataBuffer(DataBuffer) then
                                                                          begin
                                                                            NMRAnetUtilities_MsgBufferLink(Node, PBaseBuffer( Pointer( DataBuffer)));
                                                                            DataBuffer^.mCode := BMC_EVENT_LEARN;
                                                                            DataBuffer^.Alias := SourceAlias;
                                                                            DataBuffer^.Count := CANBuffer^.DataCount;
                                                                            DataBuffer^.DataBytes := CANBuffer^.DataBytes;
                                                                          end     }
                                                                        end;
                                     FT_EVENTS_IDENTIFY               : begin 
                                                                          NMRAnetNode_SetMsgFlagsOnAllNodesOnPermittedNodes(MF_IDENTIFY_ALL_EVENTS);
                                                                        end;
                                   end
                                 end;
        MTI_RESERVED           : begin                                          // Unused as of June 2012
                                 end
      else begin                                                                // Addressed Messages
          Node := NMRAnetNode_FindByAlias(NMRAnetUtilities_ExtractDestinationAlias(CANBuffer));   // Extract the Node that the message is addressed to
          if Node <> nil then
          begin
            if NMRAnetNode_TestStateFlag(Node, NS_PERMITTED) then
            begin
              case CANBuffer^.ID and MTI_TYPE_MASK of                           // Now subdivide the Addressed down to Datagrams, Streams, Other Addressed
                MTI_ADDRESSED            : begin
                                             case CANBuffer^.Databytes[0] of
                                               MTI_EXTENSION_VERIFY_NODE_ID_NUMBER_DEST       : begin 
                                                                                                  if CANBuffer^.DataCount = 1 then                                 // THIS IS NOT CLEAR IN THE SPEC, , with the $0A in Index 0
                                                                                                     NMRAnetNode_SetMsgFlag(Node, MF_VERIFY_NODE_ID)
                                                                                                  else
                                                                                                  if CANBuffer^.DataCount = 7 then                                 // THIS IS NOT CLEAR IN THE SPEC
                                                                                                  begin
                                                                                                    NMRAnetUtilities_PacketBytesToNodeID(@CANBuffer^.DataBytes, NodeID, 1); // Extract the 48 Bit ID, with the $0A in Index 0
                                                                                                    Node := NMRAnetNode_FindByNodeID(NodeID);
                                                                                                    if Node <> nil then                                                 // If addressed to us then respond
                                                                                                      NMRAnetNode_SetMsgFlag(Node, MF_VERIFY_NODE_ID)
                                                                                                  end
                                                                                                end;
                                               MTI_EXTENSION_PROTOCOL_SUPPORT_QUERY           : begin 
                                                                                                  if NMRAnetBufferPools_AllocateBaseBuffer(BaseBuffer) then
                                                                                                  begin
                                                                                                    NMRAnetUtilities_MsgBufferLink(Node, BaseBuffer);
                                                                                                    BaseBuffer^.mCode := BMC_PROTOCOL_SUPPORT_QUERY;
                                                                                                    BaseBuffer^.Alias := SourceAlias
                                                                                                  end
                                                                                                end;  // DispatchProtocolSupportInquiry(NodeBuffer, CANBuffer);
                                               MTI_EXTENSION_IDENTIFY_EVENTS                  : begin
                                                                                                  NMRAnetNode_SetMsgFlag(Node, MF_IDENTIFY_ALL_EVENTS);
                                                                                                end;
                                               MTI_EXTENSION_SIMPLENODE_IDENTIFY_INFO_REQUEST : begin 
                                                                                                    // NEED TO PASS THE TARGET NODE TO NEXT LAYER, HOW????????
                                                                                                end;  // DispatchAbbreviatedCDIRequest(NodeBuffer, CANBuffer);
                                               MTI_EXTENSION_DATAGRAM_RECIEVED_OK             : begin end;  // DispatchDatagramReceivedOk(NodeBuffer, CANBuffer);
                                               MTI_EXTENSION_DATAGRAM_REJECTED                : begin end  // DispatchDatagramRejected(NodeBuffer, CANBuffer)
                                              else
                                                if NMRAnetBufferPools_AllocateBaseBuffer(BaseBuffer) then
                                                begin
                                                  NMRAnetUtilities_MsgBufferLink(Node, BaseBuffer);
                                                  BaseBuffer^.mCode := BMC_OPTIONAL_INTERACTION_REJECTED;
                                                  BaseBuffer^.Alias := SourceAlias
                                                end;
                                              end;
                                           end;
                MTI_DATAGRAM_ONLY_FRAME,
                MTI_DATAGRAM_FRAME_START : begin
                                           end;
                MTI_DATAGRAM_FRAME,
                MTI_DATAGRAM_FRAME_END   : begin
                                           end;
                MTI_STREAM_DATA_SEND     : begin
                                           end;
               end
            end
          end
        end;  // case, else
      end
    end;
  end;

  if TMR4 > MaxTime_RX then
  begin
    MaxTime_RX := TMR4;
  end;
end;

procedure ReceivedOnFilter2(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

procedure ReceivedOnFilter3(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

procedure ReceivedOnFilter4(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

procedure ReceivedOnFilter5(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

procedure ReceivedOnFilter6(Buffer: PCANBuffer);
begin
  // Not used for NMRABus
end;

end.