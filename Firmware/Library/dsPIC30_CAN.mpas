unit dsPIC30_CAN;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-04-01:   1.0.0.0 Created
//
// * Description:
//                Implements an easy to use interface into the dsPIC33 ECAN Module Registers
//                It is fast, no.  Is it efficient, no.  Is it easy to experiment with to try to
//                understand how this module works, YES
//
// ******************************************************************************

uses
  CAN_Storage;
  
{$I Options.inc}

const
  ICODE_None    = 0;
  ICODE_ERROR   = 1;
  ICODE_TX2     = 2;
  ICODE_TX1     = 3;
  ICODE_TX0     = 4;
  ICODE_RX1     = 5;
  ICODE_RX0     = 6;
  ICODE_WAKE    = 7;

// *****************************************************************************
// CAN FIFO Buffer Access, these are exported through the "external" modifier
// *****************************************************************************
function AddToList(List: PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
function AddToListByParameter(List: PCANRawBufferList; ID: DWORD; ByteCount, Byte0, Byte1, Byte2, Byte3, Byte4, Byte5, Byte6, Byte7: Byte; IsExtended: Boolean): Boolean;
function ExtractFromList(List :PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
// *****************************************************************************
 
procedure dsPIC30_CAN_TXBufferInterrupt(Enable: Boolean);


implementation

procedure dsPIC30_CAN_TXBufferInterrupt(Enable: Boolean);
begin
  if Enable then
    TXB0IE_bit := 1
  else
    TXB0IE_bit := 0
end;

// ****************************************************************************
// procedure dsPIC30_Style_Buffer
//
// parameters:
//
//  Description:
//
// ****************************************************************************
procedure dsPIC30_Style_Buffer(Direction: Word; CANPtr: ^Word; var Buffer: TCANBuffer);
var
  SID, EID: DWORD;
  IsExtended: Boolean;
begin
  if Direction = CAN_DIRECTION_WRITE then
  begin
    SID := (Buffer.ID and $1FFC0000) shr 18;
    EID := Buffer.ID and $0003FFFF;

    CANPtr^ := ((SID shl 2) and $00FC) or ((SID shl 5) and $F800);
    if Buffer.IsExtended then
    begin
      CANPtr^ := CANPtr^ or $0001;
      Inc(CANPtr);                                                              // Move to C1TXnEID
      CANPtr^ := ((EID shr 6) and $00FF) or ((EID shr 2) and $F000);
      Inc(CANPtr);                                                              // Move to the RXnDLC Register
      CANPtr^ := ((EID shl 10) and $FC00);
    end else
    begin
      Inc(CANPtr);                                                              // Move to
    end;
    CANPtr^ := (CANPtr^ and $FF87) or (WORD( Buffer.DataCount) shl 3);
    Inc(CANPtr);                                                                // Move to
    CANPtr^ := Buffer.DataBytes[0] or (Buffer.DataBytes[1] shl 8);
    Inc(CANPtr);                                                                // Move to
    CANPtr^ := Buffer.DataBytes[2] or (Buffer.DataBytes[3] shl 8);
    Inc(CANPtr);                                                                // Move to
    CANPtr^ := Buffer.DataBytes[4] or (Buffer.DataBytes[5] shl 8);
    Inc(CANPtr);                                                                // Move to
    CANPtr^ := Buffer.DataBytes[6] or (Buffer.DataBytes[7] shl 8);
    Inc(CANPtr);                                                                // Move to
    CANPtr^ := (CANPtr^ and $FFFC);                                             // Set Priority to 0
  end else
  begin
    SID := ((DWORD( CANPtr^ shr 2)) and $000007FF);                             // Get the Standard ID
    IsExtended := CANPtr^ and $0001 <> 0;
    Inc(CANPtr);                                                                // Move to the RXnEID Register
    if IsExtended then
    begin
      EID := ((DWORD( CANPtr^) shl 6) and $0003FFC0);                           // Pull out the info from the RXnEID
      Inc(CANPtr);                                                              // Move to the RXnDLC Register
      EID := EID or (DWORD( CANPtr^) shr 10);                                   // Pull out the rest of the Extended ID
    end else
      Inc(CANPtr);                                                              // Move to the RXnDLC Register
    Buffer.ID := (SID shl 18) or EID;                                              // Build the EID
    Buffer.DataCount := CANPtr^ and $000F;
    Inc(CANPtr);                                                                // Move to C1RXnB1
    Buffer.DataBytes[0] := CANPtr^;
    Buffer.DataBytes[1] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                // Move to C1RXnB2
    Buffer.DataBytes[2] := CANPtr^;
    Buffer.DataBytes[3] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                // Move to C1RXnB3
    Buffer.DataBytes[4] := CANPtr^;
    Buffer.DataBytes[5] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                // Move to C1RXnB4
    Buffer.DataBytes[6] := CANPtr^;
    Buffer.DataBytes[7] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                // Move to C1RXnCON
  end
end;

// *****************************************************************************
//  function AddToList
//     Parameters:
//
//     Returns: True if the parameters were loaded into the FIFO buffers, else the buffers were full
//
//     Description:   Loads the passed paramters into the next empty Buffer FIFO list
//                    ~260 Cycles to complete for the dsPIC33
//
// *****************************************************************************
function AddToList(List: PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
var
  Head: PCANRawBuffer;
begin
  Result := False;
  Head := CANStorage_Head(List);
  if Head <> PCANRawBuffer( nil) then
  begin
    dsPIC30_Style_Buffer(CAN_DIRECTION_WRITE, @(Head^.Word0), Buffer);
    CANStorage_IncHead(List);
    Result := True
  end;
end;

// *****************************************************************************
//  procedure AddToListByParameter;
//
//  Parameters: List           : Pointer to the FIFO buffer List to operation on
//
//  Result:
//
//  Description: Stores the passed Buffer Information into the CAN Storage Buffer in the passed list
// *****************************************************************************
function AddToListByParameter(List: PCANRawBufferList; ID: DWORD; ByteCount, Byte0, Byte1, Byte2, Byte3, Byte4, Byte5, Byte6, Byte7: Byte; IsExtended: Boolean): Boolean;
var
  Buffer: TCANBuffer;
begin
  Buffer.ID := ID;
  Buffer.DataCount := ByteCount;
  Buffer.DataBytes[0] := Byte0;
  Buffer.DataBytes[1] := Byte1;
  Buffer.DataBytes[2] := Byte2;
  Buffer.DataBytes[3] := Byte3;
  Buffer.DataBytes[4] := Byte4;
  Buffer.DataBytes[5] := Byte5;
  Buffer.DataBytes[6] := Byte6;
  Buffer.DataBytes[7] := Byte7;
  Buffer.IsExtended := IsExtended;
  Result := AddToList(List, Buffer)
end;

// *****************************************************************************
//  function ExtractFromList
//     Parameters:
//
//     Returns: True if the return parameters are valid (i.e. there was something to read in the List
//
//     Description:   Loads the passed paramters with the next Buffer Data in the FIFO list
//                    ~260 Cycles to complete for the dsPIC33 and dsPIC30
//
// *****************************************************************************
function ExtractFromList(List :PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
var
  Tail: PCANRawBuffer;
begin
  Result := False;
  Tail := CANStorage_Tail(List);
  if Tail <> nil then
  begin
    dsPIC30_Style_Buffer(CAN_DIRECTION_READ, @Tail^.Word0, Buffer);         // dsPIC33 and the dsPIC30 are the same format for RX Buffers
    CANStorage_IncTail(List);
    Result := True;
  end
end;

end.