unit dsPIC30_CAN;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-04-01:   1.0.0.0 Created
//
// * Description:
//                Implements an easy to use interface into the dsPIC33 ECAN Module Registers
//                It is fast, no.  Is it efficient, no.  Is it easy to experiment with to try to
//                understand how this module works, YES
//
// ******************************************************************************

uses
  CAN_Storage;
  
{$I Options.inc}

// *****************************************************************************
// CAN FIFO Buffer Access, these are exported through the "external" modifier
// *****************************************************************************
function AddToList(List: PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
function AddToListByParameter(List: PCANRawBufferList; ID: DWORD; ByteCount, Byte0, Byte1, Byte2, Byte3, Byte4, Byte5, Byte6, Byte7: Byte; IsExtended: Boolean): Boolean;
function ExtractFromList(List :PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
// *****************************************************************************
  


implementation

// ****************************************************************************
// procedure CANReadRXBuffer
//
// parameters:
//     Buffer:        TX Buffer to use.  See CAN_RX_n constants
//     Header:        The SID and EID for the CAN header
//     DataCount:     Number of Data Bytes
//     DataBytes:     Bytes to send
//     IsExtended:    If the Header is a Standard or Extended
//
//  Description:  16us
//
// ****************************************************************************
procedure CANReadRXBuffer(Buffer: Byte; var Header: DWord; var DataCount: Byte; var DataBytes: TCAN_DataBytes; var IsExtended: Boolean);
var
  CANPtr: ^Word;
  SID, EID: DWORD;
begin
  case Buffer of
    0: CANPtr := @C1RX0SID;
    1: CANPtr := @C1RX1SID;
  end;
  SID := ((DWORD( CANPtr^ shr 2)) and $000007FF);                               // Get the Standard ID
  IsExtended := CANPtr^ and $0001 <> 0;
  Inc(CANPtr);                                                                  // Move to the RXnEID Register
  if IsExtended then
  begin
    EID := ((DWORD( CANPtr^) shl 6) and $0003FFC0);                             // Pull out the info from the RXnEID
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
    EID := EID or (DWORD( CANPtr^) shr 10);                                     // Pull out the rest of the Extended ID
  end else
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
  Header := (SID shl 18) or EID;                                                // Build the EID
  DataCount := CANPtr^ and $000F;
  Inc(CANPtr);                                                                  // Move to C1RXnB1
  DataBytes[0] := CANPtr^;
  DataBytes[1] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnB2
  DataBytes[2] := CANPtr^;
  DataBytes[3] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnB3
  DataBytes[4] := CANPtr^;
  DataBytes[5] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnB4
  DataBytes[6] := CANPtr^;
  DataBytes[7] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnCON
  CANPtr^ := CANPtr^ and $FF7F;                                                 // Clear the RXFUL flag
end;

// ****************************************************************************
// procedure CANWriteTXBuffer
//
// parameters:
//     Buffer:        TX Buffer to use.  See CAN_TX_n constants
//     Header:        The SID and EID for the CAN header
//     DataCount:     Number of Data Bytes
//     DataBytes:     Bytes to send
//     IsExtended:    If the Header is a Standard or Extended
//     Priority:      Transmit Priority.  See CAN_TX_PRIORITY_n constants
//
//  Description:  16us
//
// ****************************************************************************
procedure CANWriteTXBuffer(Buffer: Byte; Header: DWord; DataCount: Byte; var DataBytes: TCAN_DataBytes; IsExtended: Boolean; Priority: Byte);
var
  CANPtr: ^Word;
  SID, EID: DWORD;
begin
  SID := (Header and $1FFC0000) shr 18;
  EID := Header and $0003FFFF;

  case Buffer of
    0: CANPtr := @C1TX0SID;
    1: CANPtr := @C1TX1SID;
    2: CANPtr := @C1TX2SID;
  end;
  CANPtr^ := ((SID shl 2) and $00FC) or ((SID shl 5) and $F800);
  if IsExtended then
  begin
    CANPtr^ := CANPtr^ or $0001;
    Inc(CANPtr);                                                                // Move to C1TXnEID
    CANPtr^ := ((EID shr 6) and $00FF) or ((EID shr 2) and $F000);
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
    CANPtr^ := ((EID shl 10) and $FC00);
  end else
  begin
    Inc(CANPtr);                                                                // Move to C1TXnEID
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
  end;
  CANPtr^ := (CANPtr^ and $FF87) or (WORD( DataCount) shl 3);
  Inc(CANPtr);                                                                  // Move to C1TXnB1
  CANPtr^ := DataBytes[0] or (DataBytes[1] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnB2
  CANPtr^ := DataBytes[2] or (DataBytes[3] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnB3
  CANPtr^ := DataBytes[4] or (DataBytes[5] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnB4
  CANPtr^ := DataBytes[6] or (DataBytes[7] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnCON
  CANPtr^ := (CANPtr^ and $FFFC) or Priority or $0008;                          // Set Priority and Set TXREQ to start transmit
end;

// *****************************************************************************
//  function AddToList
//     Parameters:
//
//     Returns: True if the parameters were loaded into the FIFO buffers, else the buffers were full
//
//     Description:   Loads the passed paramters into the next empty Buffer FIFO list
//                    ~260 Cycles to complete for the dsPIC33
//
// *****************************************************************************
function AddToList(List: PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
var
  Head: PCANRawBuffer;
begin
  Result := False;
  Head := CANStorage_Head(List);
  if Head <> PCANRawBuffer( nil) then
  begin
  //  dsPIC33_DMA_Style_Buffer(CAN_DIRECTION_WRITE, @(Head^.Word0), Buffer);
    CANStorage_IncHead(List);
    Result := True
  end;
end;

// *****************************************************************************
//  procedure AddToListByParameter;
//
//  Parameters: List           : Pointer to the FIFO buffer List to operation on
//
//  Result:
//
//  Description: Stores the passed Buffer Information into the CAN Storage Buffer in the passed list
// *****************************************************************************
function AddToListByParameter(List: PCANRawBufferList; ID: DWORD; ByteCount, Byte0, Byte1, Byte2, Byte3, Byte4, Byte5, Byte6, Byte7: Byte; IsExtended: Boolean): Boolean;
var
  Buffer: TCANBuffer;
begin
  Buffer.ID := ID;
  Buffer.DataCount := ByteCount;
  Buffer.DataBytes[0] := Byte0;
  Buffer.DataBytes[1] := Byte1;
  Buffer.DataBytes[2] := Byte2;
  Buffer.DataBytes[3] := Byte3;
  Buffer.DataBytes[4] := Byte4;
  Buffer.DataBytes[5] := Byte5;
  Buffer.DataBytes[6] := Byte6;
  Buffer.DataBytes[7] := Byte7;
  Buffer.IsExtended := IsExtended;
  Result := AddToList(List, Buffer)
end;

// *****************************************************************************
//  function ExtractFromList
//     Parameters:
//
//     Returns: True if the return parameters are valid (i.e. there was something to read in the List
//
//     Description:   Loads the passed paramters with the next Buffer Data in the FIFO list
//                    ~260 Cycles to complete for the dsPIC33 and dsPIC30
//
// *****************************************************************************
function ExtractFromList(List :PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
var
  Tail: PCANRawBuffer;
begin
  Result := False;
  Tail := CANStorage_Tail(List);
  if Tail <> nil then
  begin
  //  dsPIC33_DMA_Style_Buffer(CAN_DIRECTION_READ, @Tail^.Word0, Buffer);         // dsPIC33 and the dsPIC30 are the same format for RX Buffers
    CANStorage_IncTail(List);
    Result := True;
  end
end;

end.