unit dsPIC30_CAN;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-04-01:   1.0.0.0 Created
//
// * Description:
//                Implements an easy to use interface into the dsPIC33 ECAN Module Registers
//                It is fast, no.  Is it efficient, no.  Is it easy to experiment with to try to
//                understand how this module works, YES
//
// ******************************************************************************

uses
  CANStorage;
  
{$I Options.inc}

implementation

// *****************************************************************************
//  procedure dsPIC30_Style_TX_Buffer
//     Parameters:
//
//     Returns: None
//
//     Description:   Fills the passed PCANRawBuffer with the more user friendly data
//                    the buffers are filled with copies of what the perphial registers need
//
// *****************************************************************************
procedure dsPIC30_Style_TX_Buffer(CANPtr: ^Word; var Buffer: TCANBuffer);
begin
  CANPtr^ := ((Buffer.ID shl 5) and $0000F800);                                 // Setup the Standard ID
  CANPtr^ := CANPtr^ or ((Buffer.ID shl 2) and $000000FC);
  if Buffer.IsExtended then
    CANPtr^ := CANPtr^ or $00000001;                                            // Setup if it is an extended ID
  Inc(CANPtr);                                                                  // Move to the Extended ID
  CANPtr^ := DWORD( (Buffer.ID shr 13) and $0000F000);
  CANPtr^ := CANPtr^ or ((Buffer.ID shr 17) and $000000FF);
  Inc(CANPtr);                                                                  // Move to the DLC and the rest of the EID
  CANPtr^ := ((Buffer.ID shr 1) and $0000FC00);                                 // Put EID 0..5 into bits 10..15
  CANPtr^ := CANPtr^ or Buffer.DataCount;                                       // Put Data Length
  Inc(CANPtr);                                                                  // Move to Byte 1 and Byte 2
  CANPtr^ := Buffer.DataBytes[0] or Buffer.DataBytes[1] shl 8;
  Inc(CANPtr);                                                                  // Move to Byte 3 and Byte 4
  CANPtr^ := Buffer.DataBytes[2] or Buffer.DataBytes[3] shl 8;
  Inc(CANPtr);                                                                  // Move to Byte 5 and Byte 6
  CANPtr^ := Buffer.DataBytes[4] or Buffer.DataBytes[5] shl 8;
  Inc(CANPtr);                                                                  // Move to Byte 7 and Byte 8
  CANPtr^ := Buffer.DataBytes[6] or Buffer.DataBytes[7] shl 8;
  Inc(CANPtr);
end;




// ****************************************************************************
// procedure CANReadRXBuffer
//
// parameters:
//     Buffer:        TX Buffer to use.  See CAN_RX_n constants
//     Header:        The SID and EID for the CAN header
//     DataCount:     Number of Data Bytes
//     DataBytes:     Bytes to send
//     IsExtended:    If the Header is a Standard or Extended
//
//  Description:  16us
//
// ****************************************************************************
procedure CANReadRXBuffer(Buffer: Byte; var Header: DWord; var DataCount: Byte; var DataBytes: TCANData; var IsExtended: Boolean);
var
  CANPtr: ^Word;
  SID, EID: DWORD;
begin
 {$IFDEF dsPIC33}

 {$ELSE}
  case Buffer of
    0: CANPtr := @C1RX0SID;
    1: CANPtr := @C1RX1SID;
  end;
  SID := ((DWORD( CANPtr^ shr 2)) and $000007FF);                               // Get the Standard ID
  IsExtended := CANPtr^ and $0001 <> 0;
  Inc(CANPtr);                                                                  // Move to the RXnEID Register
  if IsExtended then
  begin
    EID := ((DWORD( CANPtr^) shl 6) and $0003FFC0);                             // Pull out the info from the RXnEID
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
    EID := EID or (DWORD( CANPtr^) shr 10);                                     // Pull out the rest of the Extended ID
  end else
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
  Header := (SID shl 18) or EID;                                                // Build the EID
  DataCount := CANPtr^ and $000F;
  Inc(CANPtr);                                                                  // Move to C1RXnB1
  DataBytes[0] := CANPtr^;
  DataBytes[1] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnB2
  DataBytes[2] := CANPtr^;
  DataBytes[3] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnB3
  DataBytes[4] := CANPtr^;
  DataBytes[5] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnB4
  DataBytes[6] := CANPtr^;
  DataBytes[7] := CANPtr^ shr 8;
  Inc(CANPtr);                                                                  // Move to C1RXnCON
  CANPtr^ := CANPtr^ and $FF7F;                                                 // Clear the RXFUL flag
  {$ENDIF}
end;

// ****************************************************************************
// procedure CANWriteTXBuffer
//
// parameters:
//     Buffer:        TX Buffer to use.  See CAN_TX_n constants
//     Header:        The SID and EID for the CAN header
//     DataCount:     Number of Data Bytes
//     DataBytes:     Bytes to send
//     IsExtended:    If the Header is a Standard or Extended
//     Priority:      Transmit Priority.  See CAN_TX_PRIORITY_n constants
//
//  Description:  16us
//
// ****************************************************************************
procedure CANWriteTXBuffer(Buffer: Byte; Header: DWord; DataCount: Byte; var DataBytes: TCANData; IsExtended: Boolean; Priority: Byte);
var
  CANPtr: ^Word;
  SID, EID: DWORD;
begin
 {$IFDEF dsPIC33}

 {$ELSE}
  SID := (Header and $1FFC0000) shr 18;
  EID := Header and $0003FFFF;

  case Buffer of
    0: CANPtr := @C1TX0SID;
    1: CANPtr := @C1TX1SID;
    2: CANPtr := @C1TX2SID;
  end;
  CANPtr^ := ((SID shl 2) and $00FC) or ((SID shl 5) and $F800);
  if IsExtended then
  begin
    CANPtr^ := CANPtr^ or $0001;
    Inc(CANPtr);                                                                // Move to C1TXnEID
    CANPtr^ := ((EID shr 6) and $00FF) or ((EID shr 2) and $F000);
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
    CANPtr^ := ((EID shl 10) and $FC00);
  end else
  begin
    Inc(CANPtr);                                                                // Move to C1TXnEID
    Inc(CANPtr);                                                                // Move to the RXnDLC Register
  end;
  CANPtr^ := (CANPtr^ and $FF87) or (WORD( DataCount) shl 3);
  Inc(CANPtr);                                                                  // Move to C1TXnB1
  CANPtr^ := DataBytes[0] or (DataBytes[1] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnB2
  CANPtr^ := DataBytes[2] or (DataBytes[3] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnB3
  CANPtr^ := DataBytes[4] or (DataBytes[5] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnB4
  CANPtr^ := DataBytes[6] or (DataBytes[7] shl 8);
  Inc(CANPtr);                                                                  // Move to C1TXnCON
  CANPtr^ := (CANPtr^ and $FFFC) or Priority or $0008;                          // Set Priority and Set TXREQ to start transmit
 {$ENDIF}
end;

end.