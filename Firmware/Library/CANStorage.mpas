unit CANStorage;

{$I Options.inc}

const
  CAN_DIRECTION_READ = 1;
  CAN_DIRECTION_WRITE = 0;

type
  TCAN_DataBytes = array[8] of Byte;
  PCAN_DataBytes = ^TCAN_DataBytes;
  
  // ***************************************************************************
  // CAN Message Buffers in raw form that can be loaded into the CAN controller
  // registers
  //   NOTE: For the dsPIC33 RX and TX are identical, for the dsPIC30 the bit
  //         patterns are different between RX and TX
  // ***************************************************************************
  TCANRawBuffer = record
    SID    : Word;   // Standard Identifier
    EID    : Word;   // Extended Identifier
    EID_DLC: Word;   // More Extended Identifier bits and Data Length Code
    Byte0_1: Word;   // Data Byte 0 and Data Byte 1
    Byte2_3: Word;   // Data Byte 0 and Data Byte 1
    Byte4_5: Word;   // Data Byte 0 and Data Byte 1
    Byte6_7: Word;   // Data Byte 0 and Data Byte 1
    Tag    : Word;   // Dependant on the the microcontroller
  end;
  PCANRawBuffer = ^TCANRawBuffer;
  
 // ***************************************************************************
  // CAN Message Buffers in user friendly form that can be easily maniuplated then
  // loaded into the Raw CAN FIFOs
  // ***************************************************************************
  TCANBuffer = record
    ID: DWord;
    DataCount: Byte;
    DataBytes: TCAN_DataBytes;
    IsExtended: Boolean;
  end;
  PCANBuffer = ^TCANBuffer;
  
const
  RAWBUFFERSIZE = SizeOf(TCANRawBuffer);
  
type
  TCANRawBufferArray = array[0..0] of TCANRawBuffer;
  PCANRawBufferArray = ^TCANRawBufferArray;
  
  TCANRawBufferList = record
    Buffers: PCANRawBufferArray;   // Pointer to the TCANRawBuffer Array where the data is stored (Normal RAM or DMA RAM depending on device)
    BufferEndPtr: PCANRawBuffer;   // Points to the last record in the List - So (BufferEndPtr - Buffers)/RAWBUFFERSIZE is the total number of items in the Buffer
    HeadPtr: PCANRawBuffer;        // Points to the next empty TCANRawBuffer item in the list that is empty [for RX]
    TailPtr: PCANRawBuffer;        // Points to the first full TCANRawBuffer that needs to be serviced [for RX]
  end;
  PCANRawBufferList = ^TCANRawBufferList;
  

function CANStorage_LoadTransmitterBuffer(List: PCANRawBufferList; var Buffer: TCANBuffer; Priority: Word): Boolean;
function CANStorage_ReadReceiverBuffer(List: PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
procedure CANStorage_InitializeList(ListPtr: PCANRawBufferList; BufferArrayPtr: PCANRawBufferArray; LastBufferPtr: PCANRawBuffer);
function CANStorage_InitTransmit(ListPtr: PCANRawBufferList): Boolean;
  
implementation

// *****************************************************************************
//  procedure CANStorage_InitTransmit;
//
//  Parameters:
//
//  Result:
//
//  Description: Transfers the message from the queue to the CAN bus
// *****************************************************************************
function CANStorage_InitTransmit(ListPtr: PCANRawBufferList): Boolean;
begin
  Result := False;
  {$IFDEF dsPIC33} 
    // Setup Priority, TXREQ, and align DMA/CAN Module to the Buffer.  IF there is not a transmit in progress that will call the interrupt and auto load the next buffer
  {$ELSE}
  {$IFDEF dsPIC30} 
   // Setup Priority, TXREQ, and align DMA/CAN Module to the Buffer.  IF there is not a transmit in progress that will call the interrupt and auto load the next buffer
  {$ELSE}
    Error; (*ERROR:  You must define either dsPIC33 or dsPIC30 in your options file*)
  {$ENDIF} {$ENDIF}
end;

// *****************************************************************************
//  procedure CANStorage_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the RawBufferArray
//              LasterBuffer   : Pointer to the last item in the RawBufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure CANStorage_InitializeList(ListPtr: PCANRawBufferList; BufferArrayPtr: PCANRawBufferArray; LastBufferPtr: PCANRawBuffer);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.BufferEndPtr := LastBufferPtr;
  ListPtr^.HeadPtr := @BufferArrayPtr^[0];
  ListPtr^.TailPtr := @BufferArrayPtr^[0];
end;

// *****************************************************************************
//  function NextHead(List: PCANRawBufferList): PCANRawBuffer;
//     Parameters:
//
//     Returns: Pointer to the Next Buffer if available, nil if no buffers are available
//
//     Description:   Returns the Next Item in the List available for filling
//                    NOTE: This will not return item 0 for an empty list it will
//                          always return item 1 as the first item used in the list....
//
// *****************************************************************************
function NextHead(List: PCANRawBufferList): PCANRawBuffer;
begin
  Result := List^.HeadPtr;                                                      // Take the current head
  Inc(Result); //:= Result + Sizeof(TCANRawBuffer);                                     // Increment it to the next item
  if Result > List^.BufferEndPtr then                                           // Wrap it if necessary
    Result := @List^.Buffers^[0];
  if Result = List^.TailPtr then                                                // If the new Head = Tail then the list is full
    Result := PCANRawBuffer( nil);
end;

// *****************************************************************************
//  function CurrentTail(List: PCANRawBufferList): PCANRawBuffer;
//     Parameters:
//
//     Returns: Pointer to the Current Tail if there is Data available, else nil
//
//     Description:   Returns the Buffer ready to be read from the Buffer
//
// *****************************************************************************
function CurrentTail(List: PCANRawBufferList): PCANRawBuffer;
begin
 // if List^.HeadPtr <> List^.TailPtr then
    Result := List^.TailPtr                                                     // Take the current Tail
 // else
 //   Result := PCANRawBuffer( nil);                                              // List is empty
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_Style_Buffer
//     Parameters:
//
//     Returns: None
//
//     Description:   Fills the passed PCANRawBuffer with the more user friendly data
//                    the buffers are filled with copies of what the perphial registers need
//
// *****************************************************************************
procedure dsPIC33_DMA_Style_Buffer(Direction: Byte; CANPtr: ^Word; var Buffer: TCANBuffer; Priority: Word);
begin
  if Direction = CAN_DIRECTION_WRITE then
  begin
    // Direction = 0 means Parameters to Buffer (Load TX Buffer)
    CANPtr^ := DWORD((Buffer.ID shl 2) and $00001FFC);                          // Setup the Standard ID
    if Buffer.IsExtended then
      CANPtr^ := CANPtr^ or $0001;                                              // Setup if it is an extended ID
    Inc(CANPtr);                                                                // Move to the Extended ID
    CANPtr^ := DWORD(Buffer.ID shr 17);                                                // put EID 6..17 into bits 0..11
    Inc(CANPtr);                                                                // Move to the DLC and the rest of the EID
    CANPtr^ := DWORD((Buffer.ID shr 1) and $0000FC00);                                 // Put EID 0..5 into bits 10..15
    CANPtr^ := CANPtr^ or (Word( Buffer.DataCount) and $000F);                           // Put Data Length
    Inc(CANPtr);                                                                // Move to Byte 1 and Byte 2
    CANPtr^ := Buffer.DataBytes[0] or (Buffer.DataBytes[1] shl 8);
    Inc(CANPtr);                                                                // Move to Byte 3 and Byte 4
    CANPtr^ := Buffer.DataBytes[2] or (Buffer.DataBytes[3] shl 8);
    Inc(CANPtr);                                                                // Move to Byte 5 and Byte 6
    CANPtr^ := Buffer.DataBytes[4] or (Buffer.DataBytes[5] shl 8);
    Inc(CANPtr);                                                                // Move to Byte 7 and Byte 8
    CANPtr^ := Buffer.DataBytes[6] or (Buffer.DataBytes[7] shl 8);
    Inc(CANPtr);
    CANPtr^ := Priority;                                                        // Last Byte not used in TX so save the Priority there
  end else
  begin
    // Direction <> 0 then Buffer to Parameters (Read RX Buffer)
    Buffer.IsExtended := CANPtr^ and $0001 <> 0;
    Buffer.ID := ((DWORD( CANPtr^ shr 2)) and $000007FF);                              // Get the Standard ID
    Inc(CANPtr);                                                                // Move to the Extended ID Register
    Buffer.ID := Buffer.ID or (DWORD(CANPtr^ shl 17) and $1FFF03FF);
    Inc(CANPtr);
    Buffer.ID := Buffer.ID or (DWORD(CANPtr^ shl 1) and $0001F800);
    if Buffer.IsExtended then
      Buffer.ID := Buffer.ID and $000007FF;
    Buffer.DataCount := CANPtr^ and $000F;
    Inc(CANPtr);                                                                  // Move to C1RXnB1
    Buffer.DataBytes[0] := CANPtr^;
    Buffer.DataBytes[1] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                  // Move to C1RXnB2
    Buffer.DataBytes[2] := CANPtr^;
    Buffer.DataBytes[3] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                  // Move to C1RXnB3
    Buffer.DataBytes[4] := CANPtr^;
    Buffer.DataBytes[5] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                  // Move to C1RXnB4
    Buffer.DataBytes[6] := CANPtr^;
    Buffer.DataBytes[7] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                  // Move to C1RXnCON
  end
end;

// *****************************************************************************
//  procedure dsPIC30_Style_TX_Buffer
//     Parameters:
//
//     Returns: None
//
//     Description:   Fills the passed PCANRawBuffer with the more user friendly data
//                    the buffers are filled with copies of what the perphial registers need
//
// *****************************************************************************
{$IFDEF dsPIC30}
procedure dsPIC30_Style_TX_Buffer(CANPtr: ^Word; var Buffer: TCANBuffer; Priority: Byte);
begin
  CANPtr^ := ((Buffer.ID shl 5) and $0000F800);                                 // Setup the Standard ID
  CANPtr^ := CANPtr^ or ((Buffer.ID shl 2) and $000000FC);
  if Buffer.IsExtended then
    CANPtr^ := CANPtr^ or $00000001;                                            // Setup if it is an extended ID
  Inc(CANPtr);                                                                  // Move to the Extended ID
  CANPtr^ := DWORD( (Buffer.ID shr 13) and $0000F000);
  CANPtr^ := CANPtr^ or ((Buffer.ID shr 17) and $000000FF);
  Inc(CANPtr);                                                                  // Move to the DLC and the rest of the EID
  CANPtr^ := ((Buffer.ID shr 1) and $0000FC00);                                 // Put EID 0..5 into bits 10..15
  CANPtr^ := CANPtr^ or Buffer.DataCount;                                       // Put Data Length
  Inc(CANPtr);                                                                  // Move to Byte 1 and Byte 2
  CANPtr^ := Buffer.DataBytes[0] or Buffer.DataBytes[1] shl 8;
  Inc(CANPtr);                                                                  // Move to Byte 3 and Byte 4
  CANPtr^ := Buffer.DataBytes[2] or Buffer.DataBytes[3] shl 8;
  Inc(CANPtr);                                                                  // Move to Byte 5 and Byte 6
  CANPtr^ := Buffer.DataBytes[4] or Buffer.DataBytes[5] shl 8;
  Inc(CANPtr);                                                                  // Move to Byte 7 and Byte 8
  CANPtr^ := Buffer.DataBytes[6] or Buffer.DataBytes[7] shl 8;
  Inc(CANPtr);
  CANPtr^ := Priority;                                                          // Last Byte not used in TX so save the Priority there
end;
{$ENDIF}

// *****************************************************************************
//  function CANStorage_ReadReceiverBuffer
//     Parameters:
//
//     Returns: True if the return parameters are valid (i.e. there was something to read in the List
//
//     Description:   Loads the passed paramters with the next Buffer Data in the FIFO list
//                    ~260 Cycles to complete for the dsPIC33 and dsPIC30
//
// *****************************************************************************
function CANStorage_ReadReceiverBuffer(List: PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
var
  Tail: PCANRawBuffer;
begin
  Result := False;
  Tail := CurrentTail(List);
  if Tail <> nil then
  begin
    Result := True;
    dsPIC33_DMA_Style_Buffer(CAN_DIRECTION_READ, @(Tail^.SID), Buffer, 0);   // dsPIC33 and the dsPIC30 are the same format for RX Buffers
  end
end;

// *****************************************************************************
//  function CANStorage_LoadTransmitterBuffer
//     Parameters:
//
//     Returns: True if the parameters were loaded into the FIFO buffers
//
//     Description:   Loads the passed paramters into the next empty Buffer FIFO list
//                    ~260 Cycles to complete for the dsPIC33
//                    ~340 Cycles to complete for the dsPIC30
//
// *****************************************************************************
function CANStorage_LoadTransmitterBuffer(List: PCANRawBufferList; var Buffer: TCANBuffer; Priority: Word): Boolean;
var
  Head: PCANRawBuffer;
begin
  Head := NextHead(List);
  Result := Head <> nil;
  if Result then
  begin
    // Data Structure is different between dsPIC30 and dsPIC33
    {$IFDEF dsPIC33} dsPIC33_DMA_Style_Buffer(CAN_DIRECTION_WRITE, @(Head^.SID), Buffer, Priority); {$ELSE}
    {$IFDEF dsPIC30} dsPIC30_Style_TX_Buffer(@(Head^.SID), Buffer, Priority); {$ELSE}
    Error; (*ERROR:  You must define either dsPIC33 or dsPIC30 in your options file*) {$ENDIF} {$ENDIF}
    List^.HeadPtr := Head;                                                      // Mark the new head as full AFTER it is
  end;
end;

end.