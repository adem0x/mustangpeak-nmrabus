unit CANStorage;

{$I Options.inc}

type
  TCAN_DataBytes = array[8] of Byte;
  PCAN_DataBytes = ^TCAN_DataBytes;
  
  // ***************************************************************************
  // CAN Message Buffers in raw form that can be loaded into the CAN controller
  // registers
  //   NOTE: For the dsPIC33 RX and TX are identical, for the dsPIC30 the bit
  //         patterns are different between RX and TX
  // ***************************************************************************
  TCANRawBuffer = record
    SID    : Word;   // Standard Identifier
    EID    : Word;   // Extended Identifier
    EID_DLC: Word;   // More Extended Identifier bits and Data Length Code
    Byte0_1: Word;   // Data Byte 0 and Data Byte 1
    Byte2_3: Word;   // Data Byte 0 and Data Byte 1
    Byte4_5: Word;   // Data Byte 0 and Data Byte 1
    Byte6_7: Word;   // Data Byte 0 and Data Byte 1
    Tag    : Word;   // Dependant on the the microcontroller
  end;
  PCANRawBuffer = ^TCANRawBuffer;
  
const
  RAWBUFFERSIZE = SizeOf(TCANRawBuffer);
  
type
  TCANRawBufferArray = array[0..0] of TCANRawBuffer;
  PCANRawBufferArray = ^TCANRawBufferArray;
  
  TCANRawBufferList = record
    Buffers: PCANRawBufferArray;   // Pointer to the TCANRawBuffer Array where the data is stored (Normal RAM or DMA RAM depending on device)
    BufferEndPtr: PCANRawBuffer;   // Points to the last record in the List - So (BufferEndPtr - Buffers)/RAWBUFFERSIZE is the total number of items in the Buffer
    HeadPtr: PCANRawBuffer;        // Points to the next empty TCANRawBuffer item in the list that is empty [for RX]
    TailPtr: PCANRawBuffer;        // Points to the first full TCANRawBuffer that needs to be serviced [for RX]
  end;
  PCANRawBufferList = ^TCANRawBufferList;
  
function CANStorage_LoadTransmitterBuffer(List: PCANRawBufferList; var ID: DWord; var DataCount: Byte; var DataBytes: TCAN_DataBytes; Priority: Byte; IsExtended: Boolean): Boolean;
function CANStorage_ReadReceiverBuffer(List: PCANRawBufferList; var ID: DWord; var DataCount: Byte; var DataBytes: TCAN_DataBytes; IsExtended: Boolean): Boolean;
procedure CANStorage_InitializeList(ListPtr: PCANRawBufferList; BufferArrayPtr: PCANRawBufferArray; LastBufferPtr: PCANRawBuffer);
  
implementation

procedure CANStorage_InitializeList(ListPtr: PCANRawBufferList; BufferArrayPtr: PCANRawBufferArray; LastBufferPtr: PCANRawBuffer);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.BufferEndPtr := LastBufferPtr;
  ListPtr^.HeadPtr := @BufferArrayPtr^[0];
  ListPtr^.TailPtr := @BufferArrayPtr^[0];
end;

// *****************************************************************************
//  function NextHead(List: PCANRawBufferList): PCANRawBuffer;
//     Parameters:
//
//     Returns: Pointer to the Next Buffer if available, nil if no buffers are available
//
//     Description:   Returns the Next Item in the List available for filling
//
// *****************************************************************************
function NextHead(List: PCANRawBufferList): PCANRawBuffer;
begin
  Result := List^.HeadPtr;                                                      // Take the current head
  if List^.HeadPtr <> List^.TailPtr then                                        // If the list is empty then just return the Head
  begin
    Inc(Result);                                                                // Increment it
    if Result > List^.BufferEndPtr then                                         // Wrap it if necessary
      Result := @List^.Buffers^[0];
    if Result = List^.TailPtr then                                                // If the new Head = Tail then the list is full
      Result := PCANRawBuffer( nil);
  end
end;

// *****************************************************************************
//  function CurrentTail(List: PCANRawBufferList): PCANRawBuffer;
//     Parameters:
//
//     Returns: Pointer to the Current Tail if there is Data available, else nil
//
//     Description:   Returns the Buffer ready to be read from the Buffer
//
// *****************************************************************************
function CurrentTail(List: PCANRawBufferList): PCANRawBuffer;
begin
  if List^.HeadPtr <> List^.TailPtr then
    Result := List^.TailPtr                                                     // Take the current Tail
  else
    Result := PCANRawBuffer( nil);                                              // List is empty
end;

// *****************************************************************************
//  procedure dsPIC33_DMA_Style_Buffer
//     Parameters:
//
//     Returns: None
//
//     Description:   Fills the passed PCANRawBuffer with the more user friendly data
//                    the buffers are filled with copies of what the perphial registers need
//
// *****************************************************************************
procedure dsPIC33_DMA_Style_Buffer(Direction: Byte; CANPtr: ^Word; var ID: DWord; var DataCount: Byte; var DataBytes: TCAN_DataBytes; Priority: Byte; IsExtended: Boolean);
var
  IsStandardID: Boolean;
begin
  if Direction = 0 then
  begin
    // Direction = 0 means Parameters to Buffer (Load TX Buffer)
    CANPtr^ := DWORD((ID shl 2) and $00001FFC);                                        // Setup the Standard ID
    if IsExtended then
      CANPtr^ := CANPtr^ or $0001;                                              // Setup if it is an extended ID
    Inc(CANPtr);                                                                // Move to the Extended ID
    CANPtr^ := DWORD(ID shr 17);                                                // put EID 6..17 into bits 0..11
    Inc(CANPtr);                                                                // Move to the DLC and the rest of the EID
    CANPtr^ := DWORD((ID shr 1) and $0000FC00);                                 // Put EID 0..5 into bits 10..15
    CANPtr^ := CANPtr^ or (Word( DataCount) and $000F);                           // Put Data Length
    Inc(CANPtr);                                                                // Move to Byte 1 and Byte 2
    CANPtr^ := DataBytes[0] or (DataBytes[1] shl 8);
    Inc(CANPtr);                                                                // Move to Byte 3 and Byte 4
    CANPtr^ := DataBytes[2] or (DataBytes[3] shl 8);
    Inc(CANPtr);                                                                // Move to Byte 5 and Byte 6
    CANPtr^ := DataBytes[4] or (DataBytes[5] shl 8);
    Inc(CANPtr);                                                                // Move to Byte 7 and Byte 8
    CANPtr^ := DataBytes[6] or (DataBytes[7] shl 8);
    Inc(CANPtr);
    CANPtr^ := Priority;                                                        // Last Byte not used in TX so save the Priority there
  end else
  begin
    // Direction <> 0 then Buffer to Parameters (Read RX Buffer)
    IsStandardID := CANPtr^ and $0001 <> 0;
    ID := ((DWORD( CANPtr^ shr 2)) and $000007FF);                              // Get the Standard ID
    Inc(CANPtr);                                                                // Move to the Extended ID Register
    ID := ID or (DWORD(CANPtr^ shr 17) and $1FFF03FF);
    Inc(CANPtr);
    ID := ID or (DWORD(CANPtr^ shl 1) and $0000FC00);
    if IsStandardID then
      ID := ID and $000007FF;
    DataCount := CANPtr^ and $000F;
    Inc(CANPtr);                                                                  // Move to C1RXnB1
    DataBytes[0] := CANPtr^;
    DataBytes[1] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                  // Move to C1RXnB2
    DataBytes[2] := CANPtr^;
    DataBytes[3] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                  // Move to C1RXnB3
    DataBytes[4] := CANPtr^;
    DataBytes[5] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                  // Move to C1RXnB4
    DataBytes[6] := CANPtr^;
    DataBytes[7] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                  // Move to C1RXnCON
    CANPtr^ := CANPtr^ and $FF7F;                                                 // Clear the RXFUL flag
  end
end;

// *****************************************************************************
//  procedure dsPIC30_Style_TX_Buffer
//     Parameters:
//
//     Returns: None
//
//     Description:   Fills the passed PCANRawBuffer with the more user friendly data
//                    the buffers are filled with copies of what the perphial registers need
//
// *****************************************************************************
{$IFDEF dsPIC30}
procedure dsPIC30_Style_TX_Buffer(CANPtr: ^Word; var ID: DWord; DataCount: Byte; var DataBytes: TCAN_DataBytes; Priority: Byte; IsExtended: Boolean);
begin
  CANPtr^ := ((ID shl 5) and $0000F800);                                      // Setup the Standard ID
  CANPtr^ := CANPtr^ or ((ID shl 2) and $00001FFC);
  if IsExtended then
    CANPtr^ := CANPtr^ or $00000001;                                          // Setup if it is an extended ID
  Inc(CANPtr);                                                                // Move to the Extended ID
  CANPtr^ := (ID shr 13) or $0000F000;
  CANPtr^ := CANPtr^ or ((ID shr 17) or $000000FF);
  Inc(CANPtr);                                                                // Move to the DLC and the rest of the EID
  CANPtr^ := ((ID shr 1) and $0000FC00);                                      // Put EID 0..5 into bits 10..15
  CANPtr^ := CANPtr^ or DataCount;                                            // Put Data Length
  Inc(CANPtr);                                                                // Move to Byte 1 and Byte 2
  CANPtr^ := Word( DataBytes[0]);
  Inc(CANPtr);                                                                // Move to Byte 3 and Byte 4
  CANPtr^ := Word( DataBytes[2]);
  Inc(CANPtr);                                                                // Move to Byte 5 and Byte 6
  CANPtr^ := Word( DataBytes[4]);
  Inc(CANPtr);                                                                // Move to Byte 7 and Byte 8
  CANPtr^ := Word( DataBytes[6]);
  Inc(CANPtr);
  CANPtr^ := Priority;                                                        // Last Byte not used in TX so save the Priority there

end;
{$ENDIF}

// *****************************************************************************
//  function CANStorage_ReadReceiverBuffer
//     Parameters:
//
//     Returns: True if the return parameters are valid (i.e. there was something to read in the List
//
//     Description:   Loads the passed paramters with the next Buffer Data in the FIFO list
//
// *****************************************************************************
function CANStorage_ReadReceiverBuffer(List: PCANRawBufferList; var ID: DWord; var DataCount: Byte; var DataBytes: TCAN_DataBytes; IsExtended: Boolean): Boolean;
var
  Tail: PCANRawBuffer;
begin
  Result := False;
  Tail := CurrentTail(List);
  if Tail <> nil then
  begin
    Result := True;
    dsPIC33_DMA_Style_Buffer(0, @(Tail^.SID), ID, DataCount, DataBytes, 0, IsExtended);   // dsPIC33 and the dsPIC30 are the same format for RX Buffers
  end
end;

// *****************************************************************************
//  function CANStorage_LoadTransmitterBuffer
//     Parameters:
//
//     Returns: True if the parameters were loaded into the FIFO buffers
//
//     Description:   Loads the passed paramters into the next empty Buffer FIFO list
//
// *****************************************************************************
function CANStorage_LoadTransmitterBuffer(List: PCANRawBufferList; var ID: DWord; var DataCount: Byte; var DataBytes: TCAN_DataBytes; Priority: Byte; IsExtended: Boolean): Boolean;
var
  Head: PCANRawBuffer;
begin
  Head := NextHead(List);
  Result := Head <> nil;
  if Result then
  begin
    // Data Structure is different between dsPIC30 and dsPIC33
    {$IFDEF dsPIC33}
    dsPIC33_DMA_Style_Buffer(0, @(Head^.SID), ID, DataCount, DataBytes, Priority, IsExtended);
    {$ELSE}
    {$IFDEF dsPIC30}
    dsPIC30_Style_TX_Buffer(@(Head^.SID), ID, DataCount, DataBytes, Priority, IsExtended);
    {$ELSE}     
    Error; //ERROR:  You must define either dsPIC33 or dsPIC30 in your options file
    {$ENDIF} {$ENDIF}
    List^.HeadPtr := Head;                                                      // Mark the new head as full AFTER it is
  end;
end;

end.