unit CANStorage;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-04-01:   1.0.0.0 Created
//
// * Description:
//    Implements a FIFO data structure that can be overlayed onto DSPRAM and DMA transfers
//    for the ECAN Peripheral or overlayed in normal RAM to add FIFO data structures
//    for the dsPIC30 CAN Peripheral.
//    It also implements functions to convert a easy to use CAN data struture (TCANBuffer) into
//    the SID, EID, DLC, ect bit formats needed for the CAN Modules (TCANRAWBuffer)
//
// ******************************************************************************

{$I Options.inc}

const
  CAN_DIRECTION_READ = 1;
  CAN_DIRECTION_WRITE = 0;

type
  TCAN_DataBytes = array[8] of Byte;
  PCAN_DataBytes = ^TCAN_DataBytes;
  
  // ***************************************************************************
  // CAN Message Buffers in raw form that can be loaded into the CAN controller
  // registers
  //   NOTE: For the dsPIC33 RX and TX are identical, for the dsPIC30 the bit
  //         patterns are different between RX and TX
  // ***************************************************************************
  TCANRawBuffer = record
    Word0    : Word;   // if Standard Message then SID else EID upper Bits
    Word1    : Word;   // if Standard Message then Data Length Code else low bits of EID and upper bits of SID
    Word2    : Word;   // if Standard Message then Data 0 and Data 1 else low bits of SID and Data Length Code
    Word3    : Word;   // if Standard Message then Data 2 and Data 3 else Data 0 and Data 1
    Word4    : Word;   // if Standard Message then Data 4 and Data 5 else Data 2 and Data 3
    Word5    : Word;   // if Standard Message then Data 6 and Data 7 else Data 4 and Data 5
    Word6    : Word;   // if Standard Message then, not used, else Data 6 and Data 7
    Word7    : Word;   // dsPIC33 only, For TX not used for RX the Filter that passed the message
  end;
  PCANRawBuffer = ^TCANRawBuffer;
  
 // ***************************************************************************
  // CAN Message Buffers in user friendly form that can be easily maniuplated then
  // loaded into the Raw CAN FIFOs
  // ***************************************************************************
  TCANBuffer = record
    ID: DWord;
    DataCount: Byte;
    DataBytes: TCAN_DataBytes;
    IsExtended: Boolean;
  end;
  PCANBuffer = ^TCANBuffer;
  
const
  RAWBUFFERSIZE = SizeOf(TCANRawBuffer);
  
type
  TCANRawBufferArray = array[0..0] of TCANRawBuffer;
  PCANRawBufferArray = ^TCANRawBufferArray;
  
  TCANRawBufferList = record
    Buffers: PCANRawBufferArray;   // Pointer to the TCANRawBuffer Array where the data is stored (Normal RAM or DMA RAM depending on device)
    Size: Byte;                    // Number of Buffers in the List
    Head: PCANRawBuffer;           // Points to the Next empty item in the list (may point to a used item if Count = Size so this comparison needs to be checked)
    Tail: PCANRawBuffer;           // Points to the first used item in the list
    Count: Byte;                   // Number of Items in the List
  end;
  PCANRawBufferList = ^TCANRawBufferList;
  


function CANStorage_WriteToList(List: PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
function CANStorage_ReadFromList(List: PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
procedure CANStorage_InitializeList(ListPtr: PCANRawBufferList; BufferArrayPtr: PCANRawBufferArray; ListLength: Byte);
procedure LoadBufferAndWriteToList(List: PCANRawBufferList; ID: DWORD; ByteCount, Byte0, Byte1, Byte2, Byte3, Byte4, Byte5, Byte6, Byte7: Byte; IsExtended: Boolean);

function CANStorage_NextHead(List: PCANRawBufferList): PCANRawBuffer;
function CANStorage_NextTail(List: PCANRawBufferList): PCANRawBuffer;
function CANStorage_Head(List: PCANRawBufferList): PCANRawBuffer;
function CANStorage_Tail(List: PCANRawBufferList): PCANRawBuffer;
procedure CANStorage_IncHead(List: PCANRawBufferList);
procedure CANStorage_IncTail(List: PCANRawBufferList);


implementation

// *****************************************************************************
//  procedure LoadBufferAndWriteToList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the RawBufferArray
//              LasterBuffer   : Pointer to the last item in the RawBufferArray
//
//  Result:
//
//  Description: Stores the passed Buffer Information into the CAN Storage Buffer in the passed list
// *****************************************************************************
procedure LoadBufferAndWriteToList(List: PCANRawBufferList; ID: DWORD; ByteCount, Byte0, Byte1, Byte2, Byte3, Byte4, Byte5, Byte6, Byte7: Byte; IsExtended: Boolean);
var
  Buffer: TCANBuffer;
begin
  Buffer.ID := ID;
  Buffer.DataCount := ByteCount;
  Buffer.DataBytes[0] := Byte0;
  Buffer.DataBytes[1] := Byte1;
  Buffer.DataBytes[2] := Byte2;
  Buffer.DataBytes[3] := Byte3;
  Buffer.DataBytes[4] := Byte4;
  Buffer.DataBytes[5] := Byte5;
  Buffer.DataBytes[6] := Byte6;
  Buffer.DataBytes[7] := Byte7;
  Buffer.IsExtended := IsExtended;
  CANStorage_WriteToList(List, Buffer)
end;

// *****************************************************************************
//  procedure CANStorage_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the RawBufferArray
//              LasterBuffer   : Pointer to the last item in the RawBufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure CANStorage_InitializeList(ListPtr: PCANRawBufferList; BufferArrayPtr: PCANRawBufferArray; ListLength: Byte);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.Size := ListLength;
  ListPtr^.Head := @BufferArrayPtr^[0];
  ListPtr^.Tail := @BufferArrayPtr^[0];
  ListPtr^.Count := 0;
end;

function CANStorage_NextHead(List: PCANRawBufferList): PCANRawBuffer;
begin
  if List^.Count < List^.Size then
  begin
    Result := List^.Head;                                                       // Take the current head
    Inc(Result);                                                                // Increase it the size of a TCANRawBuffer
    if Result > (@List^.Buffers^[0] + Size) then                                // Wrap it if necessary
     Result := @List^.Buffers^[0];
  end
end;

function CANStorage_NextTail(List: PCANRawBufferList): PCANRawBuffer;
begin
  if List^.Count > 0 then
  begin
    Result := List^.Tail;                                                       // Take the current head
    Inc(Result);                                                                // Increase it the size of a TCANRawBuffer
    if Result > (@List^.Buffers^[0] + Size) then                                // Wrap it if necessary
     Result := @List^.Buffers^[0];
  end
end;

function CANStorage_Head(List: PCANRawBufferList): PCANRawBuffer;
begin
  if List^.Count < List^.Size then
    Result := List^.Head
  else
    Result := PCANRawBuffer( nil)
end;

function CANStorage_Tail(List: PCANRawBufferList): PCANRawBuffer;
begin
  if List^.Count > 0 then
    Result := List^.Tail
  else
    Result := PCANRawBuffer( nil)
end;

procedure CANStorage_IncHead(List: PCANRawBufferList);
var
  Temp: PCANRawBuffer;
begin
  if List^.Count < List^.Size then
  begin
    Temp := List^.Head;
    Inc(Temp);                                                                // Increase it the size of a TCANRawBuffer
    if Temp > (@List^.Buffers^[0] + Size) then                                // Wrap it if necessary
     Temp := @List^.Buffers^[0];
    List^.Head := Temp
  end;
  Inc(List^.Count);
end;

procedure CANStorage_IncTail(List: PCANRawBufferList);
var
  Temp: PCANRawBuffer;
begin
  if List^.Count > 0 then
  begin
    Temp := List^.Tail;
    Inc(Temp);                                                                // Increase it the size of a TCANRawBuffer
    if Temp > (@List^.Buffers^[0] + Size) then                                // Wrap it if necessary
     Temp := @List^.Buffers^[0];
    List^.Tail := Temp
  end;
  Dec(List^.Count)
end;


// *****************************************************************************
//  procedure dsPIC33_DMA_Style_Buffer
//     Parameters:
//
//     Returns: None
//
//     Description:   Fills the passed PCANRawBuffer with the more user friendly data
//                    the buffers are filled with copies of what the perphial registers need
//
//                     NOTE:  The datasheet for the dsPIC33FJ256GP710A is TOTALLY FREAKING WRONG
//                            in the Bit Pattern for the SID, EID, DLC words in the Buffers...
//
//
//                                     This is the correct bit pattern.
//  Datasheet defined SID - Word 0     |   U  |   U  |   U  |EID-17|EID-16|EID-15|EID-14|EID-13|EID-12|EID-11|EID-10|EID-9 |EID-8 |EID-7 |  SRR |  EID |
//  Datasheet defined EID - Word 1     |   U  |   U  |   U  |   U  |EID-6 |EID-5 |EID-4 |EID-3 |EID-2 |EID-1 |EID-0 |SID-10 |SID-9 |SID-8 |SID-7 |SID-6|
//  Datasheet defined EID - Word 2     |SID-5 |SID-4 |SID-3 |SID-2 |SID-1 |SID-0 |  RTR |  RB1 |   U  |   U  |   U  |   RB0 | DCL-3| DCL-2| DCL-1| DCL-0|
//
//  The example code for the ECAN shows in the comments what is in the datasheet
//  BUT.....  The code does exactly what I show above!!!!  Verified the datasheet is wrong
// *****************************************************************************
procedure dsPIC33_DMA_Style_Buffer(Direction: Byte; CANPtr: ^Word; var Buffer: TCANBuffer);
begin
  if Direction = CAN_DIRECTION_WRITE then
  begin  
    // Direction = 0 means Parameters to Buffer (Load TX Buffer)
    if Buffer.IsExtended then
    begin
      CANPtr^ := DWORD(Buffer.ID shr 16) and $1FFC;                             // Setup the Extended iD 7..17
      CANPtr^ := CANPtr^ or $0001;                                              // Setup if it is an extended ID
      Inc(CANPtr);                                                              // Move to the Extended ID
      CANPtr^ := DWORD(Buffer.ID shr 6) and $0FFF;                              // put SID 0..6 into bits 5..11 and SID 6..10 in bits 0..4
      Inc(CANPtr);                                                              // Move to the DLC and the rest of the EID
      CANPtr^ := DWORD((Buffer.ID shl 10) and $FC00);                           // Put SID 0..5 into bits 10..15
      CANPtr^ := CANPtr^ or (Word( Buffer.DataCount) and $000F);                // Put Data Length in the last 4 bits
    end else
    begin
      CANPtr^ := DWORD(Buffer.ID shl 2) and $007FF;                             // SID
      Inc(CANPtr);                                                              // EID is not used
      CANPtr^ := Buffer.DataCount;                                              // EID/DLC does not use the EID bits
    end;
    Inc(CANPtr);                                                                // Move to Byte 1 and Byte 2
    CANPtr^ := Buffer.DataBytes[0] or (Buffer.DataBytes[1] shl 8);
    Inc(CANPtr);                                                                // Move to Byte 3 and Byte 4
    CANPtr^ := Buffer.DataBytes[2] or (Buffer.DataBytes[3] shl 8);
    Inc(CANPtr);                                                                // Move to Byte 5 and Byte 6
    CANPtr^ := Buffer.DataBytes[4] or (Buffer.DataBytes[5] shl 8);
    Inc(CANPtr);                                                                // Move to Byte 7 and Byte 8
    CANPtr^ := Buffer.DataBytes[6] or (Buffer.DataBytes[7] shl 8);
    Inc(CANPtr);
  end else
  begin
    // Direction <> 0 then Buffer to Parameters (Read RX Buffer)
    Buffer.IsExtended := CANPtr^ and $0001 <> 0;                                // Word 0
    if Buffer.IsExtended then
    begin
      Buffer.ID := CANPtr^ and $1FFC;
      Buffer.ID := Buffer.ID shl 16;
      Inc(CANPtr);                                                              // Word 1
      Buffer.ID := Buffer.ID or DWORD((CANPtr^ and $0FFF) shl 11);
      Inc(CANPtr);
      Buffer.ID := Buffer.ID or DWORD((CANPtr^ and $FC00) shr 5);               // Word 2
    end else
    begin
      Buffer.ID := (CANPtr^ and $1FFC) shr 2;                                   // Word 0
      Inc(CANPtr);                                                              // Word 1
      Inc(CANPtr);                                                              // Word 2
    end;
    
 //   Buffer.ID := ((DWORD( CANPtr^ shr 2)) and $000007FF);                       // Get the Standard ID
 //   Inc(CANPtr);                                                                // Move to the Extended ID Register
 //   Buffer.ID := Buffer.ID or (DWORD(CANPtr^ shl 17) and $1FFF03FF);
 //   Inc(CANPtr);
  //  Buffer.ID := Buffer.ID or (DWORD(CANPtr^ shl 1) and $0001F800);
  //  if Buffer.IsExtended then
   //   Buffer.ID := Buffer.ID and $000007FF;
    Buffer.DataCount := CANPtr^ and $000F;                                      // Word 2
    Inc(CANPtr);                                                                // Move to C1RXnB1
    Buffer.DataBytes[0] := CANPtr^;
    Buffer.DataBytes[1] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                // Move to C1RXnB2
    Buffer.DataBytes[2] := CANPtr^;
    Buffer.DataBytes[3] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                // Move to C1RXnB3
    Buffer.DataBytes[4] := CANPtr^;
    Buffer.DataBytes[5] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                // Move to C1RXnB4
    Buffer.DataBytes[6] := CANPtr^;    
    Buffer.DataBytes[7] := CANPtr^ shr 8;
    Inc(CANPtr);                                                                // Move to C1RXnCON
  end
end;

// *****************************************************************************
//  procedure dsPIC30_Style_TX_Buffer
//     Parameters:
//
//     Returns: None
//
//     Description:   Fills the passed PCANRawBuffer with the more user friendly data
//                    the buffers are filled with copies of what the perphial registers need
//
// *****************************************************************************
{$IFDEF dsPIC30}
procedure dsPIC30_Style_TX_Buffer(CANPtr: ^Word; var Buffer: TCANBuffer);
begin
  CANPtr^ := ((Buffer.ID shl 5) and $0000F800);                                 // Setup the Standard ID
  CANPtr^ := CANPtr^ or ((Buffer.ID shl 2) and $000000FC);
  if Buffer.IsExtended then
    CANPtr^ := CANPtr^ or $00000001;                                            // Setup if it is an extended ID
  Inc(CANPtr);                                                                  // Move to the Extended ID
  CANPtr^ := DWORD( (Buffer.ID shr 13) and $0000F000);
  CANPtr^ := CANPtr^ or ((Buffer.ID shr 17) and $000000FF);
  Inc(CANPtr);                                                                  // Move to the DLC and the rest of the EID
  CANPtr^ := ((Buffer.ID shr 1) and $0000FC00);                                 // Put EID 0..5 into bits 10..15
  CANPtr^ := CANPtr^ or Buffer.DataCount;                                       // Put Data Length
  Inc(CANPtr);                                                                  // Move to Byte 1 and Byte 2
  CANPtr^ := Buffer.DataBytes[0] or Buffer.DataBytes[1] shl 8;
  Inc(CANPtr);                                                                  // Move to Byte 3 and Byte 4
  CANPtr^ := Buffer.DataBytes[2] or Buffer.DataBytes[3] shl 8;
  Inc(CANPtr);                                                                  // Move to Byte 5 and Byte 6
  CANPtr^ := Buffer.DataBytes[4] or Buffer.DataBytes[5] shl 8;
  Inc(CANPtr);                                                                  // Move to Byte 7 and Byte 8
  CANPtr^ := Buffer.DataBytes[6] or Buffer.DataBytes[7] shl 8;
  Inc(CANPtr);
end;
{$ENDIF}


// *****************************************************************************
//  function CANStorage_ReadFromList
//     Parameters:
//
//     Returns: True if the return parameters are valid (i.e. there was something to read in the List
//
//     Description:   Loads the passed paramters with the next Buffer Data in the FIFO list
//                    ~260 Cycles to complete for the dsPIC33 and dsPIC30
//
// *****************************************************************************
function CANStorage_ReadFromList(List: PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
var
  Tail: PCANRawBuffer;
begin
  Result := False;
  Tail := CANStorage_Tail(List);
  if Tail <> nil then
  begin
    dsPIC33_DMA_Style_Buffer(CAN_DIRECTION_READ, @Tail^.Word0, Buffer);         // dsPIC33 and the dsPIC30 are the same format for RX Buffers
    CANStorage_IncTail(List);
    Result := True;
  end
end;

// *****************************************************************************
//  function CANStorage_WriteToList
//     Parameters:
//
//     Returns: True if the parameters were loaded into the FIFO buffers
//
//     Description:   Loads the passed paramters into the next empty Buffer FIFO list
//                    ~260 Cycles to complete for the dsPIC33
//                    ~340 Cycles to complete for the dsPIC30
//
// *****************************************************************************
function CANStorage_WriteToList(List: PCANRawBufferList; var Buffer: TCANBuffer): Boolean;
var
  Head: PCANRawBuffer;
begin
  Result := False;
  Head := CANStorage_Head(List);
  if Head <> PCANRawBuffer( nil) then
  begin
    // Data Structure is different between dsPIC30 and dsPIC33
    {$IFDEF dsPIC33} dsPIC33_DMA_Style_Buffer(CAN_DIRECTION_WRITE, @(Head^.Word0), Buffer); {$ELSE}
    {$IFDEF dsPIC30} dsPIC30_Style_TX_Buffer(@(Head^.Word0), Buffer); {$ELSE}
    Error; (*ERROR:  You must define either dsPIC33 or dsPIC30 in your options file*) {$ENDIF} {$ENDIF}
    CANStorage_IncHead(List)
  end;
end;

end.