unit CAN_Storage;
// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2012.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2012-04-01:   1.0.0.0 Created
//
// * Description:
//    Implements a FIFO data structure that can be overlayed onto DSPRAM and DMA transfers
//    for the ECAN Peripheral or overlayed in normal RAM to add FIFO data structures
//    for the dsPIC33 CAN Peripheral.
//    It also implements functions to convert a easy to use CAN data struture (TCANBuffer) into
//    the SID, EID, DLC, ect bit formats needed for the CAN Modules (TCANRAWBuffer)
//
// ******************************************************************************

{$I Options.inc}

const
  CAN_DIRECTION_READ = 1;
  CAN_DIRECTION_WRITE = 0;

type
  TCAN_DataBytes = array[8] of Byte;
  PCAN_DataBytes = ^TCAN_DataBytes;
  
  // ***************************************************************************
  // CAN Message Buffers in raw form that can be loaded into the CAN controller
  // registers
  //   NOTE: For the dsPIC33 RX and TX are identical, for the dsPIC30 the bit
  //         patterns are different between RX and TX
  // ***************************************************************************
  TCANRawBuffer = record
    Word0    : Word;   // if Standard Message then SID else EID upper Bits
    Word1    : Word;   // if Standard Message then Data Length Code else low bits of EID and upper bits of SID
    Word2    : Word;   // if Standard Message then Data 0 and Data 1 else low bits of SID and Data Length Code
    Word3    : Word;   // if Standard Message then Data 2 and Data 3 else Data 0 and Data 1
    Word4    : Word;   // if Standard Message then Data 4 and Data 5 else Data 2 and Data 3
    Word5    : Word;   // if Standard Message then Data 6 and Data 7 else Data 4 and Data 5
    Word6    : Word;   // if Standard Message then, not used, else Data 6 and Data 7
    Word7    : Word;   // dsPIC33 only, For TX not used for RX the Filter that passed the message
  end;
  PCANRawBuffer = ^TCANRawBuffer;
  
 // ***************************************************************************
  // CAN Message Buffers in user friendly form that can be easily maniuplated then
  // loaded into the Raw CAN FIFOs
  // ***************************************************************************
  TCANBuffer = record
    ID: DWord;
    DataCount: Byte;
    DataBytes: TCAN_DataBytes;
    IsExtended: Boolean;
  end;
  PCANBuffer = ^TCANBuffer;
  
type
  TCANRawBufferArray = array[0..0] of TCANRawBuffer;                            // Allows any length array within the TCANRawBufferList
  PCANRawBufferArray = ^TCANRawBufferArray;
  

  TCANRawBufferList = record
    Buffers: PCANRawBufferArray;                                                // Pointer to the TCANRawBuffer Array where the data is stored (Normal RAM or DMA RAM depending on device)
    Size: Byte;                                                                 // Number of Buffers in the List
    Head: PCANRawBuffer;                                                        // Points to the Next empty item in the list (may point to a used item if Count = Size so this comparison needs to be checked)
    Tail: PCANRawBuffer;                                                        // Points to the first used item in the list
    Count: Byte;                                                                // Number of Items in the List
  end;
  PCANRawBufferList = ^TCANRawBufferList;
  
const
  CES_TRANSMITTING = $0001;

type
  TCAN_Engine = record
    State: Word;                            // See the CES_xxx constants
    TransmittingList: PCANRawBufferList;    // List that has an item being transmitted
  end;
  

procedure CANStorage_Initialize;
procedure CANStorage_InitializeList(ListPtr: PCANRawBufferList; BufferArrayPtr: PCANRawBufferArray; ListLength: Byte);
function CANStorage_NextHead(List: PCANRawBufferList): PCANRawBuffer;
function CANStorage_NextTail(List: PCANRawBufferList): PCANRawBuffer;
function CANStorage_Head(List: PCANRawBufferList): PCANRawBuffer;
function CANStorage_Tail(List: PCANRawBufferList): PCANRawBuffer;
function CANStorage_IncHead(List: PCANRawBufferList): Boolean;
function CANStorage_IncTail(List: PCANRawBufferList): Boolean;
procedure CANStorage_FlushList(List: PCANRAwBufferList);
function CANStorage_Transmitting: Boolean;

var
  CAN_Engine: TCAN_Engine;

implementation

procedure CANStorage_Initialize;
begin
  CAN_Engine.State := 0;
end;

procedure CANStorage_FlushList(List: PCANRAwBufferList);
begin
  List^.Count := 0
end;

function CANStorage_Transmitting: Boolean;
begin
  Result := CAN_Engine.State and CES_TRANSMITTING <> 0
end;

// *****************************************************************************
//  procedure CANStorage_InitializeList;
//
//  Parameters: ListPtr        : Pointer to the FIFO buffer Lists
//              BufferArrayPtr : Pointer to the first item in the RawBufferArray
//              LasterBuffer   : Pointer to the last item in the RawBufferArray
//
//  Result:
//
//  Description: Initializes a FIFO Buffer Array
// *****************************************************************************
procedure CANStorage_InitializeList(ListPtr: PCANRawBufferList; BufferArrayPtr: PCANRawBufferArray; ListLength: Byte);
begin
  ListPtr^.Buffers := BufferArrayPtr;
  ListPtr^.Size := ListLength;
  ListPtr^.Head := @BufferArrayPtr^[0];
  ListPtr^.Tail := @BufferArrayPtr^[0];
  ListPtr^.Count := 0;
end;

// *****************************************************************************
//  function CANStorage_NextHead;
//
//  Parameters: List            : Pointer to the Raw Buffer List to extract the Next Head for
//
//  Result:  Pointer to the TCANRawBuffer object that is at the next head of the list.  If the list is
//           full and the next Head can not accessed it returns nil
//
//  Description:
// *****************************************************************************
function CANStorage_NextHead(List: PCANRawBufferList): PCANRawBuffer;
begin
  if List^.Count < List^.Size then
  begin
    Result := List^.Head;                                                       // Take the current head
    Inc(Result);                                                                // Increase it the size of a TCANRawBuffer
    if Result > (@List^.Buffers^[0] + Size) then                                // Wrap it if necessary
     Result := @List^.Buffers^[0];
  end
end;

// *****************************************************************************
//  function CANStorage_NextTail;
//
//  Parameters: List            : Pointer to the Raw Buffer List to extract the Next Tail for
//
//  Result:  Pointer to the TCANRawBuffer object that is at the next tail of the list, if there
//           are filled buffers in the list.  If the list is empty it returns nil
//
//  Description:
// *****************************************************************************
function CANStorage_NextTail(List: PCANRawBufferList): PCANRawBuffer;
begin
  if List^.Count > 0 then
  begin
    Result := List^.Tail;                                                       // Take the current head
    Inc(Result);                                                                // Increase it the size of a TCANRawBuffer
    if Result > (@List^.Buffers^[0] + Size) then                                // Wrap it if necessary
     Result := @List^.Buffers^[0];
  end
end;


// *****************************************************************************
//  function CANStorage_Head;
//
//  Parameters: List            : Pointer to the Raw Buffer List to extract the Head for
//
//  Result:  Pointer to the TCANRawBuffer object that is at the head of the list
//
//  Description:
// *****************************************************************************
function CANStorage_Head(List: PCANRawBufferList): PCANRawBuffer;
begin
  if List^.Count < List^.Size then
    Result := List^.Head
  else
    Result := PCANRawBuffer( nil)
end;

// *****************************************************************************
//  function CANStorage_Head;
//
//  Parameters: List            : Pointer to the Raw Buffer List to extract the Head for
//
//  Result:  Pointer to the TCANRawBuffer object that is at the head of the list
//
//  Description:
// *****************************************************************************
function CANStorage_Tail(List: PCANRawBufferList): PCANRawBuffer;
begin
  if List^.Count > 0 then
    Result := List^.Tail
  else
    Result := PCANRawBuffer( nil)
end;

// *****************************************************************************
//  procedure CANStorage_IncHead;
//
//  Parameters: List            : Pointer to the Raw Buffer List to extract Increase the Head for
//
//  Result:  Returns True if the list is not full and the head pointer was increased
//
//  Description:
// *****************************************************************************
function CANStorage_IncHead(List: PCANRawBufferList): Boolean;
var
  Temp: PCANRawBuffer;
begin
  Result := False;
  if List^.Count < List^.Size then
  begin
    Temp := List^.Head;
    Inc(Temp);                                                                // Increase it the size of a TCANRawBuffer
    if Temp > (@List^.Buffers^[0] + Size) then                                // Wrap it if necessary
     Temp := @List^.Buffers^[0];
    List^.Head := Temp;
    Result := True
  end;
  Inc(List^.Count);
end;

// *****************************************************************************
//  procedure CANStorage_IncTail;
//
//  Parameters: List            : Pointer to the Raw Buffer List to extract Increase the Tail for
//
//  Result:  Returns True if the list is not empty and the tail pointer was increased
//
//  Description:
// *****************************************************************************
function CANStorage_IncTail(List: PCANRawBufferList): Boolean;
var
  Temp: PCANRawBuffer;
begin
  Result := False;
  if List^.Count > 0 then
  begin
    Temp := List^.Tail;
    Inc(Temp);                                                                // Increase it the size of a TCANRawBuffer
    if Temp > (@List^.Buffers^[0] + Size) then                                // Wrap it if necessary
     Temp := @List^.Buffers^[0];
    List^.Tail := Temp;
    Result := True;
  end;
  Dec(List^.Count)
end;

end.